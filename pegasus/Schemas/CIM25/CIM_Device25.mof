// ===================================================================
// Title:       Devices MOF specification 2.5
// Filename:    CIM_Device25.mof
// Version:     2.5
// Release:     0
// Date:        06/12/2001
// ===================================================================
// Copyright "2001" Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release cited should always be noted.
// ===================================================================
// Description: The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//              by other working groups, are omitted.
// ==================================================================
// Author:      DMTF System and Devices Working Group
// ==================================================================
// Date:  04/14/1998 - Version 2.0
//        06/23/1998 - V2.0 Errata
//      - CR222, References to the "Resource" component in 
//          CIM_ComputerSystemResource association and its
//          subclasses incorrect - Should be PartComponent
//      - CR225, Antecedent reference should be CIM_CurrentSensor
//          in the AssociatedSupplyCurrentSensor relationship
//      - CR226, Add ArrayType("Indexed") and update descriptions
//          for CIM_NetworkAdapter.NetworkAddresses and its
//          overrides
//      - CR227, UninterruptablePowerSupply should be 
//          Uninterruptible
//      - CR235, Format for specifying propagated value uses
//                period, not colon
//      09/29/1998 - Version 2.1
//      - CR236, Add ModelCorrespondence qualifier to properties
//          of CIM_MonitorResolution 
//      - CR243, Add AutoSense and MaxSpeed properties to 
//          CIM_NetworkAdapter
//      - CR244a, Extend the enumeration of CIM_Processor.Family, 
//          Add a new Processor property, OtherFamilyDescription
//      - CR245, Add CIM_AllocatedDMA association
//      - CR254, Add CIM_DeviceErrorCounts object and related
//          association, CIM_ErrorCountersForDevice
//      - CR259, Add DesiredSpeed property and SetSpeed method 
//          to CIM_Fan
//      - CR261a, Add two properties to CIM_Battery, ExpectedLife
//          and MaxRechargeTime
//      - CR265, Address "cleaning" related to a CIM_Media
//          AccessDevice
//      - CR266, Add CIM_AlarmDevice and association
//      - CR274, Remove repetition of the Values array from 
//          property Descriptions
//      - CR275, Update DMI Master.MIF mappings
//      - CR288a, Add AssociatedProcessorMemory relationship
//      - CR292, Add ModelCorrespondence to 'linked' properties
//          - CR294, Remove key-qualifier from 'StartingAddress' in
//                CIM_BIOSLoadedInNV
//      10/14/1998 - Version 2.1.1
//      - Missed CR271a, Add Stepping property to CIM_Processor
//      06/11/1999 - Version 2.2
//      - CR297, Add Sparc processors to the enum, Processor.Family
//      - CR308a, Create DeviceIdentity relationship
//      - CR316, Add OrderIndex to BasedOn
//      - CR318c, Add processors to the enum, Processor.Family
//      - CR325, Load balancing (Add LoadBalancedGroup boolean to
//          ExtraCapacityGroup, Create new NetworkAdapter
//          RedundancyComponent and NetworkVirtualAdapter 
//                associations)
//      - CR326, Add properties, LoadedOnDevice and UpgradeableOn
//          Device to DeviceSoftware
//      - CR327b, Update the PCIController class and add new 
//          subclasses, PCIDevice and PCIBridge
//      - CR328, New MappingStrings, Descriptions and properties in 
//          SCSIController and SCSIInterface
//      - CR329a, Add to the MediaAccessDevice Capabilities array,
//          (enum) / Also, add a MediaIsLocked property and 
//                LockMedia method / Create subclass, DVDDevice
//      - CR330a, Add properties and methods to AlarmDevice
//      - CR331, Create IDE, PCMCIA and InfraredController 
//                subclasses of Controller / Add to the enum for 
//                Controller.ProtocolSupported
//      - CR332, Add PartitionType and PartitionSubtype properties
//          to DiskPartition / Update class Description
//      - CR333a, Extensions to and clarifications of StorageExtent
//      - CR334, Clarify the StorageRedundancyGroup.TypeOfAlgorithm
//          enum and add properties to the class / Create an
//          ExtentRedundancyComponent association
//      - CR335a, Updates to the Printer object
//      - CR336, New Printer-related classes and associations
//      - CR341, Create new Modem classes, properties and 
//          associations
//      - CR342, Create OOBAlert and WakeUpServices and 
//                associations to NetworkAdapter 
//      - CR343, Create new NetworkAdapter classes, properties 
//          and associations
//      - CR344, Changes to POTSModem and movement of some 
//          properties up to CIM_Modem
//      - CR345b, Changes to Sensor and its subclasses
//      - CR346, Add WatchDog object
//      - CR347, Add a UniqueID property to Processor
//      - CR348, Create AGPVideoController and AGPSoftware
//          Feature classes
//      - CR351, Add TimeOfDeviceReset to ControlledBy
//      - CR355a, Use Values-ValueMap qualifiers in DeviceError
//                Counts.ResetCounter and AlarmDevice.SetUrgency / 
//          Update the method descriptions indicating that 
//                Values-ValueMap qualifiers can be defined for 
//                return codes
//      - CR356a, Keys on all associations either explicitly or
//          via inheritance
//      - CR357, Remove company references
//      - CR360, Add VendorID to ConnectionBasedModem
//      - CR366, Clarify the Description for ResidesOnExtent
//          - CR372, Create LogicalPort and PortOnDevice 
//      - CR373, Define the USB Model
//      - CR375, Update descriptions and enumerations / Add new
//          classes - SuppliesPower, VideoControllerResolution,
//          VideoSetting / Create new properties - IRQ.Hardware,
//          Security in MediaAccessDevice, ParallelController and
//          SerialController, VideoController.CurrentNumberOf
//          Colors, ScreenHeight and Width in DesktopMonitor, 
//          NetworkAdapter.FullDuplex, Processor.CPUStatus,
//                MemoryMappedIO.MappedResource and 3 'storage is 
//                writeable' properties in NonVolatileStorage
//      - CR377, Add "video processor" to Processor.Family
//      - CR379a, Update the DMI MappingStrings
//      - CR380a, Define the Fibre Channel Adapter and Port models
//      - CR381, Update MediaAccessDevice's enumerations and add new
//          properties - LastCleaned, MaxAccessTime, 
//                UncompressedDataRate, LoadTime, UnloadTime / Create
//          MediaPresent.FixedMedia / Update StorageExtent's 
//          enumerations and add a SequentialAccess property /
//          Create TapeDrive.MaxRewindTime
//      - CR382, Create a DiskGroup class and its supporting
//          associations
//      - CR384, Update Processor.UpgradeMethod / Create an
//          ESCONController
//      - CR393a, Define the Tape Library Device Model
//      - CR394, Update Descriptions / Add VolumeSet.VolumeStatus
//          and properties to VolumeSetBasedOnPSExtent (from
//          CR333a)
//      - CR399, Remove SubmitsRequest from CR336
//      - CR405, Add Counter and Gauge qualifiers as appropriate
//      - CR406, Update PartitionSubtype enumeration from CR332
//      - CR407, Add DoorAccessToPhysicalElement and Changer.
//          AuditInProgress
//      - CR408, Update the Description for StorageExtent.
//          ConsumableBlocks (from CR333a)
//      - CR410, Updates to the Fibre Channel Model submitted in
//          CR380a
//      - CR414, Add "Mouse-Optical Sensor" to PointingDevice.
//          PointingType
//      - CR415, Remove OrderOfQueue from QueueForPrintService
//          (added in CR336)
//      - CR417a, Add "N/A" to CacheMemory.Level
//      - CR418a, Add to the enum for CacheMemory.Read and Write
//          Policy / Update Descriptions related to Storage
//          Volume (from CR333a) / Change the association,
//          LogicalDiskBasedOnSoftwareVolume (CR333a) to 
//          LogicalDiskBasedOnVolume
//      - CR420, Miscellaneous syntax and semantic issues
//      - CR421, Defer including some properties of Unimodem from
//          CR341
//      07/06/1999 - Version 2.2.1
//      - CR422, Cut & paste errors (Remove Association qualifier 
//          from LabelReader, MediaAccess and PickerStatInfo; 
//          Add Association qualifier to CIM_VideoSetting)
//      - CR423, Locale should be specified as en_US
//      - CR424, Add CIM_ to the class name for PCIDevice and 
//          PCIBridge / Add Overrides to xxxInDiskGroup 
//          aggregations / Update the Descriptions for Cache
//          Memory Read and WritePolicy
//      - CR425, Update the DMI MappingStrings using the June
//          release of the master.mif
//      07/27/1999 - Version 2.2.2
//      - CR428, Remove underscores from two properties of 
//          PCIDevice 
//  Date  02/18/2000 - Version 2.3
//      - CR429 Modify Description of UserDataStripeDepth in 
//          CIM_ProtectedSpaceExtent
//      - CR431 Update MappingStrings
//      - CR432 Create subclasses of MemoryMappedIO
//      - CR433 Add new properties and enums from Master.MIF and new 
//          ModelCorrespondences 
//      - CR436 Add a place holder for SSA Controller
//      - CR438 Change Intel Processor types to meet Intel legal requirements 
//          in CIM_Processor.Family
//      - CR445e Modify the SpareGroup class to add a Failover method
//      - CR449 Add Itanium processors to CIM_Processor.Family
//      - CR452a Updates to FibrePort
//      - CR457 Miscellaneous StorageExtent and MediaAccessDevice 
//          clarifications
//      - CR460a Add Counter, OctetString and Gauge qualifiers
//      - CR461 Subclass from CIM_ManagedElement StorageError
//      - CR463b Define the necessary classes and associations to 
//          support Message Logs
//      - CR471 Recommended qualifier for CIM_NumericSensor.CurrentReading
//      - CR474 Add Processor types to CIM_Processor.Family
//      - CR475 Add Processor types to CIM_Processor.Family
//  Date 06/09/2000 - Version 2.4
//      - CR479 Miscellaneous Device Model Additions to the Storage and 
//          StorageLibrary Classes
//          1. Add a new property, CellLocation, to the PickerElement class. 
//          2. Add to the enumeration for LabelReader.SupportedFormats.
//          3. Add a new property, Extendable, to TapePartition
//          4. Add a new property, Direction, to BOTH LimitedAccessPort 
//              and InterLibraryPort
//          5. Add six new properties to MediaAccessDevice.
//          6. Define a new association, AssociatedLabelReader
//          7. Update the subclassing of PickerLabelReader and AccessLabelReader
//              to use the association defined in #6.
//          8. Update the description for LimitedAccessPort.
//      - CR486, Further updates to the Storage and Storage Library Models
//          1. Add seek and recovered R/W stats to the class, MediaAccessStatInfo
//          2. Due to the changes in #1, must update the ResetCounters method 
//              in MediaAccessStatInfo.
//          3. Create a new superclass of TapePartition and DiskPartition, 
//              MediaPartition
//          4. Change the subclassing of TapePartition and DiskPartition from 
//              CIM_StorageExtent to CIM_MediaPartition.
//          5. Remove the Bootable boolean from DiskPartition since it is now 
//              found in the MediaPartition superclass.
//      - CR494, Add to the enumerations in CIM_CacheMemory.Associativity
//  Date 07/14/00 - Version 2.4
//      - CR513a, Move Extendable Boolean up to the MediaPartition superclass
//      - CR519   ERRATA CIM 2.3: correct ValueMap syntax errors in 
//                CIM_Processor.Family
//  Date 12/01/2000 Version 2.5
//      - CR527 Add AMD Duron  processors to CIM_Processor.Family
//      - CR528 Add Socket 423 and Socket A (Socket 462) enumerations to 
//          CIM_Processor.UpgradeMethod
//      - CR530 Modify the enumerations in CIM_Processor.Family (Device MOF) 
//      - CR531 Add Transmeta Crusoe  processors's names in CIM_Processor.Family
//      - CR534 Update MappingStrings Qualifiers to stay in sync with 
//              updates to the MASTER.MIF.
//      - CR535 Add "Service Processor" to CIM_Watchdog.MonitoredEntity and 
//          CIM_Watchdog.MonitoredEntityOnLastExpiration enumeration.
//  Date 05/23/2001 - Final Version 2.5
//          Reordered classes to match Visio
//      - CR606 Add the Aggregate qualifier where missing:
//              PrintJobFile, NetworkAdapterRedundancyComponent,
//
// ===================================================================


// ===================================================================
// Generic Pragmas
// ===================================================================
#pragma locale ("en_US")

// ===================================================================
//
//    General Devices 
//
// ===================================================================

// ===================================================================
// DeviceConnection
// ===================================================================
   [Association,
    Description (
     "The DeviceConnection relationship indicates that two or more "
     "Device are connected together.") ] 
class CIM_DeviceConnection : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("A LogicalDevice.") ]
   CIM_LogicalDevice REF Antecedent;
      [Override ("Dependent"),
       Description (
        "A second LogicalDevice connected to the Antecedent Device.") ]
   CIM_LogicalDevice REF Dependent;
      [Description (
        "When several bus and/or connection speeds are possible, the "
        "NegotiatedSpeed property defines the one in use between the "
        "Devices.  Speed is specified in bits per second.  If "
        "connection or bus speeds are not negotiated, or if this "
        "information is not available/important to Device management, "
        "the property should be set to 0."), 
       Units ("Bits per Second"),
       MappingStrings {"MIF.DMTF|Bus Port Association|001.2"}  ]
   uint64 NegotiatedSpeed;
      [Description (
        "When several bus and/or connection data widths are possible, "
        "the NegotiatedDataWidth property defines the one in use "
        "between the Devices.  Data width is specified in bits.  If "
        "data width is not negotiated, or if this information is not "
        "available/important to Device management, the property should "
        "be set to 0."),
       Units ("Bits"),
       MappingStrings {"MIF.DMTF|Bus Port Association|001.3"}  ]
   uint32 NegotiatedDataWidth;
};


// ===================================================================
// DeviceIdentity
// ===================================================================
   [Association,
    Description (
     "CIM_DeviceIdentity indicates that two LogicalDevices "
     "represent different aspects of the same underlying entity. "
     "This association refines the CIM_LogicalIdentity superclass "
     "by restricting it to the Device level and defining its use in "
     "well understood scenarios. One of these scenarios is to "
     "represent that a Device is both a 'bus' entity and a "
     "'functional' entity. For example, a Device could be both a PCI "
     "Device (or a USB Device), as well as a CIM_Keyboard. The other "
     "scenario is where a Device plays multiple functional roles "
     "that can not be distinguished by their hardware realization "
     "alone. For example, a Fibre Channel adapter might have aspects "
     "of both a NetworkAdapter and a SCSIController.") ]
class CIM_DeviceIdentity: CIM_LogicalIdentity {
      [Override ("SystemElement"), 
       Description (
        "SystemElement represents one aspect of the Device.") ]
   CIM_LogicalDevice ref SystemElement;
      [Override ("SameElement"), 
       Description (
        "SameElement represents an alternate aspect of "
        "the System entity.") ]
   CIM_LogicalDevice ref SameElement;
};


// ===================================================================
// WatchDog
// ===================================================================
   [Description (
     "CIM_Watchdog is a timer implemented in system hardware. It "
     "allows the hardware to monitor the state of the Operating"
     "System, BIOS or a software component installed on the "
     "System. If the monitored component fails to re-arm the timer "
     "before its expiration, the hardware assumes that the System is "
     "in a critical state, and could reset the ComputerSystem. This "
     "feature can also be used as an application watchdog timer for "
     "a mission-critical application. In this case, the application "
     "would assume responsibility for re-arming the timer before "
     "expiration.") ]
class CIM_Watchdog : CIM_LogicalDevice {
      [Description (
        "The entity that is currently being monitored by the WatchDog. "
        "This property is used to identify the module that is responsible "
        "for re-arming the watchdog at periodic intervals."), 
       Values {"Unknown", "Other", "Operating System", 
               "Operating System Boot Process", 
               "Operating System Shutdown Process", 
               "Firmware Boot Process", "BIOS Boot Process", "Application", 
               "Service Processor"}  ]
   uint16 MonitoredEntity;
      [MaxLen (256), Description (
        "A string describing more textual information about the "
        "monitored entity ") ]
   string MonitoredEntityDescription;
      [Description (
        "The timeout interval used by the watchdog, in MicroSeconds."), 
       Units ("MicroSeconds") ]
   uint32 TimeoutInterval;
      [Description (
        "Resolution of the timer. For example, if this value is 100, "
        "then the timer can expire anytime between (TimeoutInterval-"
        "100) microseconds or (TimeoutInterval+100) microseconds."),
       Units ("MicroSeconds") ]
   uint32 TimerResolution;
      [Description ("The time of the last timer expiry.") ]
   datetime TimeOfLastExpiration; 
      [Description (
        "Monitored entity at the time of last timer expiry."), 
       Values {"Unknown", "Other", "Operating System", 
               "Operating System Boot Process", 
               "Operating System Shutdown Process", 
               "Firmware Boot Process", "BIOS Boot Process", "Application", 
               "Service Processor"}  ]
   uint16 MonitoredEntityOnLastExpiration;
      [Description (
        "The action that should happen upon the expiry of the watchdog."), 
       Values {"None - Status Only", "System Reset", "System Power Off", 
               "System Power Off, then On", 
               "Generate System NonMaskableInterrupt (NMI)", 
               "Generate System Management Interrupt (SMI)"} ]
   uint16 ActionOnExpiration;
      [Description (
        "A method to re-arm the timer. This method is only used if "
        "the MonitoredEntity is \"Application\". It returns 0 if "
        "successful, 1 if unsupported, and any other value if an "
        "error occurred. In a subclass, the set of possible return "
        "codes could be specified, using a ValueMap qualifier on "
        "the method. The strings to which the ValueMap contents are "
        "'translated' may also be specified in the subclass as a "
        "Values array qualifier.") ]
   uint32 KeepAlive();
};


// ===================================================================
// CoolingDevice
// ===================================================================
   [Description (
     "Capabilities and management of CoolingDevices.") ] 
class CIM_CoolingDevice : CIM_LogicalDevice {
      [Description (
        "ActiveCooling is a boolean indicating that the Cooling"
        "Device provides active (as opposed to passive) cooling.") ]
   boolean ActiveCooling;
};


// ===================================================================
// Refrigeration
// ===================================================================
   [Description (
     "Capabilities and management of a Refrigeration CoolingDevice.") ] 
class CIM_Refrigeration : CIM_CoolingDevice {
};


// ===================================================================
// HeatPipe
// ===================================================================
   [Description (
     "Capabilities and management of a HeatPipe CoolingDevice.") ] 
class CIM_HeatPipe : CIM_CoolingDevice {
};


// ===================================================================
// Fan
// ===================================================================
   [Description (
     "Capabilities and management of a Fan CoolingDevice.") ] 
class CIM_Fan : CIM_CoolingDevice {
      [Description (
        "Indication of whether the fan supports variable speeds.") ]
   boolean VariableSpeed;
      [Description (
        "DesiredSpeed is the currently requested fan speed, " 
        "defined in Revolutions per Minute, when a variable speed fan "
        "is supported (VariableSpeed boolean = TRUE). The current " 
        "speed is determined via a sensor (CIM_Tachometer) that is "
        "associated with the Fan using the CIM_AssociatedSensor "
        "relationship."), 
       Units ("Revolutions per Minute") ]
   uint64 DesiredSpeed;
      [Description (
        "Requests that the Fan speed be set to the " 
        "value specified in the method's input parameter. The return " 
        "value should be 0 if the request was successfully executed, " 
        "1 if the request is not supported and some other value if an " 
        "error occurred. In a subclass, the set of possible "
        "return codes could be specified, using a ValueMap qualifier "
        "on the method. The strings to which the ValueMap contents "
        "are 'translated' may also be specified in the "
        "subclass as a Values array qualifier.") ]
   uint32 SetSpeed (
       [IN] uint64 DesiredSpeed);
};


// ===================================================================
// AssociatedCooling
// ===================================================================
   [Association, Description (
     "Many Devices, such as processors or power supplies, require "
     "their own cooling devices.  This association indicates where "
     "fans or other CoolingDevices are specific to a Device, "
     "versus providing enclosure or cabinet cooling.") ] 
class CIM_AssociatedCooling : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The CoolingDevice.") ]
   CIM_CoolingDevice REF Antecedent;
      [Override ("Dependent"),
       Description ("The LogicalDevice being cooled.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// UserDevice
// ===================================================================
   [Abstract, Description (
     "UserDevices are LogicalDevices that allow a ComputerSystem's "
     "users to input, view or hear data.  It is a superclass from "
     "which other classes, such as Keyboard or DesktopMonitor, "
     "descend.") ] 
class CIM_UserDevice : CIM_LogicalDevice {
      [Description (
        "An indication of whether the Device is locked, preventing "
        "user input or output.") ]
   boolean IsLocked;
};


// ===================================================================
// PointingDevice
// ===================================================================
   [Description (
     "PointingDevice represents those Devices used to 'point' to "
     "regions of a Display.") ] 
class CIM_PointingDevice : CIM_UserDevice {
      [Description ("The type of the pointing device."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9"},
       Values {"Other", "Unknown", "Mouse", "Track Ball", "Track Point",
               "Glide Point", "Touch Pad", "Touch Screen", 
               "Mouse - Optical Sensor"}, 
       MappingStrings {"MIF.DMTF|Pointing Device|003"} ]
   uint16 PointingType;
      [Description (
        "Number of buttons. If the PointingDevice has no buttons, "
        "enter 0."),
       MappingStrings {"MIF.DMTF|Pointing Device|003"} ]
   uint8 NumberOfButtons;
      [Description (
        "Integer indicating whether the PointingDevice is configured "
        "for right (value=2) or left handed operation (value=3). "
        "Also, the values, \"Unknown\" (0) and \"Not Applicable\" (1), "
        "can be defined."),
       Values {"Unknown", "Not Applicable", "Right Handed Operation",
               "Left Handed Operation"} ]
   uint16 Handedness;
      [Description (
        "Tracking resolution of the PointingDevice in Counts per "
        "Inch."),
       Units ("Counts per Inch") ]
   uint32 Resolution;
};


// ===================================================================
// Keyboard
// ===================================================================
   [Description (
     "Capabilities and management of the Keyboard LogicalDevice.") ] 
class CIM_Keyboard : CIM_UserDevice {
      [Description ("Number of function keys on the Keyboard.") ]
   uint16 NumberOfFunctionKeys;
      [Description (
        "A free-form string indicating the format and layout of the "
        "Keyboard."),
       MappingStrings {"MIF.DMTF|Keyboard|004"} ]
   string Layout;
      [Description (
        "An integer indicating whether a hardware-level password is "
        "enabled at the keyboard (value=4), preventing local input. "
        "Other values are:  \"Disabled\" (3), \"Not Implemented\" (5), "
        "\"Other\" (1) and \"Unknown\" (2)."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "Disabled", "Enabled", 
               "Not Implemented"},
       MappingStrings {"MIF.DMTF|System Hardware Security|001.2"} ]
   uint16 Password;
};


// ===================================================================
// Display
// ===================================================================
   [Abstract, Description (
     "Display is a superclass for grouping the miscellaneous display "
     "devices that exist.") ] 
class CIM_Display : CIM_UserDevice {
};


// ===================================================================
// DesktopMonitor
// ===================================================================
   [Description (
     "Capabilities and management of the DesktopMonitor (CRT) "
     "LogicalDevice.") ] 
class CIM_DesktopMonitor : CIM_Display {
      [Description (
        "The type of DesktopMonitor or CRT. For example, "
        "multiscan color or monochrome monitors (values 2 or 3, "
        "respectively) can be indicated in this property."),
       Values {"Unknown", "Other", "Multiscan Color", 
               "Multiscan Monochrome", "Fixed Frequency Color",
               "Fixed Frequency Monochrome"} ]
   uint16 DisplayType;
      [Description (
        "Monitor's bandwidth in MHertz. If unknown, enter 0."),
       Units ("MegaHertz") ]
   uint32 Bandwidth;
      [Description (
        "The logical height of the Display in screen coordinates.") ]
   uint32 ScreenHeight;
      [Description ( 
        "The logical width of the Display in screen coordinates.") ]
   uint32 ScreenWidth;
};


// ===================================================================
// FlatPanel
// ===================================================================
   [Description (
     "Capabilities and management of the FlatPanel LogicalDevice.") ] 
class CIM_FlatPanel : CIM_Display  {
      [Description ("FlatPanel's horizontal resolution in Pixels."),
       Units ("Pixels") ]
   uint32 HorizontalResolution;
      [Description ("FlatPanel's vertical resolution in Pixels."),
       Units ("Pixels") ]
   uint32 VerticalResolution;
      [Description (
        "A FlatPanel's scan mode indicating either single "
        "(value=2) or dual scan (3)."),
       Values {"Unknown", "Other", "Single Scan", "Dual Scan"} ]
   uint16 ScanMode;
      [Description (
        "An integer enumeration describing the type of flat panel "
        "display."),
       Values {"Unknown", "Other", "Passive Matrix LCD", 
               "Active Matrix LCD", "Cholesteric LCD",
               "Field Emission Display", 
               "Electro Luminescent Display", "Gas Plasma", "LED"} ]
   uint16 DisplayType;
      [Description (
        "A description of the display illumination type. For example, "
        "backlit (value=2) or reflective (4) can be specified."),
       Values {"Unknown", "Other", "Backlit", "Edgelit", "Reflective"} ]
   uint16 LightSource;
      [Description (
       "Boolean indicating whether the FlatPanel supports color "
       "display.") ]
   boolean SupportsColor;
};


// ===================================================================
// Scanner
// ===================================================================
   [Description (
     "Capabilities and management of the Scanner LogicalDevice.") ] 
class CIM_Scanner : CIM_LogicalDevice {
};


// ===================================================================
// Battery
// ===================================================================
   [Description (
     "Capabilities and management of the Battery LogicalDevice. "
     "This class applies to both batteries in Laptop Systems and "
     "other internal/external batteries, such as used in, "
     "or as UPSs.") ] 
class CIM_Battery : CIM_LogicalDevice  {
      [Description (
        "Description of the Battery's charge status. Values such "
        "as \"Fully Charged\" (value=3) or \"Partially Charged\" "
        "(11) can be specified. The value, 10, is "
        "not valid in the CIM Schema since in DMI it represents "
        "that no battery is installed. In this case, this object "
        "should not be instantiated."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
                 "11"},
       Values {"Other", "Unknown", "Fully Charged",  
               "Low", "Critical", "Charging", "Charging and High", 
               "Charging and Low", "Charging and Critical", "Undefined", 
               "Partially Charged"},
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   uint16 BatteryStatus;
      [Description (
        "TimeOnBattery indicates the elapsed time in seconds "
        "since the ComputerSystem, UPS, ... last switched to "
        "battery power, or the time since the System or UPS "
        "was last restarted, whichever is less. Zero shall "
        "be returned if the Battery is 'on line'."), 
       Units ("Seconds") ]
   uint32 TimeOnBattery;
      [Description (
        "EstimatedRunTime is an estimate in minutes of the "
        "time to battery charge depletion under the present "
        "load conditions if the utility power is off, or lost "
        "and remains off, or a Laptop is disconnected from a "
        "power source."),
       Units ("Minutes"),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   uint32 EstimatedRunTime;
      [Gauge, Description (
        "An estimate of the percentage of full charge remaining."),
       Units ("Percent") ] 
   uint16 EstimatedChargeRemaining;
      [Description (
        "An enumeration that describes the Battery's chemistry."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8"},
       Values {"Other", "Unknown", "Lead Acid", "Nickel Cadmium", 
               "Nickel Metal Hydride", "Lithium-ion", "Zinc air", 
               "Lithium Polymer"},
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   uint16 Chemistry;
      [Description (
        "The design capacity of the battery in mWatt-hours. "
        "If this property is not supported, enter 0."),
       Units ("MilliWattHours"),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]  
   uint32 DesignCapacity;
      [Description (
        "The full charge capacity of the battery in mWatt-hours. "
        "Comparison of this value to the Battery DesignCapacity "
        "determines when the Battery requires replacement.  A "
        "Battery's end of life is typically when the FullCharge"
        "Capacity falls below 80% of the DesignCapacity. "
        "If this property is not supported, enter 0."),
       Units ("MilliWattHours"),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   uint32 FullChargeCapacity;
      [Description (
        "The design voltage of the battery in mVolts. If "
        "this attribute is not supported, enter 0."),
       Units ("MilliVolts"),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]   
   uint64 DesignVoltage;
      [MaxLen (64), Description (
        "The Smart Battery Data Specification version number "
        "supported by this Battery. If the Battery does not "
        "support this function, the value should be left blank."),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   string SmartBatteryVersion;
      [Description (
        "The remaining time to charge the battery fully in minutes "
        "at the current charging rate and usage."),
       Units ("Minutes"),
       MappingStrings {"MIF.DMTF|Portable Battery|003"} ]
   uint32 TimeToFullCharge;
    [Description (
        "Indicates the Battery's expected lifetime in minutes, " 
        "assuming that the Battery is fully charged. This property "
        "represents the total expected life of the Battery, not its "
        "current remaining life, which is indicated by the "
        "EstimatedRunTime property. "), 
       Units ("Minutes") ]
   uint32 ExpectedLife;
      [Description (
        "MaxRechargeTime indicates the maximum time, in minutes, " 
        "to fully charge the Battery. This property represents the "
        "time to recharge a fully depleted Battery, not the current "
        "remaining charging time, which is indicated in the "
        "TimeToFullCharge property. "), 
       Units ("Minutes") ]
   uint32 MaxRechargeTime;  
};


// ===================================================================
// PowerSupply
// ===================================================================
   [Description (
     "Capabilities and management of the PowerSupply LogicalDevice.") ] 
class CIM_PowerSupply : CIM_LogicalDevice   {
      [Description (
        "Boolean indicating that the PowerSupply is a switching "
        "(vs linear) supply.") ]
   boolean IsSwitchingSupply;
      [Description (
        "The low voltage of Input Voltage Range 1 for this Power"
        "Supply, in millivolts. A value of 0 denotes 'unknown'."),
       Units ("MilliVolts"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range1InputVoltageLow;
      [Description (
        "The high voltage of Input Voltage Range 1 for this Power"
        "Supply, in millivolts. A value of 0 denotes 'unknown'."),
       Units ("MilliVolts"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range1InputVoltageHigh;
      [Description (
        "The frequency (in Hertz) at the low end of this Power"
        "Supply's Input Frequency Range 1. A value of zero "
        "implies DC."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range1InputFrequencyLow;
      [Description (
        "The frequency (in Hertz) at the high end of this Power"
        "Supply's Input Frequency Range 1. A value of zero "
        "implies DC."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range1InputFrequencyHigh;
      [Description (
        "The low voltage of Input Voltage Range 2 for this Power"
        "Supply, in millivolts. A value of 0 denotes 'unknown'."),
       Units ("MilliVolts"), 
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range2InputVoltageLow;
      [Description (
        "The high voltage of Input Voltage Range 2 for this Power"
        "Supply, in millivolts. A value of 0 denotes 'unknown'."),
       Units ("MilliVolts"), 
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range2InputVoltageHigh;
      [Description (
        "The frequency (in Hertz) at the low end of this Power"
        "Supply's Input Frequency Range 2. A value of zero "
        "implies DC."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range2InputFrequencyLow;
      [Description (
        "The frequency (in Hertz) at the high end of this Power"
        "Supply's Input Frequency Range 2. A value of zero "
        "implies DC."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 Range2InputFrequencyHigh;
      [Description (
        "ActiveInputVoltage indicates which input voltage range is "
        "currently in use. Range 1, 2 or both can be specified "
        "using the values 3, 4 or 5, respectively. If the Supply "
        "is not currently drawing power, the value 6 (\"Neither\") "
        "can be specified. This information is necessary in the "
        "case of a UPS, a subclass of PowerSupply."),
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Range 1", "Range 2", "Both",
               "Neither"},
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint16 ActiveInputVoltage;
      [Description (
        "TypeOfRangeSwitching describes the kind of input voltage "
        "range switching implemented in this PowerSupply. For "
        "example, autoswitching can be specified (value=4)."),
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Manual", "Autoswitch",
               "Wide Range", "Not Applicable"},
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint16 TypeOfRangeSwitching;
      [Description (
        "Represents the total output power of the PowerSupply in "
        "milliWatts. 0 denotes 'unknown'."),
       Units ("MilliWatts"),
       MappingStrings {"MIF.DMTF|Power Supply|004"} ]
   uint32 TotalOutputPower;
};


// ===================================================================
// SuppliesPower 
// ===================================================================
   [Association, Description (
     "The SuppliesPower relationship indicates that a Device is in "
     "the power domain of the referenced PowerSupply or UPS. "
     "It indicates which Device(s) are dependent on the PowerSupply, "
     "and hence, which Devices are affected if the Supply is lost.") ]
class CIM_SuppliesPower : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The Supply providing power.") ]
   CIM_PowerSupply REF Antecedent;
      [Override ("Dependent"), 
       Description (
        "A LogicalDevice in the power domain of the Supply.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// UninterruptiblePowerSupply
// ===================================================================
   [Description (
     "Capabilities and management of an UninterruptiblePowerSupply. "
     "The properties of the UPS Device indicate when incoming power "
     "is trimmed or boosted, and the aggregated information of the "
     "batteries, generators, etc. that comprise the Device.  These "
     "individual components (for example, multiple batteries) can "
     "also be independently modeled and associated with the UPS.") ] 
class CIM_UninterruptiblePowerSupply : CIM_PowerSupply {
      [Override ("Range1InputVoltageLow"), Description (
        "If the voltage (in millivolts) drops below the value "
        "specified by Range1InputVoltageLow, the UPS will compensate "
        "by boosting the voltage using its power source(s).  A value "
        "of 0 indicates that the voltage at which boosting occurs "
        "is 'unknown'."), 
       Units ("MilliVolts") ]
   uint32 Range1InputVoltageLow;
      [Override ("Range1InputVoltageHigh"), Description (
        "If the voltage (in millivolts) rises above the value "
        "specified by Range1InputVoltageHigh, the UPS will compensate "
        "by trimming the voltage.  A value of 0 indicates that the "
        "voltage at which trimming occurs is 'unknown'."),
       Units ("MilliVolts") ]
   uint32 Range1InputVoltageHigh;
      [Override ("Range2InputVoltageLow"), Description (
        "If the voltage (in millivolts) drops below the value "
        "specified by Range2InputVoltageLow, the UPS will compensate "
        "by boosting the voltage using its power source(s).  A value "
        "of 0 indicates that the voltage at which boosting occurs "
        "is 'unknown'."), 
       Units ("MilliVolts") ]
   uint32 Range2InputVoltageLow;
      [Override ("Range2InputVoltageHigh"), Description (
        "If the voltage (in millivolts) rises above the value "
        "specified by Range2InputVoltageHigh, the UPS will compensate "
        "by trimming the voltage.  A value of 0 indicates that the "
        "voltage at which trimming occurs is 'unknown'."),
       Units ("MilliVolts") ]
   uint32 Range2InputVoltageHigh;
      [Description (
        "The indication of the capacity remaining in the UPS' "
        "batteries, generator, ...  A value of \"Normal\" (2) "
        "indicates that the remaining estimated minutes of run-time "
        "is greater than the UPS' defined 'low power' state "
        "(typically two minutes). A value of \"Low\" (3) indicates "
        "that the remaining estimated minutes of run-time is less "
        "than or equal to the UPS' defined 'low power' state.  A "
        "value of \"Depleted\" (4) indicates that the "
        "UPS will be unable to sustain the present load when and if "
        "the utility power is lost (including the possibility that "
        "the utility power is currently absent)."), 
       ValueMap {"1", "2", "3", "4"}, 
       Values {"Unknown", "Normal", "Low", "Depleted"},
       MappingStrings {"MIF.DMTF|UPS Battery|001.1"} ]
   uint16 RemainingCapacityStatus;
      [Description (
        "TimeOnBackup indicates the elapsed time in seconds "
        "since the UPS last switched to battery power, generator, ...  "
        "Or, the time since the UPS was last restarted, whichever is "
        "less. Zero shall be returned if the UPS is 'on line'."), 
       Units ("Seconds"),
       MappingStrings {"MIF.DMTF|UPS Battery|001.2"} ]
   uint32 TimeOnBackup;
      [Description (
        "EstimatedRunTime is an estimate in minutes of the time to "
        "battery, generator, ... depletion under the present load "
        "conditions if the utility power is off, or lost and remains "
        "off."),
       Units ("Minutes"),
       MappingStrings {"MIF.DMTF|UPS Battery|001.3"} ]
   uint32 EstimatedRunTime;
      [Gauge, Description (
        "An estimate of the percentage of full charge remaining for "
        "a UPS (that uses battery technology)."),
       Units ("Percent"),
       MappingStrings {"MIF.DMTF|UPS Battery|001.4"} ] 
   uint16 EstimatedChargeRemaining;
};


// ===================================================================
// AssociatedBattery
// ===================================================================
   [Association, Description (
     "A LogicalDevice may use or require one or more Batteries. This "
     "relationship is described by the AssociatedBattery dependency. "
     "It is also possible to model the individual Batteries that "
     "comprise a UPS, using this association.") ] 
class CIM_AssociatedBattery : CIM_Dependency   {
      [Override ("Antecedent"),
       Description ("The Battery.") ]
   CIM_Battery REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The LogicalDevice needing or associated with the Battery.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// Processor
// ===================================================================
   [Description (
     "Capabilities and management of the Processor LogicalDevice.") ] 
class CIM_Processor : CIM_LogicalDevice {
      [Description (
        "A free form string describing the role of the Processor - "
        "for example, \"Central Processor\" or \"Math Processor\".") ] 
   string Role;
      [Description (
        "The Processor family type. For example, values include "
        "\"Pentium(R) processor with MMX(TM) technology\" (14) "
        "and \"68040\" (96)."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
                 "11", "12", "13", "14", "15", "16", "17", "18", "19", 
                 "24", "25", "26", "27", "28", "29", "30", 
                 "31", "32", "33", "34", "35", "36", "37", "38", "39", 
                 "48", "49", "50", "51", "52", "53", "54", "55", 
                 "64", "65", "66", "67", "68", "69", 
                 "80", "81", "82", "83", "84", "85", "86", "87", "88", 
                 "96", "97", "98", "99", "100", 
                 "101", "112", "120", "121", "128", "130", 
                 "144", "145", "146", "147", "148", "149", "150",
                 "160", "176", "177", "180", "200", "201", "202", 
                 "250", "251", "260", "261", "280", "281", 
                 "300", "301", "302", "320", "350", "500"},
       Values {"Other", "Unknown", "8086", "80286", "80386", "80486",
               "8087", "80287", "80387", "80487", "Pentium(R) brand",
               "Pentium(R) Pro", "Pentium(R) II", 
               "Pentium(R) processor with MMX(TM) technology", 
               "Celeron(TM)", "Pentium(R) II Xeon(TM)", 
               "Pentium(R) III", "M1 Family", "M2 Family", "K5 Family", 
               "K6 Family", "K6-2", "K6-3", 
               "AMD Athlon(TM) Processor Family", 
               "AMD(R) Duron(TM) Processor", "AMD29000 Family", 
               "K6-2+", "Power PC Family", "Power PC 601", 
               "Power PC 603", "Power PC 603+", "Power PC 604", 
               "Power PC 620", "Power PC X704", "Power PC 750", 
               "Alpha Family", "Alpha 21064", "Alpha 21066", 
               "Alpha 21164", "Alpha 21164PC", "Alpha 21164a", 
               "Alpha 21264", "Alpha 21364", "MIPS Family", 
               "MIPS R4000", "MIPS R4200", "MIPS R4400", "MIPS R4600", 
               "MIPS R10000", "SPARC Family", "SuperSPARC", 
               "microSPARC II", "microSPARC IIep", "UltraSPARC", 
               "UltraSPARC II", "UltraSPARC IIi", "UltraSPARC III", 
               "UltraSPARC IIIi", "68040", "68xxx Family", "68000", 
               "68010", "68020", "68030", "Hobbit Family", 
               "Crusoe(TM) TM5000 Family", "Crusoe(TM) TM3000 Family",
               "Weitek", "Itanium(TM) Processor", "PA-RISC Family", 
               "PA-RISC 8500", "PA-RISC 8000", "PA-RISC 7300LC", 
               "PA-RISC 7200", "PA-RISC 7100LC", "PA-RISC 7100", 
               "V30 Family", "Pentium(R) III Xeon(TM)", 
               "Pentium(R) III Processor with Intel(R) SpeedStep(TM) Technology",
               "AS400 Family", "IBM390 Family", "G4", "G5", "i860", 
               "i960", "SH-3", "SH-4", "ARM", "StrongARM", "6x86", 
               "MediaGX", "MII", "WinChip", "DSP", "Video Processor"},
       MappingStrings {"MIF.DMTF|Processor|013"},
       ModelCorrespondence {"CIM_Processor.OtherFamilyDescription"} ]
   uint16 Family;
      [MaxLen (64), Description (
        "A string describing the Processor Family type - used when "
        "the Family property is set to 1 (\"Other\"). This string "
        "should be set to NULL when the Family property is any "
        "value other than 1."),
       ModelCorrespondence {"CIM_Processor.Family"} ]
   string OtherFamilyDescription;
      [Description (
        "CPU socket information including data on how this "
        "Processor can be upgraded (if upgrades are supported). "
        "This property is an integer enumeration."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", 
                 "10", "11", "12", "13", "14"}, 
       Values {"Other", "Unknown", "Daughter Board", "ZIF Socket",
               "Replacement/Piggy Back", "None", "LIF Socket", "Slot 1",
               "Slot 2", "370 Pin Socket", "Slot A", "Slot M", 
               "Socket 423", "Socket A (Socket 462)"}, 
       MappingStrings {"MIF.DMTF|Processor|013"} ]
   uint16 UpgradeMethod;
      [Description ("The maximum speed (in MHz) of this Processor."),
       Units ("MegaHertz"),
       MappingStrings {"MIF.DMTF|Processor|013"} ]
   uint32 MaxClockSpeed;
      [Description ("The current speed (in MHz) of this Processor."),
       Units ("MegaHertz"),
       MappingStrings {"MIF.DMTF|Processor|013"} ]
   uint32 CurrentClockSpeed;
      [Description ("Processor data width in bits."),
       Units ("Bits") ]
   uint16 DataWidth; 
      [Description ("Processor address width in bits."),
       Units ("Bits") ]
   uint16 AddressWidth;
      [Gauge, Description (
        "Loading of this Processor, averaged over the last minute, "
        "in Percent."),
       Units ("Percent"),
       MappingStrings {"MIB.IETF|HOST-RESOURCES-MIB.hrProcessorLoad"} ]
   uint16 LoadPercentage;
      [Description (
        "Stepping is a free-form string indicating the revision " 
        "level of the Processor within the Processor.Family."), 
       ModelCorrespondence {"CIM_Processor.Family"} ]
   string Stepping;
      [Description (
        "A globally unique identifier for the Processor. This "
        "identifier may only be unique within a Processor Family.") ]
   string UniqueID;
      [Description (
        "The CPUStatus property indicates the current status of "
        "the Processor. For example, it may be disabled by the user "
        "via BIOS (value=2), or disabled due to a POST error (value="
        "3). Information in this property can be obtained from SMBIOS, "
        "the Type 4 structure, the Status attribute."), 
       ValueMap {"0", "1", "2", "3", "4", "7"}, 
       Values {"Unknown", "CPU Enabled", 
               "CPU Disabled by User via BIOS Setup", 
               "CPU Disabled By BIOS (POST Error)", "CPU Is Idle", "Other"} ]
   uint16 CPUStatus;
};


// ====================================================================
// AlarmDevice 
// ===================================================================
   [Description (
     "An AlarmDevice is a type of Device that emits audible or " 
     "visible indications related to a problem situation. ") ]
class CIM_AlarmDevice : CIM_LogicalDevice {
      [Description ("Boolean indicating that the Alarm is audible. ") ]
   boolean AudibleAlarm;
      [Description ("Boolean indicating that the Alarm is visible. ") ]
   boolean VisibleAlarm;
      [Description (
        "Boolean indicating that the Alarm causes motion of the "
        "Device.") ]
   boolean MotionAlarm;
      [Description (
        "Urgency is an enumerated value that indicates the relative " 
        "frequency at which the Alarm flashes, vibrates and/or emits "
        "audible tones. "), 
       Values {"Unknown", "Other", "Not Supported", "Informational", 
               "Non-Critical", "Critical", "Unrecoverable"} ]
   uint16 Urgency;
      [Description ("The current state of the alarm."),
       Values {"Unknown", "Off", "Steady", "Alternating"} ]
   uint16 AlarmState;
      [Description (
        "True indicates that the audio of an AlarmState indicator "
        "has been disabled (i.e. muted). A disabled state here "
        "does not imply that the AlarmState is off.") ]
   boolean AudioIndicatorIsDisabled;
      [Description (
        "True indicates that the visual of an AlarmState indicator "
        "has been disabled (i.e. dimmed). A disabled state here "
        "does not imply that the AlarmState is off.") ]
   boolean VisualIndicatorIsDisabled;
      [Description (
        "True indicates that the motion of an AlarmState indicator "
        "has been disabled (i.e. stopped). A disabled state here "
        "does not imply that the AlarmState is off.") ]
   boolean MotionIndicatorIsDisabled;
      [Description (
        "SetAlarmState is a method for defining the current state "
        "of the Alarm. Its input parameter, RequestedAlarmState, is "
        "specified using the Values list of AlarmDevice's AlarmState "
        "property. SetAlarmState returns 0 if the request is "
        "successfully implemented, 1 if the specified RequestedAlarm"
        "State is not supported, and some other value if any other "
        "error occurred. In a subclass, the set of possible return "
        "codes should be specified using a ValueMap qualifier on the "
        "method. The strings to which the ValueMap contents are "
        "'translated' should be specified as a Values array "
        "qualifier.") ]
   uint32 SetAlarmState (
      [IN, Values {"Unknown", "Off", "Steady", "Alternating"}] 
       uint16 RequestedAlarmState);
      [Description (
        "SetAlarmIndicator is a method for enabling or disabling the "
        "indicator of the AlarmState function, without changing the "
        "current AlarmState. It has 3 input parameters, Audio"
        "Indicator, VisualIndicator and MotionIndicator. For all of "
        "the input parameters, a value of 0 indicates no change to "
        "the AlarmState indicator, 1 indicates Disable, and 2 "
        "indicates Enable. The method returns 0 if the request is "
        "successfully implemented, 1 if the specified request is not "
        "supported, and some other value if any other error occurred. "
        "In a subclass, the set of possible return codes should be "
        "specified using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "should be specified as a Values array qualifier.") ]
   uint32 SetAlarmIndicator (
      [IN, Values {"No Change", "Disable", "Enable"}] 
       uint16 AudioIndicator, 
      [IN, Values {"No Change", "Disable", "Enable"}] 
       uint16 VisualIndicator, 
      [IN, Values {"No Change", "Disable", "Enable"}] 
       uint16 MotionIndicator);
      [Description (
        "SetUrgency is a method for defining the desired urgency " 
        "level for the Alarm. Its input parameter, RequestedUrgency, "
        "is specified using the Values list of AlarmDevice's Urgency "
        "property. SetUrgency returns 0 if the request is successfully "
        "implemented, 1 if the specified Urgency level is not "
        "supported, and some other value if any other error occurred. "
        "In a subclass, the set of possible return codes should be "
        "specified using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "should be specified as a Values array qualifier.") ]
   uint32 SetUrgency (
      [IN, ValueMap {"1", "3", "4", "5", "6"}, 
           Values {"Other", "Informational", "Non-Critical", "Critical", 
                   "Unrecoverable"} ] 
       uint16 RequestedUrgency);
};


// ===================================================================
// AssociatedAlarm 
// ===================================================================
   [Association, Description (
     "LogicalDevices may have one or more AlarmDevices " 
     "associated with them, in order to indicate problem situations. "
     "This relationship is indicated by the AssociatedAlarm "
     "dependency. ") ]
class CIM_AssociatedAlarm : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The AlarmDevice. ") ] 
   CIM_AlarmDevice REF Antecedent;
      [Override ("Dependent"), 
       Description ("The LogicalDevice that is alarmed. ") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// Door
// ===================================================================
   [Description (
     "A Door is the abstraction of hardware providing access to "
     "the internal componentry of a System. When a Door is 'opened', "
     "typically all accessible, moving components are stopped or "
     "suspended to prevent physical harm.") ]
class CIM_Door : CIM_LogicalDevice {
      [Description (
        "Boolean indicating the 'open' (TRUE) or 'closed' (FALSE) "
        "status of the Door.") ]
   boolean Open;
      [Description (
        "Boolean indicating that the Door is 'locked' (TRUE) or "
        "'unlocked' (FALSE). When the Door is locked, access to the "
        "componentry is prevented, without the use of a physical "
        "key or the issuance of a software unlock command.") ]
   boolean Locked;
      [Description (
        "When a Door is 'Open', all accessible, moving componentry "
        "and Device operation are typically stopped. The Timeout "
        "property provides a mechanism to event on a Door left open "
        "for a period of time (in seconds) exceeding the property's "
        "value."), 
       Units ("Seconds") ]
   uint32 Timeout;
      [Description (
        "Date and time that the Door was last opened.") ]
   datetime LastOpened;
      [Description (
        "The Capabilities of the Door. For example, information on "
        "whether the Door is \"Host System Lockable\" (value=2) and/or "
        "whether a key is available (value=3) are specified in this "
        "property. The value 4, \"All Drives Dismounted Before "
        "Access\", pertains to a Door on a StorageLibrary or set of "
        "drive bays. If specified for the Door, it means that it can "
        "not be opened unless all Media are first unloaded from the "
        "accessible MediaAccessDevices."), 
       Values {"Unknown", "Other", "Host System Lockable", 
               "Physical Key", "All Drives Dismounted Before Access"} ]
   uint16 Capabilities[];
};


// ===================================================================
// DoorAccessToPhysicalElement 
// ===================================================================
   [Association, Description (
     "Doors provide access to PhysicalElements for hot swap, repair "
     "and similar activities. The entities accessed through a Door "
     "are indicated in this relationship.") ]
class CIM_DoorAccessToPhysicalElement : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The Door that provides access.") ]
   CIM_Door REF Antecedent;
      [Override ("Dependent"), 
       Description ("The PhysicalElement that is accessed.") ]
   CIM_PhysicalElement REF Dependent;
};


// ===================================================================
// DoorAccessToDevice 
// ===================================================================
   [Association, Description (
     "Doors provide access to PhysicalElements for hot swap, repair "
     "and similar activities. In turn, PhysicalElements 'Realize' "
     "LogicalDevices. Since it may not be possible to define all the "
     "PhysicalElements that exist, and optimizing the retrieval of "
     "Devices 'behind' the Door may be desirable, the DoorAccessTo"
     "Device association provides a shortcut mechanism for defining "
     "the LogicalDevices ('hardware') accessed through a Door.") ]
class CIM_DoorAccessToDevice : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The Door that provides access.") ]
   CIM_Door REF Antecedent;
      [Override ("Dependent"), 
       Description ("The LogicalDevice that is accessed.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
//
//    Resources, Statistics, and Sensors
//
// ===================================================================


// ===================================================================
// SystemResource
// ===================================================================
   [Abstract,
    Description (
     "An entity managed by BIOS and/or an OperatingSystem which is "
     "available for use by software and/or LogicalDevices. Examples "
     "of Resources in the x86 environment are IRQs, DMA channels and "
     "memory mapped I/O.") ] 
class CIM_SystemResource : CIM_LogicalElement {
      [Description (
        "Boolean indicating whether the Resource can be shared.") ]
   boolean Shareable;
};


// ===================================================================
// IRQ
// ===================================================================
   [Description ("Personal computer architecture IRQ.") ] 
class CIM_IRQ : CIM_SystemResource {
      [Propagated("CIM_ComputerSystem.CreationClassName"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's CreationClassName.") ]
   string CSCreationClassName;
      [Propagated("CIM_ComputerSystem.Name"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's Name.") ]
   string CSName;
      [Key, MaxLen (256),
       Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Key, 
       Description ("A part of the object's key value, IRQ Number."), 
       MappingStrings {"MIF.DMTF|IRQ|002.1"} ]
   uint32 IRQNumber;
      [Description ("Availability of the IRQ."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "Available", 
               "In Use/Not Available", 
               "In Use and Available/Shareable"},
       MappingStrings {"MIF.DMTF|IRQ|002.2"} ]
   uint16 Availability;
      [Description (
        "IRQ trigger type indicating whether edge (value=4) "
        "or level triggered (value=3) interrupts occur. Also, "
        "\"Other\" (1) and \"Unknown\" (2) may be defined."),
       ValueMap {"1", "2", "3", "4"},
       Values {"Other", "Unknown", "Level", "Edge"},
       MappingStrings {"MIF.DMTF|IRQ|002.3", 
        "MIF.DMTF|System Resource IRQ Info|001.2"} ]
   uint16 TriggerType;
      [Description (
        "IRQ trigger level indicating whether the interrupt is "
        "triggered by the hardware signal going high (value=4) "
        "or low (value=3).  Also, \"Other\" (1) and "
        "\"Unknown\" (2) may be defined."),
       ValueMap {"1", "2", "3", "4"},
       Values {"Other", "Unknown", "Active Low", "Active High"},
       MappingStrings {"MIF.DMTF|System Resource IRQ Info|001.3"} ]
   uint16 TriggerLevel; 
// Override is used to define the MappingString qualifier 
      [Override ("Shareable"), 
       Description (
        "Boolean indicating whether the IRQ can be shared."),
       MappingStrings {"MIF.DMTF|IRQ|002.4"} ]
   boolean Shareable;
      [Description (
        "The Hardware property indicates whether the interrupt "
        "is hardware or software based. (If TRUE, the interrupt is "
        "hardware based.) On a personal computer, a hardware IRQ "
        "is a physical wire to a programmable interrupt "
        "controller (PIC) chip, through which the CPU can be "
        "notified of time critical events. Some IRQ lines are "
        "reserved for standard Devices such as the keyboard, floppy "
        "disk drives, and the system clock. A software interrupt "
        "is a programmatic mechanism to allow an application to "
        "get the attention of the Processor.") ]
   boolean Hardware;
};

// ===================================================================
// MemoryMappedIO
// ===================================================================
   [Description (
     "Personal Computer architecture Memory Mapped I/O. This class "
     "addresses both memory and port I/O resources. The property, "
     "MappedResource, defines whether memory or I/O is mapped (and "
     "for I/O whether the mapping is to a memory or a port space).") ]
class CIM_MemoryMappedIO : CIM_SystemResource {
      [Propagated("CIM_ComputerSystem.CreationClassName"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's CreationClassName.") ]
   string CSCreationClassName;
      [Propagated("CIM_ComputerSystem.Name"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's Name.") ]
   string CSName;
      [Key, MaxLen (256),
       Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Key, Description (
        "A part of the object's key value, the starting address of "
        "memory mapped I/O."),
       MappingStrings {"MIF.DMTF|Memory Mapped I/O|001.1"} ]
   uint64 StartingAddress;
      [Description ("Ending address of memory mapped I/O."),
       MappingStrings {"MIF.DMTF|Memory Mapped I/O|001.2"} ]
   uint64 EndingAddress;
      [Description (
        "Type of memory mapped I/O. MappedResource defines whether "
        "memory or I/O is mapped, and for I/O, whether the mapping "
        "is to a memory or a port space."), 
       Values {"Other", "Mapped Memory", "I/O Mapped to Memory Space", 
               "I/O Mapped to Port Space"} ]
   uint16 MappedResource;
};


// ===================================================================
// MemoryResource
// ===================================================================
   [Description (
     "Since the MemoryMappedIO class applies to memory AND port "
     "resources, there is the potential for key conflict. For example, "
     "both a memory resource and a port resource may be located at "
     "address 0. Since StartingAddress is the distinguishing key of "
     "MemoryMappedIO, two instances would be created with the same key. "
     "This is prevented by defining memory and port resource subclasses "
     "of MemoryMappedIO, and allowing the CreationClassName key property "
     "to distinguish between them and force uniqueness in their keys.") ]
class CIM_MemoryResource : CIM_MemoryMappedIO {
};


// ===================================================================
// PortResource
// ===================================================================
   [Description (
     "Since the MemoryMappedIO class applies to memory AND port "
     "resources, there is the potential for key conflict. For example, "
     "both a memory resource and a port resource may be located at "
     "address 0. Since StartingAddress is the distinguishing key of "
     "MemoryMappedIO, two instances would be created with the same key. "
     "This is prevented by defining memory and port resource subclasses "
     "of MemoryMappedIO, and allowing the CreationClassName key property "
     "to distinguish between them and force uniqueness in their keys.") ]
class CIM_PortResource : CIM_MemoryMappedIO {
};


// ===================================================================
// DMA
// ===================================================================
   [Description ("Personal computer architecture DMA.") ] 
class CIM_DMA : CIM_SystemResource {
      [Propagated("CIM_ComputerSystem.CreationClassName"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's CreationClassName.") ]
   string CSCreationClassName;
      [Propagated("CIM_ComputerSystem.Name"),
       Key, MaxLen (256),
       Description ("The scoping ComputerSystem's Name.") ]
   string CSName;
      [Key, MaxLen (256),
       Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Key, Description (
        "A part of the object's key value, the DMA Channel number."),
       MappingStrings {"MIF.DMTF|DMA|001.1"} ]
   uint32 DMAChannel;
      [Description ("Availability of the DMA."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "Available", 
               "In Use/Not Available", 
               "In Use and Available/Shareable"},
       MappingStrings {"MIF.DMTF|DMA|001.2"} ]
   uint16 Availability;
      [Description (
        "Indication that the DMA Channel supports burst mode."),
       MappingStrings {"MIF.DMTF|DMA|001.3"} ]
   boolean BurstMode; 
      [Description (
        "An array indicating all the transfer widths (in bits) "
        "supported by this DMA Channel. Permissible values "
        "are 8, 16, 32, 64 or 128 bits.  If unknown, enter 0."),
       Units ("Bits"),
       ValueMap {"0", "8", "16", "32", "64", "128"},
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.2"} ]
   uint16 TransferWidths[];
      [Description (
        "An integer indicating the DMA Channel address size in "
        "bits. Permissible values are 8, 16, 32 or 64 bits. "
        "If unknown, enter 0."),
       Units ("Bits"),
       ValueMap {"0", "8", "16", "32", "64"}, 
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.3"} ]
   uint16 AddressSize; 
      [Description (
        "The maximum number of bytes that can be transferred by this "
        "DMA Channel. If unknown, enter 0."),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.4"} ]
   uint32 MaxTransferSize;
      [Description (
        "Indicates whether DMA may execute in 'count by byte' mode "
        "(value=4) or not (value=3).  Also, \"Other\" (1) and "
        "\"Unknown\" (2) may be defined."),
       ValueMap {"1", "2", "3", "4"},
       Values {"Other", "Unknown", 
               "Not execute in 'count by byte' mode", 
               "Execute in 'count by byte' mode"},
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.7"} ]
   uint16 ByteMode;
      [Description (
        "Indicates whether DMA may execute in 'count by word' mode "
        "(value=4) or not (value=3).  Also, \"Other\" (1) and "
        "\"Unknown\" (2) may be defined."),
       ValueMap {"1", "2", "3", "4"},
       Values {"Other", "Unknown", 
               "Not execute in 'count by word' mode",
               "Execute in 'count by word' mode"},
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.8"} ]
   uint16 WordMode;
      [Description (
        "DMA channel timing.  For example, \"Type A\" (value "
        "=4) or \"Type F\" (6) could be specified."),
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "ISA Compatible", "Type A",
               "Type B", "Type F"},
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.9"} ]
   uint16 ChannelTiming;
      [Description (
        "Indicates whether C type (burst) timing is supported "
        "(value=5) or not (value=4). Also, \"Other\" (1), "
        "\"Unknown\" (2) and \"ISA Compatible\" (3) are defined."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "ISA Compatible", "Not Supported",
               "Supported"},
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.10"} ]
   uint16 TypeCTiming;
};


// ===================================================================
// ComputerSystemResource
// ===================================================================
   [Association, Aggregation,
    Description (
     "An association between a ComputerSystem and the System"
     "Resources available on it.") ]
class CIM_ComputerSystemResource : CIM_SystemComponent {
      [Override ("GroupComponent"), Aggregate,
       Min (1), Max (1), Description ("The ComputerSystem.")]
   CIM_ComputerSystem REF GroupComponent;
      [Override ("PartComponent"),
       Description ("A SystemResource of the ComputerSystem.") ]
   CIM_SystemResource REF PartComponent;
};


// ===================================================================
// ComputerSystemIRQ
// ===================================================================
   [Association, Aggregation,
    Description (
     "An association between a ComputerSystem and the IRQs "
     "available on it.") ]
class CIM_ComputerSystemIRQ : CIM_ComputerSystemResource {
      [Override ("PartComponent"), Weak,
       Description ("An IRQ of the ComputerSystem.")]
   CIM_IRQ REF PartComponent;
};

// ===================================================================
// ComputerSystemMappedIO
// ===================================================================
   [Association, Aggregation,
    Description (
     "An association between a ComputerSystem and the Memory Mapped "
     "I/O ports available on it.") ]
class CIM_ComputerSystemMappedIO : CIM_ComputerSystemResource {
      [Override ("PartComponent"), Weak,
       Description (
        "A memory mapped I/O port of the ComputerSystem.")]
   CIM_MemoryMappedIO REF PartComponent;
};


// ===================================================================
// ComputerSystemDMA
// ===================================================================
   [Association, Aggregation,
    Description (
     "An association between a ComputerSystem and the DMA channels "
     "available on it.") ]
class CIM_ComputerSystemDMA : CIM_ComputerSystemResource {
      [Override ("PartComponent"), Weak,
       Description ("A DMA channel of the ComputerSystem.")]
   CIM_DMA REF PartComponent;
};


// ===================================================================
// AllocatedResource
// ===================================================================
   [Association, Description (
     "An association between LogicalDevices and SystemResources, "
     "indicating that the Resource is assigned to the Device.") ]
class CIM_AllocatedResource : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The Resource.") ]
   CIM_SystemResource REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The LogicalDevice to which the Resource is assigned.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// AllocatedDMA
// =================================================================== 
   [Association, Description ( 
     "An association between a LogicalDevice and a DMA System" 
     "Resource indicating that the DMA Channel is assigned to the "
     "Device.") ]
class CIM_AllocatedDMA : CIM_AllocatedResource { 
      [Override ("Antecedent"), 
       Description ("The DMA Channel.")  ] 
   CIM_DMA REF Antecedent; 
      [Description ( 
        "Boolean indicating whether the LogicalDevice can act as a " 
        "bus master on the DMA Channel."),
       MappingStrings {"MIF.DMTF|System Resource DMA Info|001.6"}  ] 
   boolean BusMaster;
};


// ==================================================================
// DeviceErrorCounts
// ==================================================================
   [Description (
     "DeviceErrorCounts is a statistical class containing error-" 
     "related counters for a LogicalDevice. The types of errors " 
     "are as defined by CCITT (Rec X.733) and ISO (IEC 10164-4).") ]
class CIM_DeviceErrorCounts : CIM_StatisticalInformation {
      [Propagated ("CIM_LogicalDevice.SystemCreationClassName"), 
       Key, MaxLen (256),
       Description ("The scoping System's CreationClassName. ") ]
   string SystemCreationClassName; 
      [Propagated ("CIM_LogicalDevice.SystemName"), 
       Key, MaxLen (256),
       Description ("The scoping System's Name. ") ]
   string SystemName; 
      [Propagated ("CIM_LogicalDevice.CreationClassName"), 
       Key, MaxLen (256),
       Description ("The scoping Device's CreationClassName. ") ]
   string DeviceCreationClassName; 
      [Propagated ("CIM_LogicalDevice.DeviceID"), 
       Key, MaxLen (64),
       Description ("The scoping Device's ID. ") ]
   string DeviceID; 
      [Override ("Name"), 
       Key, MaxLen (256), 
       Description (
        "The inherited Name serves as part of the key for the " 
        "DeviceErrorCounts instance. The object is scoped by " 
        "the LogicalDevice to which the statistics apply. ") ] 
   string Name; 
      [Description ("Count of the indeterminate errors. "),
       Counter ] 
   uint64 IndeterminateErrorCount; 
      [Description ("Count of the critical errors. "), 
       MappingStrings {"MIF.DMTF|Operational State|006"}, 
       Counter ] 
   uint64 CriticalErrorCount; 
      [Description ("Count of the major errors. "), 
       MappingStrings {"MIF.DMTF|Operational State|006"}, 
       Counter ] 
   uint64 MajorErrorCount; 
      [Description ("Count of the minor errors. "), 
       Counter ] 
   uint64 MinorErrorCount; 
      [Description ("Count of the warnings. "), 
       MappingStrings {"MIF.DMTF|Operational State|006"}, 
       Counter ] 
   uint64 WarningCount; 
      [Description (
        "Method to reset the error and warning counters. The method " 
        "takes one parameter as input - an integer indicating which "
        "counter to reset. For this input parameter, 0 indicates all, "
        "1 indicates a reset of the indeterminate error counter, "
        "2 the critical error counter, 3 the major error counter, "
        "4 the minor error counter and 5 the warning counter. The "
        "method returns 0 if successful, 1 if not supported, and any " 
        "other value if an error occurred. A method is specified so "
        "that the LogicalDevice's instrumentation, which tabulates "
        "the errors and warnings, can also reset its internal "
        "processing and counters.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") ]
   uint32 ResetCounter (
      [IN, Values {"All","Indeterminate Error Counter", 
                   "Critical Error Counter", "Major Error Counter", 
                   "Minor Error Counter", "Warning Counter"}] 
      uint16 SelectedCounter);
};


// ==================================================================
// ErrorCountersForDevice
// ================================================================== 
   [Association, Description (
     "ErrorCountersForDevice relates the DeviceErrorCounts class "
     "to the LogicalDevice to which it applies. ") ]
class CIM_ErrorCountersForDevice : CIM_Statistics { 
      [Override ("Stats"), Weak,
       Description (
        "The statistical object - in this case, the error counter "
        "class. ")]
   CIM_DeviceErrorCounts REF Stats; 
    [Override ("Element"), Min(1), Max(1),
     Description ("The Device to which the error counters apply. ") ]
   CIM_LogicalDevice REF Element;
};

// ===================================================================
// Sensor
// ===================================================================
   [Abstract, Description (
     "A Sensor is a hardware device capable of measuring the "
     "characteristics of some physical property - for example, the "
     "temperature or voltage characteristics of a UnitaryComputer"
     "System.") ] 
class CIM_Sensor : CIM_LogicalDevice {
      [Description (
        "The Type of the Sensor, e.g. Voltage or Temperature Sensor. "
        "If the type is set to \"Other\", then the OtherSensorType"
        "Description can be used to further identify the type, or if "
        "the Sensor has numeric readings, then the type of the Sensor "
        "can be implicitly determined by the Units. A description of "
        "the different Sensor types is as follows: A Temperature Sensor "
        "measures the environmental temperature. Voltage and Current "
        "Sensors measure electrical voltage and current readings. "
        "A Tachometer measures speed/revolutions of a Device. For example, "
        "a Fan Device can have an associated Tachometer which measures "
        "its speed. A Counter is a general purpose Sensor that measures "
        "some numerical property of a Device. A Counter value can be "
        "cleared, but it never decreases. A Switch Sensor has states like "
        "Open/Close, On/Off, or Up/Down. A Lock has states of Locked/"
        "Unlocked. Humidity, Smoke Detection and Air Flow Sensors measure "
        "the equivalent environmental characteristics. A Presence Sensor "
        "detects the presence of a PhysicalElement."), 
       Values {"Unknown", "Other", "Temperature", "Voltage", "Current", 
               "Tachometer", "Counter", "Switch", "Lock", "Humidity", 
               "Smoke Detection", "Presence", "Air Flow"},
       ModelCorrespondence {"CIM_Sensor.OtherSensorTypeDescription"} ]
   uint16 SensorType;
      [MaxLen (128), Description (
        "A string describing the Sensor type - used when the SensorType "
        "property is set to \"Other\"."), 
       ModelCorrespondence {"CIM_Sensor.SensorType"} ]
   string OtherSensorTypeDescription;
      [MaxLen (128), Description (
        "PossibleStates enumerates the string outputs of the Sensor. For "
        "example, a \"Switch\" Sensor may output the states \"On\", or \"Off\". "
        "Another implementation of the Switch may output the states \"Open\", "
        "and \"Close\". Another example is a NumericSensor supporting "
        "thresholds. This Sensor can report the states like \"Normal\", "
        "\"Upper Fatal\", \"Lower Non-Critical\", etc. A NumericSensor that "
        "does not publish readings and thresholds, but stores this data "
        "internally, can still report its states.") ]
   string PossibleStates[];
      [MaxLen (128), Description (
        "The current state indicated by the Sensor. This is always one of "
        "the \"PossibleStates\".") ]
   string CurrentState;
      [Description (
        "The polling interval that the Sensor hardware or the instrumentation "
        "uses to determine the current state of the Sensor."), 
       Units ("NanoSeconds") ]
   uint64 PollingInterval;
};


// ===================================================================
// AssociatedSensor
// ===================================================================
   [Association, Description (
     "Many Devices include Sensors or have Sensors installed "
     "nearby, in order to measure critical input and output "
     "properties.  This association indicates that relationship.") ] 
class CIM_AssociatedSensor : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The Sensor.") ]
   CIM_Sensor REF Antecedent;
      [Override ("Dependent"), Description (
        "The LogicalDevice for which information is measured by "
        "the Sensor.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// BinarySensor
// ===================================================================
   [Description (
     "A BinarySensor provides a boolean output. Given the addition "
     "of the CurrentState and PossibleStates properties to Sensor, "
     "the BinarySensor subclass is no longer necessary, but is "
     "retained for backward compatibility. A BinarySensor can be "
     "created by instantiating a Sensor with two PossibleStates.") ]
class CIM_BinarySensor : CIM_Sensor {
      [Description ("The current value indicated by the Sensor.") ]
   boolean CurrentReading;
      [Description (
        "ExpectedReading indicates the 'normal' value for the Sensor.") ]
   boolean ExpectedReading;
      [MaxLen (64), Description (
        "InterpretationOfTrue is a string indicating what a 'True' "
        "value from the BinarySensor means.  This information could "
        "be displayed to a user.") ]
   string InterpretationOfTrue;
      [MaxLen (64), Description (
        "InterpretationOfFalse is a string indicating what a 'False' "
        "value from the BinarySensor means.  This information could "
        "be displayed to a user.") ]
   string InterpretationOfFalse;
};


// ===================================================================
// MultiStateSensor
// ===================================================================
   [Description (
     "A Multi-StateSensor is a multi-member set of Sensors.") ] 
class CIM_MultiStateSensor : CIM_Sensor {
};


// ===================================================================
// CollectionOfSensors
// ===================================================================
   [Association, Aggregation, Description (
     "The CollectionOfSensors association indicates the "
     "Sensors that make up a MultiStateSensor.") ] 
class CIM_CollectionOfSensors : CIM_Component {
      [Override ("GroupComponent"), Aggregate, Max (1),
       Description ("The MultiStateSensor.")]
   CIM_MultiStateSensor REF GroupComponent;
      [Override ("PartComponent"), Min (2),
       Description (
        "A Sensor that is part of the MultiStateSensor.")]
   CIM_Sensor REF PartComponent;
};


// ===================================================================
// DiscreteSensor
// ===================================================================
   [Description (
     "A DiscreteSensor has a set of legal string values, "
     "that it can report.  These values are enumerated in the "
     "Sensor's PossibleValues property.  A DiscreteSensor will "
     "always have a 'current reading' that corresponds to one of "
     "the enumerated values.\n"
     "Given the addition of the CurrentState and PossibleStates "
     "properties to Sensor, the DiscreteSensor subclass is no longer "
     "necessary, but is retained for backward compatibility. "
     "Information in the CurrentReading and PossibleValues properties "
     "will typically have the same values and semantics as for the "
     "CurrentState and PossibleStates properties, inherited from "
     "Sensor.") ]
class CIM_DiscreteSensor : CIM_Sensor {
      [MaxLen (64), Description (
        "The current value indicated by the Sensor.") ]
   string CurrentReading;
      [MaxLen (64), Description (
        "PossibleValues enumerates the string outputs that can be "
        "reported by the DiscreteSensor.") ]
   string PossibleValues[];
      [MaxLen (64), Description (
        "AcceptableValues details which of the PossibleValues strings "
        "are considered 'acceptable' (ie, 'not an error').") ]
   string AcceptableValues[];
};


// ===================================================================
// NumericSensor
// ===================================================================
   [Description (
     "A Numeric Sensor is capable of returning numeric readings "
     "and optionally supports thresholds settings.") ] 
class CIM_NumericSensor : CIM_Sensor {
      [Description (
        "The base unit of the values returned by this Sensor. All "
        "the values returned by this Sensor are represented in the units "
        "obtained by (BaseUnits * 10 raised to the power of the Unit"
        "Modifier). For example, if BaseUnits is Volts and the Unit"
        "Modifier is -6, then the units of the values returned are "
        "MicroVolts. However, if the RateUnits property is set to a "
        "value other than \"None\", then the units are further qualified "
        "as rate units. In the above example, if RateUnits is set to "
        "\"Per Second\", then the values returned by the Sensor "
        "are in MicroVolts/Second. The units apply to all numeric "
        "properties of the Sensor, unless explicitly overridden by the "
        "Units qualifier."), 
       Values {"Unknown", "Other", "Degrees C", "Degrees F", "Degrees K", 
               "Volts", "Amps", "Watts", "Joules", "Coulombs", "VA", "Nits", 
               "Lumens", "Lux", "Candelas", "kPa", "PSI", "Newtons", "CFM", 
               "RPM", "Hertz", "Seconds", "Minutes", "Hours", "Days", "Weeks", 
               "Mils", "Inches", "Feet", "Cubic Inches", "Cubic Feet", 
               "Meters", "Cubic Centimeters", "Cubic Meters", "Liters", 
               "Fluid Ounces", "Radians", "Steradians", "Revolutions", 
               "Cycles", "Gravities", "Ounces", "Pounds", "Foot-Pounds", 
               "Ounce-Inches", "Gauss", "Gilberts", "Henries", "Farads", 
               "Ohms", "Siemens", "Moles", "Becquerels", 
               "PPM (parts/million)", "Decibels", "DbA", "DbC", 
               "Grays", "Sieverts", "Color Temperature Degrees K", "Bits", 
               "Bytes", "Words (data)", "DoubleWords", "QuadWords", 
               "Percentage"},
       ModelCorrespondence {"CIM_NumericSensor.UnitModifier", 
        "CIM_NumericSensor.RateUnits"} ]
   uint16 BaseUnits;
      [Description (
        "The unit multiplier for the values returned by this Sensor. All "
        "the values returned by this Sensor are represented in the units "
        "obtained by (BaseUnits * 10 raised to the power of the Unit"
        "Modifier). For example, if BaseUnits is Volts and the Unit"
        "Modifier is -6, then the units of the values returned are Micro"
        "Volts. However, if the RateUnits property is set to a value other "
        "than \"None\", then the units are further qualified as rate units. "
        "In the above example, if RateUnits is set to \"Per Second\", then "
        "the values returned by the Sensor are in MicroVolts/Second. The "
        "units apply to all numeric properties of the Sensor, unless "
        "explicitly overridden by the Units qualifier."),
       ModelCorrespondence {"CIM_NumericSensor.BaseUnits", 
        "CIM_NumericSensor.RateUnits"} ]
   sint32 UnitModifier;
      [Description (
        "Specifies if the units returned by this Sensor are rate units. "
        "All the values returned by this Sensor are represented in the "
        "units obtained by (BaseUnits * 10 raised to the power of the Unit"
        "Modifier). This is true unless this property (RateUnits) has a "
        "value different than \"None\". For example, if BaseUnits is "
        "Volts and the UnitModifier is -6, then the units of the values "
        "returned are MicroVolts. But, if the RateUnits property is set "
        "to a value other than \"None\", then the units are further "
        "qualified as rate units. In the above example, if RateUnits is "
        "set to \"Per Second\", then the values returned by the Sensor are "
        "in MicroVolts/Second. The units apply to all numeric properties "
        "of the Sensor, unless explicitly overridden by the Units "
        "qualifier. Any implementation of CurrentReading should be qualified "
        "with either a Counter or a Gauge qualifier, depending on the "
        "characteristics of the sensor being modeled."), 
       Values {"None", "Per MicroSecond", "Per MilliSecond", "Per Second", 
               "Per Minute", "Per Hour", "Per Day", "Per Week", "Per Month", 
               "Per Year"},
       ModelCorrespondence {"CIM_NumericSensor.UnitModifier", 
        "CIM_NumericSensor.BaseUnits"} ]
   uint16 RateUnits;
      [Description ("The current value indicated by the Sensor.") ]
   sint32 CurrentReading;
      [Description (
        "NominalReading indicates the 'normal' or expected value "
        "for the NumericSensor.") ]
   sint32 NominalReading;
      [Description (
        "NormalMax provides guidance for the user as to the "
        "normal maximum range for the NumericSensor.") ]
   sint32 NormalMax;
      [Description (
        "NormalMin provides guidance for the user as to the "
        "normal minimum range for the NumericSensor.") ]
   sint32 NormalMin;
      [Description (
        "MaxReadable indicates the largest value of the measured "
        "property that can be read by the NumericSensor.") ]     
   sint32 MaxReadable;
      [Description (
        "MinReadable indicates the smallest value of the measured "
        "property that can be read by the NumericSensor.") ]     
   sint32 MinReadable;
      [Description (
        "Resolution indicates the ability of the Sensor to resolve "
        "differences in the measured property.  This value may vary "
        "depending on whether the Device is linear over its dynamic "
        "range.") ]
   uint32 Resolution;
      [Description (
        "Indicates the tolerance of the Sensor for the measured "
        "property. Tolerance, along with Resolution and Accuracy, "
        "is used to calculate the actual value of the measured "
        "physical property.  Tolerance may vary depending on "
        "whether the Device is linear over its dynamic range.") ]
   sint32 Tolerance;
      [Description (
        "Indicates the accuracy of the Sensor for the measured "
        "property. Its value is recorded as plus/minus hundredths "
        "of a percent. Accuracy, along with Resolution and Tolerance, "
        "is used to calculate the actual value of the measured "
        "physical property. Accuracy may vary depending on whether "
        "the Device is linear over its dynamic range."), 
       Units ("Hundredths of Percent") ]
   sint32 Accuracy;
      [Description (
        "Indicates that the Sensor is linear over its dynamic range.") ] 
   boolean IsLinear;
      [Description (
        "Indicates the margin built around the thresholds. This margin "
        "prevents unnecessary state changes when the Sensor reading may "
        "fluctuate very close to its thresholds. This could be due to "
        "the Sensor's tolerance/accuracy/resolution or due to "
        "environmental factors. Once a threshold is crossed, the state of "
        "the Sensor should change. However, the state should not "
        "fluctuate between the old and new states unless the Sensor's "
        "change in the reading exceeds the hysteresis value.") ]
   uint32 Hysteresis;
      [Description (
        "The Sensor's threshold values specify the ranges (min and max "
        "values) for determining whether the Sensor is operating under "
        "Normal, NonCritical, Critical or Fatal conditions. If Current"
        "Reading is between LowerThresholdNonCritical and UpperThreshold"
        "NonCritical, then the Sensor is reporting a normal value. "
        "If CurrentReading is between LowerThresholdNonCritical and Lower"
        "ThresholdCritical, then the CurrentState is NonCritical.") ]
   sint32 LowerThresholdNonCritical;
      [Description (
        "The Sensor's threshold values specify the ranges (min and max "
        "values) for determining whether the Sensor is operating under "
        "Normal, NonCritical, Critical or Fatal conditions. If the Current"
        "Reading is between LowerThresholdNonCritical and UpperThreshold"
        "NonCritical, then the Sensor is reporting a normal value. "
        "If the CurrentReading is between UpperThresholdNonCritical and "
        "UpperThresholdCritical, then the CurrentState is NonCritical.") ]
   sint32 UpperThresholdNonCritical;
      [Description (
        "The Sensor's threshold values specify the ranges (min and max "
        "values) for determining whether the Sensor is operating under "
        "Normal, NonCritical, Critical or Fatal conditions. If the Current"
        "Reading is between LowerThresholdCritical and LowerThreshold"
        "Fatal, then the CurrentState is Critical.") ]
   sint32 LowerThresholdCritical;
      [Description (
        "The Sensor's threshold values specify the ranges (min and max "
        "values) for determining whether the Sensor is operating under "
        "Normal, NonCritical, Critical or Fatal conditions. If the Current"
        "Reading is between UpperThresholdCritical and UpperThreshold"
        "Fatal, then the CurrentState is Critical.") ]
   sint32 UpperThresholdCritical;
      [Description (
        "The Sensor's threshold values specify the ranges (min and max "
        "values) for determining whether the Sensor is operating under "
        "Normal, NonCritical, Critical or Fatal conditions. If the Current"
        "Reading is below LowerThresholdFatal, then the CurrentState is "
        "Fatal.") ]
   sint32 LowerThresholdFatal;
     [Description (
       "The Sensor's threshold values specify the ranges (min and max "
       "values) for determining whether the Sensor is operating under "
       "Normal, NonCritical, Critical or Fatal conditions. If the Current"
       "Reading is above UpperThresholdFatal, then the CurrentState is "
       "Fatal.") ]
   sint32 UpperThresholdFatal;
      [Description (
        "An array representing the thresholds supported by this Sensor."), 
       Values {"LowerThresholdNonCritical", "UpperThresholdNonCritical", 
               "LowerThresholdCritical", "UpperThresholdCritical", 
               "LowerThresholdFatal", "UpperThresholdFatal"} ]
   uint16 SupportedThresholds[];
      [Description (
        "An array representing the thresholds that are currently enabled "
        "for this Sensor."), 
       Values {"LowerThresholdNonCritical", "UpperThresholdNonCritical", 
               "LowerThresholdCritical", "UpperThresholdCritical", 
               "LowerThresholdFatal", "UpperThresholdFatal"} ]
   uint16 EnabledThresholds[];
      [Description (
        "An array representing the writable thresholds supported by "
        "Sensor."), 
       Values {"LowerThresholdNonCritical", "UpperThresholdNonCritical", 
               "LowerThresholdCritical", "UpperThresholdCritical", 
               "LowerThresholdFatal", "UpperThresholdFatal"} ]
   uint16 SettableThresholds[];
      [Description (
        "This method resets the values of the thresholds to hardware "
        "defaults. This method returns 0 if successful, 1 if "
        "unsupported and any other value if an error occurred. "
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") ]
   uint32 RestoreDefaultThresholds();
      [Description (
        "For a non-linear Sensor, the resolution, accuracy, tolerance "
        "and hysteresis vary as the current reading moves. This method "
        "can be used to get these factors for a given reading. It "
        "returns 0 if successful, 1 if unsupported, and any other "
        "value if an error occurred. In a subclass, the set of "
        "possible return codes could be specified, using a ValueMap "
        "qualifier on the method. The strings to which the ValueMap "
        "contents are 'translated' may also be specified in the "
        "subclass as a Values array qualifier.") ]
   uint32 GetNonLinearFactors(
       [IN]sint32 SensorReading, 
       [OUT]sint32 Accuracy, 
       [OUT]uint32 Resolution, 
       [OUT]sint32 Tolerance, 
       [OUT]uint32 Hysteresis);
};


// ===================================================================
// TemperatureSensor
// ===================================================================
   [Description (
     "This class exists for backward compatibility to earlier "
     "CIM Schema definitions. With additions to Sensor and Numeric"
     "Sensor in V2.2, it is no longer necessary. A TempertatureSensor "
     "can be defined by setting the SensorType property, inherited "
     "from Sensor, to 2 (\"Temperature\"). Other properties of this "
     "class are hard-coded to constant values to correspond to "
     "definitions in the Sensor hierarchy.") ] 
class CIM_TemperatureSensor : CIM_NumericSensor   {
      [Override("SensorType") ]
   uint16 SensorType = 2;
      [Override("BaseUnits") ]
   uint16 BaseUnits = 2;
      [Override("UnitModifier") ]
   sint32 UnitModifier = -1;
      [Override("RateUnits") ]
   uint16 RateUnits = 0;
// Override is used to define the MappingString qualifier 
      [Override ("CurrentReading"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.5"} ]
   sint32 CurrentReading;
      [Override ("NominalReading"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.6"} ]
   sint32 NominalReading;
      [Override ("NormalMax"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.7"} ]
   sint32 NormalMax;
      [Override ("NormalMin"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.8"} ]
   sint32 NormalMin;
      [Override ("MaxReadable"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.9"} ]     
   sint32 MaxReadable;
      [Override ("MinReadable"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.10"} ]     
   sint32 MinReadable;
      [Override ("Resolution"),
       Units ("Hundredths of Degrees C"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.17"} ]
   uint32 Resolution;
      [Override ("Tolerance"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.18"} ]
   sint32 Tolerance;
      [Override ("Accuracy"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.19"} ]
   sint32 Accuracy;
      [Override ("LowerThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.11"} ]
   sint32 LowerThresholdNonCritical;
      [Override ("UpperThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.12"} ]
   sint32 UpperThresholdNonCritical;
      [Override ("LowerThresholdCritical"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.13"} ]
   sint32 LowerThresholdCritical;
      [Override ("UpperThresholdCritical"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.14"} ]
   sint32 UpperThresholdCritical;
      [Override ("LowerThresholdFatal"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.15"} ]
   sint32 LowerThresholdFatal;
      [Override ("UpperThresholdFatal"),
       MappingStrings {"MIF.DMTF|Temperature Probe|002.16"} ]
   sint32 UpperThresholdFatal;
};


// ===================================================================
// CurrentSensor
// ===================================================================
   [Description (
     "This class exists for backward compatibility to earlier "
     "CIM Schema definitions. With additions to Sensor and Numeric"
     "Sensor in V2.2, it is no longer necessary. A CurrentSensor can "
     "be defined by setting the SensorType property, inherited from "
     "Sensor, to 4 (\"Current\"). Other properties of this class are "
     "hard-coded to constant values to correspond to definitions in "
     "the Sensor hierarchy.") ] 
class CIM_CurrentSensor : CIM_NumericSensor   {
      [Override("SensorType") ]
   uint16 SensorType = 4;
      [Override("BaseUnits") ]
   uint16 BaseUnits = 6;
      [Override("UnitModifier") ]
   sint32 UnitModifier = -3;
      [Override("RateUnits") ]
   uint16 RateUnits = 0;
// Override is used to define the MappingString qualifier 
      [Override ("CurrentReading"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.5"} ]
   sint32 CurrentReading;
      [Override ("NominalReading"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.6"} ]
   sint32 NominalReading;
      [Override ("NormalMax"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.7"} ]
   sint32 NormalMax;
      [Override ("NormalMin"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.8"} ]
   sint32 NormalMin;
      [Override ("MaxReadable"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.9"} ]     
   sint32 MaxReadable;
      [Override ("MinReadable"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.10"} ]     
   sint32 MinReadable;
      [Override ("Resolution"), 
       Units ("Tenths of MilliAmps"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.17"} ]
   uint32 Resolution;
      [Override ("Tolerance"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.18"} ]
   sint32 Tolerance;
      [Override ("Accuracy"), 
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.19"} ]
   sint32 Accuracy;
      [Override ("LowerThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.11"} ]
   sint32 LowerThresholdNonCritical;
      [Override ("UpperThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.12"} ]
   sint32 UpperThresholdNonCritical;
      [Override ("LowerThresholdCritical"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.13"} ]
   sint32 LowerThresholdCritical;
      [Override ("UpperThresholdCritical"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.14"} ]
   sint32 UpperThresholdCritical;
      [Override ("LowerThresholdFatal"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.15"} ]
   sint32 LowerThresholdFatal;
      [Override ("UpperThresholdFatal"),
       MappingStrings {"MIF.DMTF|Electrical Current Probe|001.16"} ]
   sint32 UpperThresholdFatal;
};


// ===================================================================
// VoltageSensor
// ===================================================================
   [Description (
     "This class exists for backward compatibility to earlier "
     "CIM Schema definitions. With additions to Sensor and Numeric"
     "Sensor in V2.2, it is no longer necessary. A VoltageSensor can "
     "be defined by setting the SensorType property, inherited from "
     "Sensor, to 3 (\"Voltage\"). Other properties of this class are "
     "hard-coded to constant values to correspond to definitions in "
     "the Sensor hierarchy.") ] 
class CIM_VoltageSensor : CIM_NumericSensor   {
      [Override("SensorType") ]
   uint16 SensorType = 3;
      [Override("BaseUnits") ]
   uint16 BaseUnits = 5;
      [Override("UnitModifier") ]
   sint32 UnitModifier = -3;
      [Override("RateUnits") ]
   uint16 RateUnits = 0;
// Override is used to define the MappingString qualifier 
      [Override ("CurrentReading"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.5"} ]
   sint32 CurrentReading;
      [Override ("NominalReading"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.6"} ]
   sint32 NominalReading;
      [Override ("NormalMax"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.7"} ]
   sint32 NormalMax;
      [Override ("NormalMin"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.8"} ]
   sint32 NormalMin;
      [Override ("MaxReadable"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.9"} ]     
   sint32 MaxReadable;
      [Override ("MinReadable"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.10"} ]     
   sint32 MinReadable;
      [Override ("Resolution"), 
       Units ("Tenths of MilliVolts"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.17"} ]
   uint32 Resolution;
      [Override ("Tolerance"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.18"} ]
   sint32 Tolerance;
      [Override ("Accuracy"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.19"} ]
   sint32 Accuracy;
      [Override ("LowerThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.11"} ]
   sint32 LowerThresholdNonCritical;
      [Override ("UpperThresholdNonCritical"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.12"} ]
   sint32 UpperThresholdNonCritical;
      [Override ("LowerThresholdCritical"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.13"} ]
   sint32 LowerThresholdCritical;
      [Override ("UpperThresholdCritical"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.14"} ]
   sint32 UpperThresholdCritical;
      [Override ("LowerThresholdFatal"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.15"} ]
   sint32 LowerThresholdFatal;
      [Override ("UpperThresholdFatal"),
       MappingStrings {"MIF.DMTF|Voltage Probe|001.16"} ]
   sint32 UpperThresholdFatal;
};


// ===================================================================
// Tachometer
// ===================================================================
   [Description (
     "This class exists for backward compatibility to earlier "
     "CIM Schema definitions. With additions to Sensor and Numeric"
     "Sensor in V2.2, it is no longer necessary. A Tachometer can "
     "be defined by setting the SensorType property. inherited from "
     "Sensor, to 5 (\"Tachometer\"). Other properties of this class "
     "are hard-coded to constant values to correspond to definitions "
     "in the Sensor hierarchy.") ] 
class CIM_Tachometer : CIM_NumericSensor   {
      [Override("SensorType") ]
   uint16 SensorType = 5;
      [Override("BaseUnits") ]
   uint16 BaseUnits = 38;
      [Override("UnitModifier") ]
   sint32 UnitModifier = 1;
      [Override("RateUnits") ]
   uint16 RateUnits = 4;
      [Override ("Resolution"), 
       Units ("Tenths of Revolutions per Minute") ]
   uint32 Resolution;
};


// ===================================================================
// AssociatedSupplyVoltageSensor
// ===================================================================
   [Association, Description (
     "A PowerSupply may have an associated VoltageSensor, monitoring "
     "its input voltage. This is described by this association.") ]
class CIM_AssociatedSupplyVoltageSensor : CIM_AssociatedSensor {
      [Override ("Antecedent"),
       Description ("The VoltageSensor.") ]
   CIM_VoltageSensor REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The PowerSupply associated with the VoltageSensor.") ]
   CIM_PowerSupply REF Dependent;
      [Description (
        "Indicates the PowerSupply's input voltage range measured "
        "by the associated sensor. Range 1, 2 or both can be specified "
        "using the values 2, 3 or 4, respectively."),
       Values {"Unknown", "Other", "Range 1", "Range 2", 
               "Both Range 1 and 2"} ]
   uint16 MonitoringRange;
};


// ===================================================================
// AssociatedSupplyCurrentSensor
// ===================================================================
   [Association, Description (
     "A PowerSupply may have an associated CurrentSensor, monitoring "
     "its input frequency. This is described by this association.") ]
class CIM_AssociatedSupplyCurrentSensor : CIM_AssociatedSensor {
      [Override ("Antecedent"),
       Description ("The CurrentSensor.") ]
   CIM_CurrentSensor REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The PowerSupply associated with the CurrentSensor.") ]
   CIM_PowerSupply REF Dependent;
      [Description (
        "Indicates the PowerSupply's input frequency range measured "
        "by the associated sensor. Range 1, 2 or both can be specified "
        "using the values 2, 3 or 4, respectively."),
       Values {"Unknown", "Other", "Range 1", "Range 2", 
               "Both Range 1 and 2"} ]
   uint16 MonitoringRange;
};


// ==================================================================
// FCAdapterEventCounters 
// ==================================================================
   [Description (
       "Error and event counters specific to a Fibre Channel Adapter.") ]
class CIM_FCAdapterEventCounters : CIM_DeviceStatisticalInformation {
      [Description ("The number of Abort sequence frames received."), 
       Counter ]
   uint64 ABTSFramesReceived;
      [Description ("The number of Abort sequence frames sent."), 
       Counter ]
   uint64 ABTSFramesSent;
      [Description ("The number of frames busied by the Fabric."), 
       Counter ]
   uint64 FBSYsReceived;
      [Description (
        "The number of frames busied by the receiving Node."),
       Counter ]
   uint64 PBSYsReceived;
      [Description (
        "The number of frames busied by the Adapter itself."),
       Counter ]
   uint64 PBSYsSent;
      [Description ("The number of frames rejected by the Fabric."), 
       Counter ]
   uint64 FRJTsReceived;
      [Description (
        "The number of frames rejected by the receiving Node."),
       Counter ]
   uint64 PRJTsReceived;
      [Description (
        "The number of frames rejected by the Adapter itself."),
       Counter ]
   uint64 PRJTsSent;
      [Description (
        "The number of PRLI frames sent where the response was "
        "LS_RJT."), 
       Counter ]
   uint64 PRLIsRejected;
      [Description (
        "The number of PRLO frames sent where the response was "
        "LS_RJT."), 
       Counter ]
   uint64 PRLOsRejected;
      [Description (
        "The number of Abort sequence frames sent where the response "
        "was BA_RJT."), 
       Counter ]
   uint64 ABTSFramesRejected;
    [Description (
      "Method to reset the Adapter event counters. The method " 
      "takes one parameter as input - an integer indicating which "
      "counter to reset. For this input parameter, 0 indicates all, "
      "1 through 11 indicate a reset of the individual counters. "
      "The method returns 0 if successful, 1 if not supported, and " 
      "any other value if an error occurred. A method is specified "
      "so that the Device's instrumentation, which tabulates "
      "the errors and warnings, can also reset its internal "
      "processing and counters.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") ]
   uint32 ResetCounter (
       [IN, Values {"All", "ABTSFramesReceived", "ABTSFramesSent", 
           "FBSYReceived", "PBSYReceived", "PBSYSent", "FRJTReceived", 
           "PRJTReceived", "PRJTSent", "PRLIRejected", "PRLORejected", 
           "ABTSFramesRejected"}]
       uint16 SelectedCounter);
};


// ==================================================================
// FibrePortEventCounters
// ==================================================================
   [Description (
       "Error and event counters specific to a Fibre Channel Port "
       "(connection point).") ]
class CIM_FibrePortEventCounters : CIM_DeviceStatisticalInformation {
      [Description ("The number of login frames received."), 
       Counter ]
   uint64 PLOGIsReceived;
      [Description ("The number of login frames sent."), 
       Counter ]
   uint64 PLOGIsSent;
      [Description (
        "Number of frames received containing 'EOF Abort'."), 
       Counter ]
   uint64 EOFAbortsReceived;
      [Description (
        "Number of frames transmitted containing 'EOF Abort'."), 
       Counter ]
   uint64 EOFAbortsTransmitted;
      [Description (
        "The number of logouts received from various targets."), 
       Counter ]
   uint64 PLOGOsReceived;
      [Description ("The number of logout frames sent."), 
       Counter ]
   uint64 PLOGOsSent;
      [Description (
        "The number of PLOGI frames sent where the response was "
        "LS_RJT."), 
       Counter ]
   uint64 PLOGIsRejected;
      [Description (
        "The number of PLOGO frames sent where the response was "
        "LS_RJT."), 
       Counter ]
   uint64 PLOGOsRejected;
    [Description (
      "Method to reset the Port event counters. The method " 
      "takes one parameter as input - an integer indicating which "
      "counter to reset. For this input parameter, 0 indicates all, "
      "1 through 8 indicate a reset of the individual counters. "
      "The method returns 0 if successful, 1 if not supported, and " 
      "any other value if an error occurred. A method is specified "
      "so that the Device's instrumentation, which tabulates "
      "the errors and warnings, can also reset its internal "
      "processing and counters.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") ]
   uint32 ResetCounter (
       [IN, Values {"All", "PLOGIsReceived", "PLOGIsSent", 
            "EOFAbortsReceived", "EOFAbortsTransmitted", "PLOGOsReceived", 
            "PLOGOsSent", "PLOGIsRejected", "PLOGOsRejected"}] 
        uint16 SelectedCounter);
};


// ===================================================================
// ComputerSystemProcessor
// ===================================================================
   [Association, Aggregation, Description (
     "Association indicating the processor(s) of a Unitary"
     "ComputerSystem. At least one processor is required. Note "
     "that this relationship inherits from the SystemDevice "
     "association, and therefore, the System Processor is weak to "
     "the aggregating UnitaryComputerSystem.") ] 
class CIM_ComputerSystemProcessor : CIM_SystemDevice {   
      [Override ("GroupComponent"), Aggregate,
       Description ("The UnitaryComputerSystem.") ]
   CIM_UnitaryComputerSystem REF GroupComponent;
      [Override ("PartComponent"), Weak,
       Description (
        "The Processor which is part of the UnitaryComputerSystem.") ]
   CIM_Processor REF PartComponent;
};


// ===================================================================
// LabelReaderStatInfo
// ===================================================================
   [Description (
     "Statistics for a LabelReader, related to read successes, "
     "failures and retries.") ]
class CIM_LabelReaderStatInfo : CIM_DeviceStatisticalInformation {
      [Description (
        "The number of successful physical label scans."), 
       Counter ]
   uint64 ScanSuccesses;
      [Description ("The number of failed physical label scans."), 
       Counter ]
   uint64 ScanFailures;
      [Description ("The number of retried physical label scans."), 
       Counter ]
   uint64 ScanRetries;
      [Description (
        "Method to reset the statistical counters. The method " 
        "takes one parameter as input - an integer indicating which "
        "counter to reset. For this input parameter, 0 indicates all, "
        "1 resets the \"Scan Successes\" counter, 2 resets the "
        "\"Scan Failures\" counter, and 3 resets the \"Scan Retries\" "
        "counter. The method returns 0 if successful, 1 if not supported, "
        "and any other value if an error occurred. A method is specified "
        "so that the Device's instrumentation can also reset its "
        "internal processing and counters.\n"
        "In a subclass, the set of possible return codes should be "
        "specified in a ValueMap qualifier on the method. The strings "
        "to which the ValueMap contents are 'translated' can be "
        "specified as a Values array qualifier.") ]
   uint32 ResetCounter (
      [IN, Values {"All", "Scan Successes", "Scan Failures", 
           "Scan Retries"}] 
       uint16 SelectedCounter);
};


// ===================================================================
// MediaAccessStatInfo
// ===================================================================
   [Description (
     "Statistics related to reading and writing at a specific "
     "MediaAccessDevice, or for a specific StorageExtent. Although "
     "the same class is used to represent this data, at the instance "
     "level the object holds information for the MediaAccessDevice "
     "(independent of the StorageExtent), OR for the Extent "
     "(independent of its AccessDevice).") ]
class CIM_MediaAccessStatInfo : CIM_DeviceStatisticalInformation {
      [Description ("The number of attempted read operations."), 
       Counter ]
   uint64 ReadOperations;
      [Description ("The number of unrecoverable read operations."), 
       Counter ]
   uint64 UnrecoverableReadOperations;
      [Description ("The number of attempted write operations."), 
       Counter ]
   uint64 WriteOperations;
      [Description ("The number of unrecoverable write operations."), 
       Counter ]
   uint64 UnrecoverableWriteOperations;
      [Description ("The number of recovered read operations."), 
       Counter ]
   uint64 RecoveredReadOperations;
      [Description ("The number of recovered write operations."), 
       Counter ]
   uint64 RecoveredWriteOperations;
      [Description ("The number of recovered seek operations."), 
       Counter ]
   uint64 RecoveredSeekOperations;
      [Description ("The number of unrecoverable seek operations."), 
       Counter ]
   uint64 UnrecoverableSeekOperations;
      [Description (
        "Method to reset the statistical counters. The method takes one "
        "parameter as input - an integer indicating which counter to "
        "reset. For this input parameter, 0 indicates all, 1-2 and 5 "
        "reset the 'read operation'-related counters, 3-4 and 6 reset "
        "the 'write operation'-related counters, and 7-8 reset the "
        "seek-related counters. The method returns 0 if "
        "successful, 1 if not supported, and any other value if an "
        "error occurred. A method is specified so that the Device's "
        "instrumentation can also reset its internal processing and "
        "counters.\n"
        "In a subclass, the set of possible return codes should be "
        "specified in a ValueMap qualifier on the method. The strings "
        "to which the ValueMap contents are 'translated' can be "
        "specified as a Values array qualifier.") ]
   uint32 ResetCounter (
      [IN, Values {"All", "Read Operations", 
           "Unrecoverable Read Operations", "Write Operations", 
           "Unrecoverable Write Operations", "Recovered Read Operations", 
           "Recovered Write Operations", "Recovered Seeks", 
           "Unrecoverable Seeks"} ] 
       uint16 SelectedCounter);
};


// ===================================================================
// PickerStatInfo
// ===================================================================
   [Description (
     "Statistics for a PickerElement, related to pick/put successes, "
     "retries and failures.") ]
class CIM_PickerStatInfo : CIM_DeviceStatisticalInformation {
      [Description ("The number of successful picks."), 
       Counter ]
   uint64 PickSuccesses;
      [Description ("The number of failed picks."), 
       Counter ]
   uint64 PickFailures;
      [Description ("The number of retried picks."), 
       Counter ]
   uint64 PickRetries;
      [Description ("The number of successful puts."), 
       Counter ]
   uint64 PutSuccesses;
      [Description ("The number of failed puts."), 
       Counter ]
   uint64 PutFailures;
      [Description ("The number of retried puts."), 
       Counter ]
   uint64 PutRetries;
      [Description (
        "Method to reset the statistical counters. The method takes one "
        "parameter as input - an integer indicating which counter to "
        "reset. For this input parameter, 0 indicates all, 1-3 reset "
        "the 'pick'-related counters, and 4-6 reset the 'put'-related "
        "counters. The method returns 0 if successful, 1 if not "
        "supported, and any other value if an error occurred. A "
        "method is specified so that the Device's instrumentation can "
        "also reset its internal pocessing and counters.\n"
        "In a subclass, the set of possible return codes should be "
        "specified in a ValueMap qualifier on the method. The strings "
        "to which the ValueMap contents are 'translated' can be "
        "specified as a Values array qualifier.") ]
   uint32 ResetCounter (
      [IN, Values {"All", "Pick Successes", "Pick Failures", "Pick Retries", 
           "Put Successes", "Put Failures", "Put Retries"} ] 
       uint16 SelectedCounter);
};


// ===================================================================
//
//    Controllers, Adapters, and Ports
//
// ===================================================================


// ===================================================================
// LogicalPort 
// ===================================================================
   [Description (
     "The abstraction of a port or connection point of a Device. "
     "This object should be instantiated when the Port has "
     "independent management characteristics from the Device that "
     "includes it. Examples are a Fibre Channel Port and a USB Port. "
     "This class would not be instantiated for an Ethernet Port which "
     "is not managed independently of the EthernetAdapter.") ]
class CIM_LogicalPort : CIM_LogicalDevice {
      [Description ("The speed of the Port in Bits per Second."), 
       Units ("Bits per Second") ]
   uint64 Speed;
      [Description (
        "The max speed of the Port in Bits per Second."), 
       Units ("Bits per Second") ]
   uint64 MaxSpeed;
};


// ===================================================================
// PortOnDevice 
// ===================================================================
   [Association, Description (
     "PortOnDevice associates a Port or connection point with its "
     "Device.") ]
class CIM_PortOnDevice : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The Device that includes the Port.") ]
   CIM_LogicalDevice REF Antecedent;
      [Override ("Dependent"), 
       Description ("The Port on the Device.") ]
   CIM_LogicalPort REF Dependent;
};


// ===================================================================
// NetworkAdapter 
// ===================================================================
   [Abstract, Description (
     "NetworkAdapter is an Abstract class defining general "
     "networking hardware concepts (for example, PermanentAddress or "
     "Speed of operation). NetworkAdapters are Devices with the "
     "ability to support multiple, higher level protocols and provide "
     "the implementation behind the Network Model's ProtocolEndpoint "
     "class. (This information is conveyed using the DeviceSAP"
     "Implementation association, defined in the Core Model.) "
     "NetworkAdapters and their Endpoints represent the potential for "
     "connectivity among peers.\n"
     "The 'potential for connectivity' is very different than the "
     "master-slave/controller-controlled by relationships of CIM_"
     "Controller. Sometimes, however, a single Device is both a kind "
     "of NetworkAdapter and a Controller - for example, when a Fibre"
     "ChannelAdapater is operating as a ComputerSystem's SCSIController. "
     "In this case, there are aspects of the Device that are network "
     "oriented and others that are Controller oriented - and, both the "
     "Controller and Adapter classes should be instantiated. A Device"
     "Identity relationship would also be created to tie together these "
     "differing aspects/abstractions of the Device.") ] 
class CIM_NetworkAdapter : CIM_LogicalDevice {
      [MaxLen (64), Description (
        "PermanentAddress defines the network address hardcoded into "
        "an adapter.  This 'hardcoded' address may be changed via "
        "firmware upgrade or software configuration. If so, this field "
        "should be updated when the change is made.  PermanentAddress "
        "should be left blank if no 'hardcoded' address exists for the "
        "NetworkAdapter."),
       MappingStrings {"MIF.DMTF|Network Adapter 802 Port|001.2"} ]       
    string PermanentAddress;
      [MaxLen (64), Description (
        "An array of strings indicating the network addresses for an "
        "adapter."),
       ArrayType ("Indexed"),
       MappingStrings {"MIF.DMTF|Network Adapter 802 Port|001.3"} ]
    string NetworkAddresses[]; 
      [Description (
        "An estimate of the current bandwidth in Bits per Second. "
        "For Adapters which vary in bandwidth or for those where "
        "no accurate estimation can be made, this property should "
        "contain the nominal bandwidth."),
       Units ("Bits per Second"), 
       MappingStrings {"MIB.IETF|RFC1213-MIB.ifSpeed", 
        "MIF.DMTF|Network Adapter 802 Port|001.5"} ]
    uint64 Speed;
      [Description ( 
        "The maximum speed, in Bits per Second, for the Network"
        "Adapter."), 
       Units ("Bits per Second")  ] 
    uint64 MaxSpeed;
      [Description (
        "Boolean indicating that the Adapter is operating in "
        "full duplex mode.") ]
   boolean FullDuplex;
      [Description ( 
        "A boolean indicating whether the NetworkAdapter is capable " 
        "of automatically determining the speed or other communications "
        "characteristics of the attached network media.")  ] 
    boolean AutoSense;
      [Description (
        "The total number of octets transmitted, including framing "
        "characters."),
       Mappingstrings {"MIB.IETF|RFC1213-MIB.ifOutOctets", 
        "MIF.DMTF|Network Adapter 802 Port|001.7"}, 
       Counter ] 
    uint64 OctetsTransmitted;
      [Description (
        "The total number of octets received, including framing "
        "characters."),
       Mappingstrings {"MIB.IETF|RFC1213-MIB.ifInOctets",
        "MIF.DMTF|Network Adapter 802 Port|001.9"}, 
       Counter ] 
    uint64 OctetsReceived;
};


// ===================================================================
// EthernetAdapter
// ===================================================================
   [Description ("Capabilities and management of an EthernetAdapter.") ]
class CIM_EthernetAdapter : CIM_NetworkAdapter {
      [Override ("NetworkAddresses"), 
       Description (
        "Ethernet/802.3 MAC addresses formatted as twelve hexadecimal "
        "digits (e.g. \"010203040506\"), with each pair representing "
        "one of the six octets of the MAC address in \"canonical\" bit "
        "order.  (Thus, the Group address bit is found in the low "
        "order bit of the first character of the string.)"),
       ArrayType ("Indexed") ]
    string NetworkAddresses[];
      [Description (
        "The maximum size of the INFO (non-MAC) field that will be "
        "received or transmitted."), 
       Mappingstrings {"MIB.IETF|BRIDGE-MIB.dot1dTpPortMaxInfo"} ]
    uint32 MaxDataSize;
      [Description (
        "Capabilities of the EthernetAdapter. For example, the "
        "Device may support AlertOnLan, WakeOnLan, Load Balancing "
        "and/or FailOver. If failover or load balancing "
        "capabilities are listed, a SpareGroup (failover) or "
        "ExtraCapacityGroup (load balancing) should also be defined "
        "to completely describe the capability."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "AlertOnLan", "WakeOnLan", 
               "FailOver", "LoadBalancing"}, 
       ModelCorrespondence {
        "CIM_EthernetAdapter.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the EthernetAdapter features "
        "indicated in the Capabilities array. Note, each entry of "
        "this array is related to the entry in the Capabilities "
        "array that is located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_EthernetAdapter.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Specifies which capabilities are enabled from the list "
        "of all supported ones, defined in the Capabilities array."), 
       Values {"Unknown", "Other", "AlertOnLan", "WakeOnLan", 
               "FailOver", "LoadBalancing"}, 
       ModelCorrespondence {"CIM_EthernetAdapter.Capabilities"} ]
   uint16 EnabledCapabilities[];
      [Description (
        "The number of times there was an invalid data symbol when "
        "a valid carrier was present. The count is incremented at "
        "most once per carrier event, even if multiple symbol "
        "errors occur during the carrier event."), 
       MappingStrings {"MIB.IETF|EtherLike-MIB.dot3StatsSymbolErrors"}, 
       Counter ] 
   uint32 SymbolErrors;
      [Description ("The total number of packets transmitted."), 
       MappingStrings {"MIF.DMTF|Network Adapter 802 Port|001.6"}, 
       Counter ] 
   uint64 TotalPacketsTransmitted;
      [Description ("The total number of packets received."), 
       MappingStrings {"MIF.DMTF|Network Adapter 802 Port|001.8"}, 
       Counter ] 
   uint64 TotalPacketsReceived;
      [Description (
        "A count of frames received on a particular interface "
        "that are not an integral number of octets in length and do "
        "not pass the FCS check. The count represented by an "
        "instance of this object is incremented when the alignment"
        "Error status is returned by the MAC layer to the LLC (or "
        "other MAC user). Received frames for which multiple error "
        "conditions obtain are, according to the conventions of IEEE "
        "802.3 Layer Management, counted exclusively according to "
        "the error status presented to the LLC."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsAlignmentErrors"}, 
       Counter ] 
    uint32 AlignmentErrors;
      [Description (
        "A count of frames received on a particular interface "
        "that are an integral number of octets in length but do "
        "not pass the FCS check. The count represented by an "
        "instance of this object is incremented when the frame"
        "CheckError status is returned by the MAC layer to the "
        "LLC (or other MAC user). Received frames for which "
        "multiple error conditions obtain are, according to the "
        "conventions of IEEE 802.3 Layer Management, counted "
        "exclusively according to the error status presented to "
        "the LLC."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsFCSErrors"}, 
       Counter ] 
    uint32 FCSErrors;
      [Description (
        "A count of successfully transmitted frames on a particular "
        "interface for which transmission is inhibited by exactly "
        "one collision. A frame that is counted by an instance of "
        "this object is not counted by the corresponding instance "
        "of the MultipleCollisionFrames property."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsSingleCollisionFrames"}, 
       Counter ] 
    uint32 SingleCollisionFrames;
      [Description (
        "A count of successfully transmitted frames on a particular "
        "interface for which transmission is inhibited by more than "
        "one collision. A frame that is counted by an instance of "
        "this object is not counted by the corresponding instance "
        "of the SingleCollisionFrames property."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsMultipleCollisionFrames"}, 
       Counter ] 
    uint32 MultipleCollisionFrames;
      [Description (
        "A count of times that the SQE TEST ERROR message is "
        "generated by the PLS sublayer for a particular interface. "
        "The SQE TEST ERROR message is defined in section "
        "7.2.2.2.4 of ANSI/IEEE 802.3-1985 and its generation is "
        "described in section 7.2.4.6 of the same document."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsSQETestErrors"}, 
       Counter ] 
    uint32 SQETestErrors;
      [Description (
        "A count of frames for which the first transmission "
        "attempt on a particular interface is delayed because the "
        "medium is busy. The count represented by an instance of "
        "this object does not include frames involved in collisions."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsDeferredTransmissions"}, 
       Counter ] 
    uint32 DeferredTransmissions;
      [Description (
        "The number of times that a collision is detected on a "
        "particular interface later than 512 bit-times into the "
        "transmission of a packet. Five hundred and twelve bit-"
        "times corresponds to 51.2 microseconds on a 10 Mbit/s "
        "system. A (late) collision included in a count "
        "represented by an instance of this object is also "
        "considered as a (generic) collision for purposes of "
        "other collision-related statistics."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsLateCollisions"}, 
       Counter ] 
    uint32 LateCollisions;
      [Description (
        "A count of frames for which transmission on a particular "
        "interface fails due to excessive collisions."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsExcessiveCollisions"}, 
       Counter ] 
    uint32 ExcessiveCollisions;
      [Description (
        "A count of frames for which transmission on a particular "
        "interface fails due to an internal MAC sublayer transmit "
        "error. A frame is only counted by an instance of this "
        "object if it is not counted by the corresponding instance "
        "of either the LateCollisions property, the Excessive"
        "Collisions property, or the CarrierSenseErrors property. "
        "The precise meaning of the count represented by an instance "
        "of this object is implementation-specific.  In particular, "
        "an instance of this object may represent a count of "
        "transmission errors on a particular interface that are "
        "not otherwise counted."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsInternalMacTransmitErrors"}, 
       Counter ] 
    uint32 InternalMACTransmitErrors;
      [Description (
        "A count of frames for which reception on a particular "
        "interface fails due to an internal MAC sublayer receive "
        "error. A frame is only counted by an instance of this "
        "object if it is not counted by the corresponding instance "
        "of either the FrameTooLongs property, the AlignmentErrors "
        "property, or the FCSErrors property. The precise meaning "
        "of the count represented by an instance of this object is "
        "implementation-specific.  In particular, an instance of "
        "this object may represent a count of receive errors on a "
        "particular interface that are not otherwise counted."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsInternalMacReceiveErrors"}, 
       Counter ] 
    uint32 InternalMACReceiveErrors;
      [Description (
        "The number of times that the carrier sense condition was "
        "lost or never asserted when attempting to transmit a frame "
        "on a particular interface. The count represented by an "
        "instance of this object is incremented at most once per "
        "transmission attempt, even if the carrier sense condition "
        "fluctuates during a transmission attempt."),
       Mappingstrings {
        "MIB.IETF|EtherLike-MIB.dot3StatsCarrierSenseErrors"}, 
       Counter ] 
    uint32 CarrierSenseErrors;
      [Description (
        "A count of frames received on a particular interface that "
        "exceed the maximum permitted frame size. The count "
        "represented by an instance of this object is incremented "
        "when the FrameTooLong status is returned by the MAC layer "
        "to the LLC (or other MAC user). Received frames for which "
        "multiple error conditions obtain are, according to the "
        "conventions of IEEE 802.3 Layer Management, counted "
        "exclusively according to the error status presented to "
        "the LLC."),
       Mappingstrings {
       "MIB.IETF|EtherLike-MIB.dot3StatsFrameTooLongs"}, 
       Counter ] 
    uint32 FrameTooLongs;
};


// ===================================================================
// TokenRingAdapter
// ===================================================================
   [Description ("Capabilities and management of a TokenRingAdapter.") ]
class CIM_TokenRingAdapter : CIM_NetworkAdapter {
      [Override ("NetworkAddresses"), Description (
        "Token Ring/802.5 MAC addresses formatted as twelve "
        "hexadecimal digits (e.g. \"010203040506\"), with each pair "
        "representing one of the six octets of the MAC address in "
        "\"canonical\" bit order.  (Thus, the Group address bit is "
        "found in the low order bit of the first character of the "
        "string.)"),
       ArrayType ("Indexed") ]
    string NetworkAddresses[];
      [Description (
        "The maximum size of the INFO (non-MAC) field that will be "
        "received or transmitted."), 
       Mappingstrings {"MIB.IETF|BRIDGE-MIB.dot1dTpPortMaxInfo"} ]
    uint32 MaxDataSize;
      [Description (
        "Capabilities of the TokenRingAdapter. For example, the Device "
        "may support AlertOnLan, WakeOnLan, Load Balancing and/or "
        "Failover. If failover or load balancing capabilities are "
        "listed, a SpareGroup (failover) or ExtraCapacityGroup (load "
        "balancing) should also be defined to completely describe the "
        "capability."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "AlertOnLan", "WakeOnLan", 
               "FailOver", "LoadBalancing"}, 
       ModelCorrespondence {
        "CIM_TokenRingAdapter.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the TokenRingAdapter features "
        "indicated in the Capabilities array. Note, each entry of "
        "this array is related to the entry in the Capabilities array "
        "that is located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_TokenRingAdapter.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Specifies which of the capabilities from the \"Capabilities\" "
        "property are currently enabled."), 
       Values {"Unknown", "Other", "AlertOnLan", "WakeOnLan", 
               "FailOver", "LoadBalancing"}, 
       ModelCorrespondence {"CIM_TokenRingAdapter.Capabilities"} ]
   uint16 EnabledCapabilities[];
      [Description (
        "The current status which can be used to diagnose fluctuating "
        "problems that can occur on token rings, after a station has "
        "successfully been added to the ring. Before an open is completed, "
        "this object contains the value indicating \"no status\" (131072). "
        "(The RingState and RingOpenStatus properties are also provided "
        "for debugging problems when the station can not even enter the "
        "ring.) The property's value is a sum of values, one for each "
        "currently applicable condition. The following values are defined "
        "for various conditions:\n"
        "0 = No Problems Detected, 32 = Ring Recovery, "
        "64 = Single Station, 256 = Remove Received, 512 = Reserved, "
        "1024 = Auto-Removal Error, 2048 = Lobe Wire Fault, "
        "4096 = Transmit Beacon, 8192 = Soft Error, 16384 = Hard Error, "
        "32768 = Signal Loss, 131072 = No Status, Open Not Completed."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5RingStatus"} ]
   uint32 RingStatus;
      [Description (
        "The current Device state with respect to entering or leaving "
        "the ring." ), 
       Values {"Opened", "Closed", "Opening", "Closing", "Open Failure", 
               "Ring Failure"}, 
       MappingStrings {"MIB.IETF|IEEE 802.5 Token Ring MIB.dot5RingState"} ]
   uint16 RingState;
      [Description (
        "This property indicates the success, or the reason for failure, "
        "of the station's most recent attempt to enter the ring." ), 
       Values {"No Open Attempted", "Bad Parameter", "Lobe Failed", 
               "Signal Loss", "Insertion Timeout", "Ring Failed", "Beaconing", 
               "Duplicate MAC", "Request Failed", "Remove Received", 
               "Last Open Successful"}, 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5RingOpenStatus"} ]
   uint16 RingOpenStatus;
      [Description ("The ring's bandwidth."), 
       Values {"Unknown", "Other", "One Megabit", "Four Megabit", 
               "Sixteen Megabit"}, 
       MappingStrings {"MIB.IETF|IEEE 802.5 Token Ring MIB.dot5RingSpeed"} ]
   uint16 RingSpeed;
      [Description (
        "This counter is incremented when a station detects the absence "
        "of transitions for five half-bit timers (burst-five errors)."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsBurstErrors"}, 
       Counter ] 
   uint32 BurstErrors;
      [Description (
        "This counter is incremented when a station receives an AMP or "
        "SMP frame in which A is equal to C is equal to 0, and then "
        "receives another SMP frame with A equal to C equal to 0 without "
        "first receiving an AMP frame. It denotes a station that cannot "
        "set the AC bits properly."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsACErrors"}, 
       Counter ] 
   uint32 ACErrors;
      [Description (
        "This counter is incremented when a station transmits an abort "
        "delimiter while transmitting data."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsAbortTransErrors"}, 
       Counter ] 
   uint32 AbortTransErrors;
      [Description (
        "This counter is incremented when a station recognizes an "
        "internal error."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsInternalErrors"}, 
       Counter ] 
   uint32 InternalErrors;
      [Description (
        "This counter is incremented when a station is transmitting "
        "and its TRR timer expires. This denotes a condition where a "
        "transmitting station in strip mode does not receive the "
        "trailer of the frame before the TRR timer goes off."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsLostFrameErrors"}, 
       Counter ] 
   uint32 LostFrameErrors;
      [Description (
        "This counter is incremented when a station recognizes a frame "
        "addressed to its specific address, but has no available buffer "
        "space - indicating that the station is congested."), 
      MappingStrings {
       "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsReceiveCongestions"}, 
       Counter ] 
   uint32 ReceiveCongestions;
      [Description (
        "This counter is incremented when a station recognizes a frame "
        "addressed to its specific address and detects that the FS field "
        "A bits are set to 1 indicating a possible line hit or duplicate "
        "address."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsFrameCopiedErrors"}, 
       Counter ] 
   uint32 FrameCopiedErrors;
      [Description (
        "This counter is incremented when a station acting as the active "
        "monitor recognizes an error condition that needs a token "
        "transmitted."), 
       MappingStrings {
       "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsTokenErrors"}, 
       Counter ]
   uint32 TokenErrors;
      [Description (
        "The number of Soft Errors that the Device has detected. It "
        "directly corresponds to the number of Report Error MAC frames "
        "that this Device has transmitted. Soft Errors are those which "
        "are recoverable by the MAC layer protocols."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsSoftErrors"}, 
       Counter ]
   uint32 SoftErrors;
      [Description (
        "The number of times this Device has detected an immediately "
        "recoverable fatal error. It denotes the number of times this "
        "Device is either transmitting or receiving beacon MAC frames. "), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsHardErrors"}, 
       Counter ]
   uint32 HardErrors;
      [Description (
        "The number of times this Device has detected the loss of "
        "signal condition from the ring."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsSignalLoss"}, 
       Counter ]
   uint32 SignalLossCount;
      [Description (
        "The number of times this Device has transmitted a beacon "
        "frame."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsTransmitBeacons"}, 
       Counter ]
   uint32 TransmittedBeacons;
      [Description (
        "The number of Claim Token MAC frames received or transmitted "
        "after the Device has received a Ring Purge MAC frame. This "
        "counter signifies the number of times the ring has been purged "
        "and is being recovered back into a normal operating state."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsRecoverys"}, 
       Counter ]
   uint32 Recoverys;
      [Description (
        "The number of times the Device has detected an open or short "
        "circuit in the lobe data path. The adapter will be closed and "
        "RingState will signify this condition."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsLobeWires"}, 
       Counter ]
   uint32 LobeWires;
      [Description (
        "The number of times the Device has received a Remove Ring "
        "Station MAC frame request. When this frame is received, the "
        "Device will enter the close state and RingState will "
        "signify this condition."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsRemoves"}, 
       Counter ]
   uint32 Removes;
      [Description (
        "The number of times the Device has sensed that it is the "
        "only station on the ring. This will happen if the Device "
        "is the first one up on a ring, or if there is a hardware "
        "problem."), 
      MappingStrings {
       "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsSingles"}, 
       Counter ]
   uint32 Singles;
      [Description (
        "The number of times the Device has detected that the "
        "frequency of the incoming signal differs from the expected "
        "frequency by more than that specified by the IEEE 802.5 "
        "standard."), 
       MappingStrings {
        "MIB.IETF|IEEE 802.5 Token Ring MIB.dot5StatsFreqErrors"}, 
       Counter ]
   uint32 FrequencyErrors;
};

// ==================================================================
// FibreChannelAdapter 
// ==================================================================
   [Description (
     "Capabilities and management of a Fibre Channel Adapter.") ]
class CIM_FibreChannelAdapter : CIM_NetworkAdapter {
      [Description (
        "The maximum frame size, in bytes, supported by the Adapter."), 
       Units ("Bytes") ]
   uint64 MaxFrameSize;
      [Description (
        "The Fibre Channel Classes of Service that are supported by "
        "the Adapter, on its Ports. The currently negotiated COS for a "
        "connection is a property (NegotiatedCOS) on the FibrePort"
        "ActiveLogin association."), 
       Values {"Unknown", "1", "2", "3", "4", "6", "F"} ]
   uint16 SupportedCOS[];
      [Description (
        "An array of integers indicating the Fibre Channel FC-4 "
        "protocols supported by the Adapter. The protocols that are "
        "active and running are indicated in the CurrentFC4Types "
        "property. The values used in this array are taken from the "
        "FC-GS2 (bitmapped) field defined in Table 11 of the standard. "
        "Also, FC-SB-2 codes are included from the T11 document, "
        "236V0. If the FC4 Type is \"Vendor Unique\" (value=255), "
        "then the specific vendor values (in the range, 0xE0 to 0xFF) "
        "should be listed in the FC4VendorUniqueTypes property."), 
       ValueMap {"0", "1", "4", "5", "8", "9", "17", "18", "19", "21", 
                 "22", "23", "25", "26", "27", "28", "32", "34", "36", 
                 "64", "80", "81", "82", "88", "96", "255"}, 
       Values {"Unknown", "Other", "ISO/IEC 8802 - 2 LLC", 
               "IP over FC", "SCSI - FCP", "SCSI - GPP", 
               "IPI - 3 Master", "IPI - 3 Slave", "IPI - 3 Peer", 
               "CP IPI - 3 Master", "CP IPI - 3 Slave", 
               "CP IPI - 3 Peer", "SBCCS Channel", 
               "SBCCS Control Unit", "FC-SB-2 Channel", 
               "FC-SB-2 Control Unit", 
               "Fibre Channel Services (FC-GS, FC-GS-2, FC-GS-3)", 
               "FC-SW", "FC - SNMP", "HIPPI - FP", "BBL Control", 
               "BBL FDDI Encapsulated LAN PDU", 
               "BBL 802.3 Encapsulated LAN PDU", "FC - VI", "FC - AV", 
               "Vendor Unique"}, 
       ModelCorrespondence {
        "CIM_FibreChannelAdapter.FC4VendorUniqueTypes"} ]
   uint16 FC4TypesSupported[];
      [MinValue (240), MaxValue (255), Description (
        "When the FC4TypesSupported array contains the value 255 "
        "(\"Vendor Unique\"), then the property, FC4VendorUniqueTypes, "
        "lists of all the vendor specific protocols supported by the "
        "Adapter. These values are in the range, 0xE0 to 0xFF.") ]
   uint16 FC4VendorUniqueTypes[];
      [Description (
        "An array of integers indicating the Fibre Channel FC-4 "
        "protocols currently running on the Adapter. A list of all "
        "protocols supported by the Adapter is indicated in the "
        "FC4TypesSupported property. The values used in this array "
        "are taken from the FC-GS2 (bitmapped) field defined in "
        "Table 11 of the standard. Also, FC-SB-2 codes are included "
        "from the T11 document, 236V0. If the FC4 Type is \"Vendor "
        "Unique\" (value=255), then the specific vendor values "
        "(in the range, 0xE0 to 0xFF) that are currently running "
        "should be listed in the CurrentFC4VendorTypes property."), 
       ValueMap {"0", "1", "4", "5", "8", "9", "17", "18", "19", "21", 
                 "22", "23", "25", "26", "27", "28", "32", "34", "36", 
                 "64", "80", "81", "82", "88", "96", "255"}, 
       Values {"Unknown", "Other", "ISO/IEC 8802 - 2 LLC", 
               "IP over FC", "SCSI - FCP", "SCSI - GPP", 
               "IPI - 3 Master", "IPI - 3 Slave", "IPI - 3 Peer", 
               "CP IPI - 3 Master", "CP IPI - 3 Slave", 
               "CP IPI - 3 Peer", "SBCCS Channel", 
               "SBCCS Control Unit", "FC-SB-2 Channel", 
               "FC-SB-2 Control Unit", 
               "Fibre Channel Services (FC-GS, FC-GS-2, FC-GS-3)", 
               "FC-SW", "FC - SNMP", "HIPPI - FP", "BBL Control", 
               "BBL FDDI Encapsulated LAN PDU", 
               "BBL 802.3 Encapsulated LAN PDU", "FC - VI", "FC - AV", 
               "Vendor Unique"}, 
       ModelCorrespondence {
        "CIM_FibreChannelAdapter.FC4TypesSupported", 
        "CIM_FibreChannelAdapter.CurrentFC4VendorTypes"} ]
   uint16 CurrentFC4Types[];
      [MinValue (240), MaxValue (255), Description (
        "When the CurrentFC4Types array contains the value 255 "
        "(\"Vendor Unique\"), then the property, CurrentFC4VendorTypes, "
        "lists all the vendor specific protocols running on the "
        "Adapter. These values are in the range, 0xE0 to 0xFF."), 
       ModelCorrespondence {
        "CIM_FibreChannelAdapter.FC4VendorUniqueTypes"} ]
   uint16 CurrentFC4VendorTypes[];
      [Description (
        "A list of the Capabilities of the Fibre Channel Adapter. "
        "For example, that the Adapter utilizes the Directory Server, "
        "or that it generates State Change Notifications can be "
        "indicated using the values 2 and 12, respectively."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Utilizes the Directory Server", 
               "Utilizes the Time Server", 
               "Utilizes the Management Server", 
               "Utilizes the Alias Server", 
               "Utilizes the Security Key Distribution Server", 
               "Utilizes the Clock Synchronization Server", 
               "Utilizes the Multicast Server", 
               "Utilizes QoS Facilitator", 
               "Utilizes Broadcast Services", 
               "Supports Fabric Login Server", 
               "Generates State Change Notifications", 
               "Registers for State Change Notifications", 
               "Responds to Read Connection Status", 
               "Supports Third Party Process Logout"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the Adapter features indicated in "
        "the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_FibreChannelAdapter.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "The number of times that a frame was received but no "
        "buffer was available."), 
       Counter ]
   uint64 ReceiveBufferErrors;
      [Description (
        "The number of times that a frame was received but no "
        "end-to-end credit was available."), 
       Counter ]
   uint64 ReceiveEndErrors;
      [Description (
        "A 'long' timeout value (in milliseconds) for determining "
        "when to reinstate a Recovery_Qualifier. The default value "
        "is 120 seconds (120000 milliseconds). It is typically set "
        "to the ErrorDetectTimeout value + 2*(fabric delay time)."), 
       Units ("MilliSeconds") ]
   uint64 ResourceAllocationTimeout;
      [Description (
        "A 'short' timeout value (in milliseconds) for determining "
        "that an error has occurred. The default value is 10 "
        "seconds (10000 milliseconds)."), 
       Units ("MilliSeconds") ]
   uint64 ErrorDetectTimeout;
      [Description (
        "Number of Class 1 sequences sent since last reset of the "
        "Device."), 
       Counter ]
   uint64 Class1SequencesSent;
      [Description (
        "Number of Class 2 sequences sent since last reset of the "
        "Device."),
       Counter ]
   uint64 Class2SequencesSent;
      [Description (
        "Number of Class 3 sequences sent since last reset of the "
        "Device."),
       Counter ]
   uint64 Class3SequencesSent;
      [Description (
        "Number of Class 4 sequences sent since last reset of the "
        "Device."),
       Counter ]
   uint64 Class4SequencesSent;
      [Description (
        "Number of octets received by the Adapter when running "
        "Class 2 service."),
       Counter ]
   uint64 Class2OctetsReceived;
      [Description (
        "Number of octets transmitted by the Adapter when running "
        "Class 2 service."),
       Counter ]
   uint64 Class2OctetsTransmitted;
      [Description (
        "Number of frames received by the Adapter when running "
        "Class 2 service."), 
       Counter ]
   uint64 Class2FramesReceived;
      [Description (
        "Number of frames transmitted by the Adapter when running "
        "Class 2 service."),
       Counter ]
   uint64 Class2FramesTransmitted;
      [Description (
        "Number of frames discarded by the Adapter when running "
        "Class 2 service."),
       Counter ]
   uint64 Class2DiscardFrames;
      [Description (
        "Number of octets received by the Adapter when running "
        "Class 3 service."),
       Counter ]
   uint64 Class3OctetsReceived;
      [Description (
        "Number of octets transmitted by the Adapter when running "
        "Class 3 service."),
       Counter ]
   uint64 Class3OctetsTransmitted;
      [Description (
        "Number of frames received by the Adapter when running "
        "Class 3 service."), 
       Counter ]
   uint64 Class3FramesReceived;
      [Description (
        "Number of frames transmitted by the Adapter when running "
        "Class 3 service."),
       Counter ]
   uint64 Class3FramesTransmitted;
      [Description (
        "Number of frames discarded by the Adapter when running "
        "Class 3 service."),
       Counter ]
   uint64 Class3DiscardFrames;
      [Description (
        "Number of parity errors detected somewhere in the "
        "data path."),
       Counter ]
   uint64 ParityErrors;
      [Description (
        "Number of Class 1 or 2 frames that are not ACKed "
        "within the time indicated by ErrorDetectTimeout."), 
       Counter ]
   uint64 FrameTimeouts;
      [Description (
        "Number of times that the Device has been without a "
        "buffer credit for a time longer than ErrorDetectTimeout."), 
       Counter ]
   uint64 BufferCreditErrors;
      [Description (
        "Number of times that the Device has been without an end "
        "credit for a time longer than ErrorDetectTimeout."), 
       Counter ]
   uint64 EndCreditErrors;
      [Description ("Number of frames received out of order."), 
       Counter ]
   uint64 OutOfOrderFramesReceived;
};


// ==================================================================
// FibrePort 
// ==================================================================
   [Description (
     "Capabilities and management of a Fibre Channel Port Device.") ]
class CIM_FibrePort : CIM_LogicalPort {
      [Description (
        "An address value used to identify the source (S_ID) or "
        "destination (D_ID) of a frame. The FC-SW standard includes a "
        "table of special address identifier values and their "
        "meanings. Consult the FC-SW documentation for additional "
        "information.") ]
   uint32 AddressIdentifier;
      [Description (
        "An array indicating the modes in which the Port can operate. "
        "PortType values describe the role and behavior of the Fibre "
        "Channel entity: \"N\" = Node Port, \"NL\" = Node Port "
        "supporting FC arbitrated loop, \"E\" = Expansion Port "
        "connecting fabric elements (for example, FC switches), "
        "\"F\" = Fabric (element) Port, \"FL\" = Fabric (element) "
        "Port supporting FC arbitrated loop, and \"B\" = Bridge "
        "Port. PortTypes are defined in the ANSI X3 standards.\n\n"
        "A particular mode may be listed multiple times in the "
        "SupportedPortTypes array in order to define that multiple, "
        "unique version levels are supported. Version information is "
        "defined in the PortTypeVersions property. Note that each "
        "entry of the SupportedPortTypes array is related to the entry "
        "in PortTypeVersions that is located at the same index."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", 
               "FL", "B"}, 
       ModelCorrespondence {"CIM_FibrePort.PortTypeVersions"} ]
   uint16 SupportedPortTypes[];
      [Description (
        "Version information for each of the SupportedPortTypes. A "
        "particular PortType (mode) may be listed multiple times in "
        "the SupportedPortTypes array in order to define multiple, "
        "unique version levels. Note that each entry of this array "
        "is related to the entry in SupportedPortTypes that is "
        "located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_FibrePort.SupportedPortTypes"} ]
   string PortTypeVersions[];
      [Description (
        "The specific modes currently enabled for the Port. The "
        "values are equal to, or a subset of the values in the Supported"
        "PortTypes array."), 
       Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", 
               "FL", "B"}, 
       ModelCorrespondence {"CIM_FibrePort.SupportedPortTypes", 
        "CIM_FibrePort.EnabledVersions"} ]
   uint16 EnabledPortTypes[];
      [Description (
        "Version information for each of the EnabledPortTypes. A "
        "particular PortType (mode) may be listed multiple times in "
        "the EnabledPortTypes array in order to define multiple, "
        "unique version levels. Note that each entry of this array "
        "is related to the entry in EnabledPortTypes that is located "
        "at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_FibrePort.EnabledPortTypes"} ]
   string EnabledVersions[];
      [Description (
        "The specific mode in which the Port is currently running. The "
        "value is one of the entries in the EnabledPortTypes array. The "
        "current port type/mode is dependent on the fibre technology. "
        "For example, in a public loop network, you might indicate a "
        "port type of \"FL\" (value=6) or \"NL\" (value=2)."), 
       Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", 
               "FL", "B"}, 
       ModelCorrespondence {"CIM_FibrePort.EnabledPortTypes", 
        "CIM_FibrePort.CurrentVersion"} ]
   uint16 CurrentPortType;
      [Description (
        "Version information for the CurrentPortType that is active."), 
       ModelCorrespondence {"CIM_FibrePort.CurrentPortType"} ]
   string CurrentVersion;
      [Description (
        "One or more address identifiers that may be recognized by "
        "the Port, in addition to its port-specific identifier. "
        "Multicast or hunt group addresses that are recognized by "
        "the Port would be identified in this array.") ]
   uint32 AliasAddresses[];
      [Description (
        "Number of times that signal is lost on the Port since last "
        "reset of the Device."), 
       Counter ]
   uint64 LossOfSignalCounter;
      [Description (
        "Number of times that synchronization is lost on the Port "
        "since last reset of the Device. Synchronization is assumed "
        "lost after a timeout period identified by the Receiver"
        "TransmitterTimeout property."), 
       Counter ]
   uint64 LossOfSyncCounter;
      [Description (
        "Number of times that the CRC in a frame does not match the "
        "CRC computed by the receiver."), 
       Counter ]
   uint64 CRCErrors;
      [Description (
        "The number of transmission words that had an 8b10b code "
        "violation in one or more of its characters, had a "
        "K28.5 in its second, third or fourth character positions, "
        "and/or was an ordered set that had an incorrect Beginning "
        "Running Disparity."), 
       Counter ]
   uint64 InvalidTransmissionWords;
      [Description (
        "The number of frames received that were shorter than 28 "
        "octets. The value of 28 is calculated based on an "
        "assumption of 24 header bytes plus 4 CRC bytes. The "
        "count does not include SOF/EOF bytes which are not data."), 
       Counter ]
   uint64 FramesTooShort;
      [Description (
        "The number of frames received that were longer than 2140 "
        "octets. The value of 2140 is calculated based on an "
        "assumption of 24 header bytes plus 4 CRC bytes and 2112 "
        "bytes of payload."), 
       Counter ]
   uint64 FramesTooLong;
      [Description (
        "The number of times that a fill word could not be "
        "inserted, when required. The Elasticity Buffer is defined "
        "in FC-AL. This event might cause data corruption and may "
        "indicate a configuration error or a device out of spec."), 
       Counter ]
   uint64 ElasticityBufferUnderruns;
      [Description (
        "The number of times that a fill word could not be deleted, "
        "when required. The Elasticity Buffer is defined in FC-AL. "
        "This event might cause data corruption and may indicate a "
        "configuration error or a device out of spec."), 
       Counter ]
   uint64 ElasticityBufferOverruns;
      [Description (
        "Timeout value in milliseconds used to determine when "
        "loss of synchronization has occurred. The typical default "
        "is 100 msec."), 
      Units ("Milliseconds") ]
   uint64 ReceiverTransmitterTimeout;
      [Description (
        "Indication of whether the Port is currently bypassed "
        "(value=2) or not (value=1). A value of 3 (\"Forced Insert\") "
        "describes that the Port is forced active, when it would "
        "otherwise be \"Bypassed\"."), 
       Values {"Unknown", "Not Bypassed", "Bypassed", 
               "Forced Insert"} ]
   uint16 BypassedState;
       [Description (
         "The type of cabling as sensed by the Port. Not all FibrePorts "
         "are capable of providing this information. In this case, a "
         "value of 0, \"Unknown\", will be returned. Also, when single or "
         "multi-mode fiber cabling can not be distinguished, the more "
         "general value - 4, \"Fiber-optic\" - can be specified."), 
       Values {"Unknown", "Other", "No Media", "Copper/Twinaxial", 
               "Fiber-optic", "Fiber Single Mode", "Fiber Multimode"}] 
   uint16 ConnectedMedia;
};


// ===================================================================
// FibrePortOnFCAdapter
// ===================================================================
   [Association, Description (
     "FibrePortOnFCAdapter associates a FibrePort with a FibreChannel"
     "Adapter. Cardinalities are defined as Max(1) to indicate the "
     "intent and usage of the model - that an Adapter is synonymous "
     "with its Port (connection point). Where you have a multi-Port "
     "Adapter and more than one Port may be active at a time, "
     "individual Adapters with individual operating data and "
     "characteristics really exist. If you have multiple connection "
     "points, but they exist only to provide multiple physical form "
     "factors (only one connection may be active at a time), then one "
     "FibreChannelAdapter and one FibrePort (the active one) exist. "
     "On the hardware side, the realizations of these entities "
     "in PhysicalElements may be as a CIM_Card (for example) with "
     "multiple CIM_PhysicalConnectors.") ]
class CIM_FibrePortOnFCAdapter : CIM_PortOnDevice {
      [Override ("Antecedent"), Max (1), 
       Description (
        "The FibreChannelAdapter that includes the Port.") ]
   CIM_FibreChannelAdapter REF Antecedent;
      [Override ("Dependent"), Max (1), 
       Description ("The FibrePort on the Adapter.") ]
   CIM_FibrePort REF Dependent;
};


// ==================================================================
// FibrePortActiveLogin
// ==================================================================
   [Association, Description (
     "FibrePortActiveLogin indicates that two FibrePorts are "
     "connected via a login and have negotiated their Class Of "
     "Service, frame size and other link characteristics, as "
     "specified by an instance of this class.\n"
     "The class' key is composed of the login originator's and "
     "responder's keys plus the Class Of Service. This combination "
     "is unique and prevents subclassing FibrePortActiveLogin "
     "from its reasonable superclass, DeviceConnection.") ]
class CIM_FibrePortActiveLogin  {
      [Key, Description ("The originator of the login.") ]
   CIM_FibrePort REF LoginOriginator;
      [Key, Description ("The responder to the login.") ]
   CIM_FibrePort REF LoginResponder;
      [Key, Description (
        "The Fibre Channel Class of Service that is currently running "
        "between the Ports. Since two Ports can be simultaneously "
        "connected at different Classes of Service, this property had "
        "to be part of the object's key and therefore, an instance's "
        "identity."), 
       Values {"Unknown", "1", "2", "3", "4", "6", "F"}, 
       ModelCorrespondence {"CIM_FibreChannelAdapter.SupportedCOS"},
       MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.5"}  ]
   uint16 NegotiatedCOS;
      [Description (
        "The Fibre Channel frame size, in bytes, that is currently "
        "negotiated between the two Ports."), 
       Units ("Bytes") ]
   uint64 NegotiatedFrameSize;
      [Description (
        "The speed for communications that is currently negotiated "
        "between the two Ports. Speed is specified in bits per second. "
        "If this information is not available, the property should be "
        "set to 0."), 
       Units ("Bits per Second") ]
   uint64 NegotiatedSpeed;
      [Description (
        "Acknowledgement model negotiated during Port login. For "
        "example, ACK-1 indicates that each frame should be "
        "acknowledged."), 
       Values {"Unknown", "ACK-0", "ACK-1", "ACK-N"},
       MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.6"} ]
   uint16 ACKModel;
      [Description (
        "The buffer-to-buffer model negotiated during Port login. "
        "Either the model defined by the FC-PH standard is used "
        "(value=1, \"Regular\"), or an \"Alternate\" model is "
        "negotiated."), 
       Values {"Unknown", "Regular", "Alternate"} ]
   uint16 BufferToBufferModel;
      [Description (
        "OriginatorBufferCredit reflects the buffer credit of the "
        "Port defined as the LoginOriginator. It is the number of "
        "frame buffers made available BY the originating Port, TO "
        "the responder Port. Buffer credits are used in point to "
        "point connections, when an NL-Local Port is logged into "
        "another NL-Local Port, and when Nx Ports are logged into "
        "Fx Ports. In other scenarios, this value is undefined."),
        MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.3"}  ]
   uint64 OriginatorBufferCredit;
      [Description (
        "ResponderBufferCredit reflects the buffer credit of the "
        "Port defined as the LoginResponder. It is the number of "
        "frame buffers made available BY the responder Port, TO "
        "the originating Port. Buffer credits are used in point to "
        "point connections, when an NL-Local Port is logged into "
        "another NL-Local Port, and when Nx Ports are logged into "
        "Fx Ports. In other scenarios, this value is undefined."),
        MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.3"}  ]
   uint64 ResponderBufferCredit;
      [Description (
        "OriginatorEndCredit reflects the end credit of the Port "
        "defined as the LoginOriginator. It is the number of frame "
        "buffers made available BY the originating Port, TO the "
        "responder Port. End credits are used in point to point "
        "connections, when an NL-Local Port is logged into another "
        "NL-Local Port, and when Nx Ports are logged into remote "
        "Nx Ports. In other scenarios, this value is undefined."),
        MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.2"}  ]
   uint64 OriginatorEndCredit;
      [Description (
        "ResponderEndCredit reflects the end credit of the Port "
        "defined as the LoginResponder. It is the number of frame "
        "buffers made available BY the responder Port, TO the "
        "originating Port. End credits are used in point to point "
        "connections, when an NL-Local Port is logged into another "
        "NL-Local Port, and when Nx Ports are logged into remote "
        "Nx Ports. In other scenarios, this value is undefined."),
        MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.2"}  ]
   uint64 ResponderEndCredit;
};


// ===================================================================
// Controller
// ===================================================================
   [Abstract, Description (
     "Controller is a superclass for grouping the miscellaneous "
     "control-related Devices that exist. Examples of Controllers "
     "are SCSIControllers, USBControllers, SerialControllers, ... "
     "The Controller class is an abstraction for Devices with a "
     "single protocol stack, which exist primarily for communication "
     "to, and control or reset of downstream (ControlledBy) Devices.") ] 
class CIM_Controller : CIM_LogicalDevice {
      [Description ("Time of last reset of the Controller.") ]
   datetime TimeOfLastReset;
      [Description (
        "The protocol used by the Controller to access 'controlled' "
        "Devices."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "13", "14", "15", "16", "17", "18", "19",
                 "20", "21", "22", "23", "24", "25", "26", "27", "28",
                 "29", "30", "31", "32", "33", "34", "35", "36", "37",
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", 
                 "47"},
       Values {"Other", "Unknown", "EISA", "ISA", "PCI", "ATA/ATAPI",
               "Flexible Diskette", "1496", "SCSI Parallel Interface",
               "SCSI Fibre Channel Protocol", "SCSI Serial Bus Protocol",
               "SCSI Serial Bus Protocol-2 (1394)", 
               "SCSI Serial Storage Architecture", "VESA", "PCMCIA",        
               "Universal Serial Bus", "Parallel Protocol", "ESCON",
               "Diagnostic", "I2C", "Power", "HIPPI", "MultiBus", "VME",
               "IPI", "IEEE-488", "RS232", "IEEE 802.3 10BASE5",
               "IEEE 802.3 10BASE2", "IEEE 802.3 1BASE5",
               "IEEE 802.3 10BROAD36", "IEEE 802.3 100BASEVG",
               "IEEE 802.5 Token-Ring", "ANSI X3T9.5 FDDI", "MCA", 
               "ESDI", "IDE", "CMD", "ST506", "DSSI", "QIC2", 
               "Enhanced ATA/IDE", "AGP", "TWIRP (two-way infrared)", 
               "FIR (fast infrared)", "SIR (serial infrared)", 
               "IrBus"}, 
       MappingStrings {"MIF.DMTF|Bus Port|003",
        "MIF.DMTF|Disks|003.3"},
       ModelCorrespondence {"CIM_Controller.ProtocolDescription"} ]
   uint16 ProtocolSupported;
      [Description (
        "Maximum number of directly addressable entities supported "
        "by this Controller.  A value of 0 should be used if the "
        "number is unknown or unlimited."),
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
   uint32 MaxNumberControlled;  
      [Description (
        "A free form string providing more information related "
        "to the ProtocolSupported by the Controller."),
       ModelCorrespondence {"CIM_Controller.ProtocolSupported"},
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
    string ProtocolDescription;
};


// ===================================================================
// ControlledBy
// ===================================================================
   [Association, Description (
     "The ControlledBy relationship indicates which Devices are "
     "commanded by or accessed through the Controller LogicalDevice.") ] 
class CIM_ControlledBy : CIM_DeviceConnection {
      [Override ("Antecedent"),
       Description ("The Controller.") ]
   CIM_Controller REF Antecedent;
      [Override ("Dependent"),
       Description ("The controlled Device.") ]
   CIM_LogicalDevice REF Dependent;
      [Description (
        "The State property indicates whether the Controller is "
        "actively commanding or accessing the Device (value=1) or "
        "not (value=2).  Also, the value, \"Unknown\" (0), can be "
        "defined. This information is necessary when a LogicalDevice "
        "can be commanded by, or accessed through, multiple "
        "Controllers."),
       Values {"Unknown", "Active", "Inactive"} ]
   uint16 AccessState;
      [Description (
        "The time that the downstream Device was last reset by "
        "the Controller.") ]
   datetime TimeOfDeviceReset;
      [Description (
        "Number of hard resets issued by the Controller. A hard reset "
        "returns the Device to its initialization or 'boot-up' state. "
        "All internal Device state information and data are lost."), 
       Counter ]
   uint32 NumberOfHardResets;
      [Description (
        "Number of soft resets issued by the Controller. A soft "
        "reset does not completely clear current Device state and/or "
        "data. Exact semantics are dependent on the Device, and on "
        "the protocols and mechanisms used to communicate to it."), 
       Counter ]
   uint32 NumberOfSoftResets;
};


// ===================================================================
// SerialController
// ===================================================================
   [Description (
     "Capabilities and management of the SerialController.") ]
class CIM_SerialController : CIM_Controller {
      [Description (
        "The Capabilities property defines chip level compatibility "
        "for the SerialController.  Therefore, this property describes "
        "the buffering and other capabilities of the SerialController, "
        "that may be inherent in the chip hardware. The property is "
        "an enumerated integer."),
       ArrayType ("Indexed"),
       ValueMap {"1", "2", "3", "4", "5", "6", "160", "161"},      
       Values {"Other", "Unknown", "XT/AT Compatible", 
               "16450 Compatible", "16550 Compatible", 
               "16550A Compatible", "8251 Compatible",
               "8251FIFO Compatible"},
       MappingStrings {"MIF.DMTF|Serial Ports|004.7"},
       ModelCorrespondence {
        "CIM_SerialController.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the SerialController features "
        "indicated in the Capabilities array. Note, each entry of "
        "this array is related to the entry in the Capabilities "
        "array that is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_SerialController.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Maximum baud rate in Bits per Second supported by the "
        "SerialController."),
       Units ("Bits per Second"),
       MappingStrings {"MIF.DMTF|Serial Ports|004.6"} ]
   uint32 MaxBaudRate; 
      [Description (
        "An enumeration indicating the operational security for the "
        "Controller. For example, information that the Device's "
        "external interface is locked out (value=4) or \"Boot "
        "Bypass\" (value=6) can be described using this property."), 
       ValueMap {"1", "2", "3", "4", "5", "6"}, 
       Values {"Other", "Unknown", "None", 
               "External Interface Locked Out", 
               "External Interface Enabled", "Boot Bypass"}, 
       MappingStrings {"MIF.DMTF|Serial Ports|004.9"} ]
   uint16 Security;
};


// ===================================================================
// SerialInterface
// ===================================================================
   [Association, Description (
     "SerialInterface is a ControlledBy relationship indicating "
     "which Devices are accessed through the SerialController and "
     "the characteristics of this access.") ] 
class CIM_SerialInterface : CIM_ControlledBy {
      [Override ("Antecedent"),  Description (
        "The SerialController.") ]
   CIM_SerialController REF Antecedent;  
      [Override ("NegotiatedDataWidth"), Description (
        "For the SerialInterface, NegotiatedDataWidth is the number "
        "of data bits to be transmitted, without stop bits or parity."),
       Units ("Bits") ]
   uint32 NegotiatedDataWidth;
      [Description ("Number of stop bits to be transmitted."),
       Units ("Bits") ]     
   uint16 NumberOfStopBits;
      [Description (
        "Information on the parity setting for transmitted data. "
        "No parity (value=1), even (2) or odd (3) can be specified."),
       Values {"Unknown", "None", "Even", "Odd"} ]
   uint16 ParityInfo;
      [Description (
        "An integer enumeration indicating the flow control "
        "(Xon-Xoff and/or RTS/CTS) for transmitted data."),
       Values {"Unknown", "Not Supported", "None", "XonXoff", 
               "RTS/CTS", "Both XonXoff and RTS/CTS"} ]
   uint16 FlowControlInfo;
};


// ===================================================================
// SCSIController
// ===================================================================
   [Description (
     "Capabilities and management of the SCSIController.") ] 
class CIM_SCSIController : CIM_Controller   {
      [Description (
        "An integer enumeration indicating whether or not the "
        "SCSIController provides redundancy or protection against "
        "device failures."),
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Unprotected", "Protected", 
               "Protected through SCC (SCSI-3 Controller Command)",
               "Protected through SCC-2 (SCSI-3 Controller Command)"},
       MappingStrings {"MIF.DMTF|Storage Controller|001.3"} ]
   uint16 ProtectionManagement;
      [Description (
        "Maximum data width (in bits) supported by the SCSI"
        "Controller."),
       Units ("Bits"), 
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
   uint32 MaxDataWidth;
      [Description (
        "Maximum transfer rate (in Bits per Second) supported by the "
        "SCSIController."),
       Units ("Bits per Second"), 
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
   uint64 MaxTransferRate;
      [Description (
        "Number of SCSIController timeouts that have occurred since "
        "the TimeOfLastReset."), 
       Counter ]  
   uint32 ControllerTimeouts;
      [Description (
        "Signal capabilities that can be supported by the SCSI"
        "Controller. For example, the Controller may support "
        "\"Single Ended\" and \"Differential\". In this case, the "
        "values 3 and 4 would be written to the Signal"
        "Capabilities array."), 
       ValueMap {"1", "2", "3", "4", "5", "6"}, 
       Values {"Other", "Unknown", "Single Ended", "Differential", 
               "Low Voltage Differential", "Optical"}, 
       ModelCorrespondence {"CIM_SCSIInterface.SCSISignal"} ]
   uint16 SignalCapabilities[];
};


// ===================================================================
// SCSIInterface
// ===================================================================
   [Association, Description (
     "SCSIInterface is a ControlledBy relationship indicating "
     "which Devices are accessed through a SCSIController and "
     "the characteristics of this access.") ] 
class CIM_SCSIInterface : CIM_ControlledBy {
      [Override ("Antecedent"),
       Description ("The SCSIController.") ]
   CIM_SCSIController REF Antecedent;  
      [Description (
        "Number of SCSI timeouts that have occurred since last hard "
        "or soft reset related to the controlled Device. The time of "
        "last reset is indicated in the TimeOfDeviceReset property, "
        "inherited from the ControlledBy association."), 
       Counter ]
   uint32 SCSITimeouts;
      [Description (
        "Number of SCSI retries that have occurred since last hard "
        "or soft reset related to the controlled Device. The time of "
        "last reset is indicated in the TimeOfDeviceReset property, "
        "inherited from the ControlledBy association."), 
       Counter,
       MappingStrings {"MIF.DMTF|Mass Storage Statistics|001.18"}  ]
   uint32 SCSIRetries;
      [Description ("The SCSI Initiator ID."), 
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
   uint32 InitiatorId;
      [Description ("The SCSI Target ID."), 
       MappingStrings {"MIF.DMTF|Bus Port|003"} ]
   uint32 TargetId;
      [Description ("The SCSI Target LUN."), 
       MappingStrings {"MIF.DMTF|Storage Devices|001.4"} ]
   uint64 TargetLUN;
      [Description (
        "SCSIReservation indicates the type of SCSI reservation "
        "that currently exists between the source and destination."), 
       Values {"Unknown", "None", "Simple", "Persistent"} ]
   uint16 SCSIReservation;
      [Description (
        "The SCSI signal characteristics being used for this "
        "connection. The value listed here must also be listed in "
        "the SCSIController's SignalCapabilities field."), 
       ValueMap {"1", "2", "3", "4", "5", "6"}, 
       Values {"Other", "Unknown", "Single Ended", "Differential", 
               "Low Voltage Differential", "Optical"}, 
       MappingStrings {"MIF.DMTF|Bus Port|003"}, 
       ModelCorrespondence {"CIM_SCSIController.SignalCapabilities"} ]
   uint16 SCSISignal;
      [Description (
        "Maximum number of Command Descriptor Blocks (CDBs) that "
        "can be supported by the target. This data can not be "
        "obtained under all circumstances.") ]
   uint32 MaxQueueDepth;
      [Description (
        "The maximum number of concurrent Command Descriptor Blocks "
        "(CDBs) that the initiator will send to the target. This "
        "value should never be greater than MaxQueueDepth.") ]
   uint32 QueueDepthLimit;
};


// ===================================================================
// VideoController
// ===================================================================
   [Description (
     "Capabilities and management of the VideoController.") ]
class CIM_VideoController : CIM_Controller   {
// Override is used to define the MappingString qualifier 
      [Override ("Description"), 
       MappingStrings {"MIF.DMTF|Video|004.18"} ]
   string Description;
      [Description (
        "A free-form string describing the video processor/Controller.") ]     
   string VideoProcessor;
      [Description (
        "An integer enumeration indicating the type of video memory."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "13"},
       Values {"Other", "Unknown", "VRAM", "DRAM", "SRAM", "WRAM",
               "EDO RAM", "Burst Synchronous DRAM", 
               "Pipelined Burst SRAM", "CDRAM", "3DRAM", "SDRAM",
               "SGRAM"},
       MappingStrings {"MIF.DMTF|Video|004.6"} ]
   uint16 VideoMemoryType;
      [Description (
        "Number of video pages supported given the current resolutions "
        "and available memory.") ]  
   uint32 NumberOfVideoPages;
      [Description ("Maximum amount of memory supported in bytes."),
       Units ("Bytes") ]
   uint32 MaxMemorySupported;
      [Description (
        "An array of integers indicating the graphics and 3D "
        "capabilities of the VideoController."),
       Values {"Unknown", "Other", "Graphics Accelerator",
               "3D Accelerator"},
     ModelCorrespondence {
      "CIM_VideoController.CapabilityDescriptions"} ]
   uint16 AcceleratorCapabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the video Accelerator features "
        "indicated in the Capabilities array. Note, each entry "
        "of this array is related to the entry in the Capabilities "
        "array that is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {
        "CIM_VideoController.AcceleratorCapabilities"} ]
   string CapabilityDescriptions[];
      [Description ("The number of bits used to display each pixel."), 
       Units ("Bits"),
       MappingStrings {"MIF.DMTF|Video|004.12"} ]
   uint32 CurrentBitsPerPixel;
      [Description ("Current number of horizontal pixels."),
       Units ("Pixels"),
       MappingStrings {"MIF.DMTF|Video|004.11"} ]
   uint32 CurrentHorizontalResolution;
      [Description ("Current number of vertical pixels."),
       Units ("Pixels"),
       MappingStrings {"MIF.DMTF|Video|004.10"} ]
   uint32 CurrentVerticalResolution;
      [Description (
        "Maximum refresh rate of the VideoController in Hertz."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Video|004.5"} ]
   uint32 MaxRefreshRate;
      [Description (
        "Minimum refresh rate of the Video Controller in Hertz."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Video|004.4"} ]
   uint32 MinRefreshRate;
      [Description ("Current refresh rate in Hertz."),
       Units ("Hertz"),
       MappingStrings {"MIF.DMTF|Video|004.15"} ]
   uint32 CurrentRefreshRate;
      [Description (
        "Current scan mode. \"Interlaced\" (value=3) or "
        "\"Non Interlaced\" (4) can be defined using this property."),
       ValueMap {"1", "2", "3", "4"},
       Values {"Other", "Unknown", "Interlaced", "Non Interlaced"},
       MappingStrings {"MIF.DMTF|Video|004.8"} ]
   uint16 CurrentScanMode;
      [Description (
        "If in character mode, number of rows for this Video"
        "Controller. Otherwise, enter 0."),
       MappingStrings {"MIF.DMTF|Video|004.13"} ]
   uint32 CurrentNumberOfRows;
      [Description (
        "If in character mode, number of columns for this "
        "VideoController. Otherwise, enter 0."),
       MappingStrings {"MIF.DMTF|Video|004.14"} ]
   uint32 CurrentNumberOfColumns;
      [Description (
        "Number of colors supported at the current resolutions.") ]
   uint64 CurrentNumberOfColors;
}; 


// ===================================================================
// PCVideoController
// ===================================================================
   [Description (
     "Capabilities and management of a PCVideoController, a subtype "
     "of VideoController.") ] 
class CIM_PCVideoController : CIM_VideoController   {
      [Description (
        "The video architecture.  For example, VGA (value=5) or "
        "PC-98 (160) may be specified."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "160"},
       Values {"Other", "Unknown", "CGA", "EGA", "VGA", "SVGA", "MDA",
               "HGC", "MCGA", "8514A", "XGA", "Linear Frame Buffer",
               "PC-98"},
       MappingStrings {"MIF.DMTF|Video|004.2"} ]
   uint16 VideoArchitecture;
      [Description ("Current video mode."),
       MappingStrings {"MIF.DMTF|Video|004.3"} ]
   uint16 VideoMode;
      [Description (
        "Current number of color planes.  If this value is not "
        "applicable for the current video configuration, enter 0.") ]
   uint16 NumberOfColorPlanes;
};


// ===================================================================
// AGPVideoController
// ===================================================================
   [Description (
     "Capabilities and management of an AGPVideoController.") ]
class CIM_AGPVideoController: CIM_VideoController {
      [Description (
        "Capabilities of the AGP Graphics Controller. For example, "
        "the Device may support multiple monitors, PCI Mastering and "
        "large memory addresses. In this case, the values 3, 4 and 6 "
        "would be written to the Capabilities array."), 
       ArrayType("Indexed"), 
       Values { "Unknown", "Other", "PCI Fast Write", 
                "MultiMonitor Support", "PCI Mastering", 
                "Second Monochrome Adapter Support", 
                "Large Memory Address Support"}, 
       ModelCorrespondence{
        "CIM_AGPVideoController.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free form strings providing more detailed "
        "explanations for any of the entries in the Capabilities "
        "array. Note, each entry of this array is related to the "
        "entry in the Capabilities array that is located at the "
        "same index."), 
       ArrayType("Indexed"), 
       ModelCorrespondence{"CIM_AGPVideoController.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description ("Size of the non-local video memory in KB."), 
       Units ("KiloBytes") ]
   uint32 NonlocalVideoMemorySize;
      [Description (
        "Width of the internal bus in the graphics Controller, in bits."), 
       Units ("Bits") ]
   uint32 LocalBusWidth;
      [Description (
        "An integer enumeration indicating the usage model of the "
        "graphics Controller. Usage model indicates how the Controller "
        "does manipulations of graphics surfaces, textures, etc. in "
        "memory. DMA indicates that the graphics Controller brings "
        "structures from the system memory to its local memory to "
        "perform needed manipulations or renderings. Execute specifies "
        "that the graphics Controller can directly access a specified "
        "region in main memory (called the graphics aperture) using GART "
        "- Graphics Aperture Remapping Table. It then performs "
        "manipulations in that range as if that whole graphics aperture "
        "were part of its local memory. A value of \"Both\" DMA and "
        "Execute models may also be specified."), 
       Values {"Unknown", "Other", "Execute", "DMA", "Both"} ]
   uint16 UsageModel;
      [Description (
        "An integer enumeration indicating the data transfer rate of "
        "the graphics Controller."), 
       Values {"Unknown", "Other", "1X", "2X", "4X"} ]
   uint16 DataTransferRate;
      [Description (
        "An integer enumeration indicating the addressing mode of the "
        "graphics Controller."), 
       Values {"Unknown", "Other", "Sideband", "Pipeline"} ]
   uint16 AddressingMode;
      [Description (
        "The maximum number of AGP Transaction requests that the master "
        "(AGP Graphics Controller) is allowed to enqueue into the target.") ]
   uint32 MaximumAGPCommandQueuePath;
      [Description (
        "The number of AGP Transaction that the core logic (chipset) can "
        "accept into its transaction request queue from the Controller.") ]
   uint32 MaxNumberOfPipelinedAGPTransactions;
      [Description ("Size of the graphics aperture in KB."), 
       Units ("KiloBytes") ]
   uint32 GraphicsApertureSize;
      [Description (
        "A string containing the AGP specification version to which this "
        "graphics Controller conforms.") ]
   string AGPSpecificationVersionConformance;
};


// ===================================================================
// ParallelController
// ===================================================================
   [Description (
     "Capabilities and management of the ParallelController.") ]
class CIM_ParallelController : CIM_Controller {
      [Description (
        "Set to true if the ParallelController supports DMA."),
       MappingStrings {"MIF.DMTF|Parallel Ports|003.7"} ]     
   boolean DMASupport;
      [Description (
        "An integer enumeration indicating the capabilities of the "
        "ParallelController."),
       ArrayType ("Indexed"),
       Values {"Unknown", "Other", "XT/AT Compatible", 
               "PS/2 Compatible", "ECP", "EPP", "PC-98", 
               "PC-98-Hireso", "PC-H98"},
       MappingStrings {"MIF.DMTF|Parallel Ports|003.8"},
       ModelCorrespondence {
        "CIM_ParallelController.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the ParallelController features "
        "indicated in the Capabilities array. Note, each entry of "
        "this array is related to the entry in the Capabilities "
        "array that is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_ParallelController.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "An enumeration indicating the operational security for the "
        "Controller. For example, information that the Device's "
        "external interface is locked out (value=4) or \"Boot "
        "Bypass\" (value=6) can be described using this property."), 
       ValueMap {"1", "2", "3", "4", "5", "6"}, 
       Values {"Other", "Unknown", "None", 
               "External Interface Locked Out", 
               "External Interface Enabled", "Boot Bypass"}, 
       MappingStrings {"MIF.DMTF|Parallel Ports|003.10"} ]
   uint16 Security;
};


// ===================================================================
// SSAController 
// ===================================================================
   [Description (
     "Capabilities and management of an SSAController (Serial "
     "Storage Architecture).") ]
class CIM_SSAController : CIM_Controller {
};



// ===================================================================
// ManagementController
// ===================================================================
   [Description (
     "Capabilities and managment of a ManagementController.  An I2C "
     "microcontroller is a type of ManagementController.") ] 
class CIM_ManagementController : CIM_Controller {
};


// ===================================================================
// IDEController 
// ===================================================================
   [Description (
     "Capabilities and management of an IDEController.") ]
class CIM_IDEController : CIM_Controller {
};


// ===================================================================
// InfraredController 
// ===================================================================
   [Description (
     "Capabilities and management of an InfraredController.") ]
class CIM_InfraredController : CIM_Controller {
};


// ===================================================================
// PCIController
// ===================================================================
   [Description (
     "PCIController is a superclass for the PCIBridge and PCIDevice "
     "classes. These classes model adapters and bridges on a PCI "
     "bus. The properties in PCIController and its subclasses are "
     "defined in the various PCI Specifications published by the "
     "PCI SIG.") ]
class CIM_PCIController : CIM_Controller {
      [Description (
        "Current contents of the register that provides basic "
        "control over the device's ability to respond "
        "to, and/or perform PCI accesses.") ]
   uint16 CommandRegister;
      [Description (
        "An array of integers indicating controller capabilities. "
        "Information such as \"Supports 66MHz\" (value=2) is "
        "specified in this property. The data in the Capabilities array "
        "is gathered from the PCI Status Register and the PCI "
        "Capabilities List as defined in the PCI Specification."),
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Supports 66MHz", 
               "Supports User Definable Features", 
               "Supports Fast Back-to-Back Transactions", 
               "PCI-X Capable", "PCI Power Management Supported", 
               "Message Signaled Interrupts Supported", 
               "Parity Error Recovery Capable", 
               "AGP Supported", "Vital Product Data Supported", 
               "Provides Slot Identification", "Hot Swap Supported"}, 
       ModelCorrespondence {"CIM_PCIController.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the PCIController features indicated "
        "in the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."),
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_PCIController.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "The slowest device select timing for a target device."), 
       Values {"Unknown", "Other", "Fast", "Medium", "Slow", 
               "Reserved"} ]
   uint16 DeviceSelectTiming;
      [Description (
        "Register of 8 bits that identifies the basic function of the "
        "PCI device. This is only the upper byte (offset 0Bh) of the "
        "3 byte ClassCode field. Note that the property's ValueMap "
        "array specifies the decimal representation of this "
        "information."), 
       ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", 
                 "10", "11", "12", "13", "14", "15", "16", "17", 
                 "255"}, 
                 // values 18-254 reserved for expansion by PCI
       Values {"Pre 2.0", "Mass Storage", "Network", "Display", 
               "Multimedia", "Memory", "Bridge", "Simple Communications", 
               "Base Peripheral", "Input", "Docking Station", "Processor", 
               "Serial Bus", "Wireless", "Intelligent I/O", 
               "Satellite Communication", "Encryption/Decryption", 
               "Data Acquisition and Signal Processing", "Other"} ]
   uint8 ClassCode;
      [Description (
        "Specifies the system cache line size in doubleword increments "
        "(e.g., a 486-based system would store the value 04h, "
        "indicating a cache line size of four doublewords."), 
       Units ("DoubleWords") ]
   uint8 CacheLineSize;
      [Description (
        "Defines the minimum amount of time, in PCI clock cycles, that "
        "the bus master can retain ownership of the bus."), 
       Units ("PCI clock cycles") ]
   uint8 LatencyTimer;
      [Description (
        "Defines the PCI interrupt request pin (INTA# to "
        "INTD#) to which a PCI functional device is connected."), 
       Values {"None", "INTA#", "INTB#", "INTC#", "INTD#", "Unknown"} ]
   uint16 InterruptPin;
      [Description (
        "Doubleword Expansion ROM base memory address."), 
       Units ("DoubleWords") ]
   uint32 ExpansionROMBaseAddress;
      [Description (
        "Reports if the PCI device can perform the self test "
        "function. Returns bit 7 of the BIST register as a boolean.") ]
   boolean SelfTestEnabled;
      [Description (
        "Method to invoke PCI device self-test. This method sets bit "
        "6 of the BIST register. The return result is the lower "
        "four bits of the BIST register where 0 indicates success and "
        "non-zero is a device dependent failure. Support for this "
        "method is optional in the PCI Specification.") ]
   uint8 BISTExecution( );
};


// ===================================================================
// PCIDevice
// ===================================================================
   [Description (
     "Capabilities and management of a PCI device controller "
     "on an adapter card.") ]
class CIM_PCIDevice : CIM_PCIController {
      [Description ("Array of doubleword base memory addresses.") ]
   uint32 BaseAddress[6];
      [Description ("Subsystem identifier code.") ]
   uint16 SubsystemID;
      [Description (
        "Subsystem vendor ID. ID information is reported from a "
        "PCIDevice via protocol-specific requests. The correct place "
        "in the CIM Schema for this information is in CIM_Physical"
        "Element (the Manufacturer property) for hardware, and "
        "CIM_Product (the Vendor property) if the information is "
        "related to Product acquisition. This data is also reported "
        "here since it is part of the standard output from the "
        "Device, and as an optimization.") ]
   uint16 SubsystemVendorID;
      [Description (
        "Register indiating how long the master would like to "
        "retain PCI bus ownership whenever it initiates a "
        "transaction. A zero value indicates no requirement."), 
       Units ("250 nanoseconds") ]
   uint8 MinGrantTime;
      [Description (
        "Register specifying how often the device needs access to "
        "the PCI bus in 250ns. A zero value indicates no "
        "requirement."), 
       Units ("250 nanoseconds") ]
   uint8 MaxLatency;
};


// ===================================================================
// PCIBridge
// ===================================================================
   [Description (
     "Capabilities and management of a PCI controller providing "
     "bridge to bridge capability.") ]
class CIM_PCIBridge : CIM_PCIController {
      [Description ("Array of doubleword base memory addresses.") ]
   uint32 BaseAddress[2];
      [Description (
        "The type of bridge. Except for \"Host\" (value=0), the type "
        "of bridge is PCI to <value>. For type \"Host\", the device is "
        "a Host to PCI bridge."), 
       ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "128"}, 
       Values {"Host", "ISA", "EISA", "Micro Channel", "PCI", 
               "PCMCIA", "NuBus", "CardBus", "RACEway", "Other"} ]
   uint16 BridgeType;
      [Description (
        "The timeslice for the secondary interface when the bridge "
        "is acting as an initiator. A zero value indicates no "
        "requirement."), 
       Units ("PCI clock cycles") ]
   uint8 SecondaryLatencyTimer;
      [Description (
        "The number of the highest numbered bus that exists behind "
        "the bridge.") ]
   uint8 SubordinateBusNumber;
      [Description (
        "The number of the PCI bus segment to which the secondary "
        "interface of the bridge is connected.") ]
   uint8 SecondayBusNumber;
      [Description (
        "The number of the PCI bus segment to which the primary "
        "interface of the bridge is connected.") ]
   uint8 PrimaryBusNumber;
      [Description (
        "The contents of the Bridge's SecondaryStatusRegister. "
        "For more information on the contents of this register, refer "
        "to the PCI-to-PCI Bridge Architecture Specification.") ]
   uint16 SecondaryStatusRegister;
      [Description (
        "The slowest device select timing for a target device on the "
        "secondary bus."), 
       Values {"Unknown", "Other", "Fast", "Medium", "Slow", 
               "Reserved"} ]
   uint16 SecondaryBusDeviceSelectTiming;
      [Description (
        "End address of the I/O addresses supported by the bus. The "
        "upper four bits of this property specify the address bits, "
        "AD[15::12], of the I/O address. The remaining 12 bits of "
        "the I/O address are assumed to be all 1's.") ]
   uint8 IOLimit;
      [Description (
        "Base address of I/O addresses supported by the bus. The "
        "upper four bits of this property specify the address bits, "
        "AD[15::12], of the I/O address. The remaining 12 bits of "
        "the I/O address are assumed to be 0.") ]
   uint8 IOBase;
      [Description (
        "End address of the memory supported by the bus. The "
        "upper twelve bits of this property specify the address bits, "
        "AD[31::20], of a 32-bit memory address. The remaining 20 "
        "bits of the address are assumed to be all 1's.") ]
   uint16 MemoryLimit;
      [Description (
        "Base address of the memory supported by the bus. The "
        "upper twelve bits of this property specify the address bits, "
        "AD[31::20], of a 32-bit memory address. The remaining 20 "
        "bits of the address are assumed to be 0.") ]
   uint16 MemoryBase;
      [Description (
        "End address of the memory that can be prefetched by the bus. "
        "The upper twelve bits of this property specify the address "
        "bits, AD[31::20], of a 32-bit memory address. The remaining "
        "20 bits of the address are assumed to be all 1's.") ]
   uint16 PrefetchMemoryLimit;
      [Description (
        "Base address of the memory that can be prefetched by the bus. "
        "The upper twelve bits of this property specify the address "
        "bits, AD[31::20], of a 32-bit memory address. The remaining "
        "20 bits of the address are assumed to be 0.") ]
   uint16 PrefetchMemoryBase;
      [Description (
        "Upper 32 bits of the supported prefetch end address when "
        "64-bit addressing is used. The lower 32 bits are assumed to "
        "be all 1's.") ]
   uint32 PrefetchLimitUpper32;
      [Description (
        "Upper 32 bits of the supported prefetch base address when "
        "64-bit addressing is used. The lower 32 bits are assumed "
        "to be 0.") ]
   uint32 PrefetchBaseUpper32;
      [Description (
        "Upper 16 bits of the supported I/O end address when 32-bit "
        "I/O addressing is used. The lower 16 bits are assumed to be "
        "all 1's.") ]
   uint16 IOLimitUpper16;
      [Description (
        "Upper 16 bits of the supported I/O base address when 32-bit "
        "I/O addressing is used. The lower 16 bits are assumed to be "
        "0.") ]
   uint16 IOBaseUpper16;
};


// ===================================================================
// PCMCIAController 
// ===================================================================
   [Description (
     "Capabilities and management of a PCMCIAController.") ]
class CIM_PCMCIAController : CIM_Controller {
};


// ===================================================================
// ESCONController 
// ===================================================================
   [Description (
     "Capabilities and management of an ESCONController.") ]
class CIM_ESCONController : CIM_Controller {
};


// ===================================================================
// USBController
// ===================================================================
   [Description (
     "Capabilities and managment of a USB Host Controller.") ] 
class CIM_USBController : CIM_Controller {
      [Description (
        "Indicates the latest USB Version supported by the Controller. "
        "The property is expressed as a Binary-Coded Decimal (BCD) "
        "where a decimal point is implied between the 2nd and 3rd "
        "digits. For example, a value of 0x201 indicates that "
        "version 2.01 is supported.") ]
   uint16 USBVersion;
      [Description (
        "The type of interface used between the host system software "
        "and the USBController."), 
       Values {"Unknown", "Other", "UHCI", "OHCI"}, 
       ModelCorrespondence {"CIM_USBController.ControllerVersion"} ]
   uint16 InterfaceType;
      [Description (
        "Indicates the version of the USB Host Controller register "
        "set, specific to the InterfaceType. The property is "
        "expressed as a Binary-Coded Decimal (BCD) value where a "
        "decimal point is implied between the 2nd and 3rd digits. "
        "For example, a value of 0x103 indicates that version "
        "1.03 is supported."), 
       ModelCorrespondence {"CIM_USBController.InterfaceType"} ]
   uint16 ControllerVersion;
};


// ===================================================================
// USBDevice
// ===================================================================
   [Description (
     "The management characterisitics of a USB Device. These ") ]
class CIM_USBDevice: CIM_LogicalDevice {
      [Description (
        "Indicates the latest USB Version supported by the USB Device. "
        "The property is expressed as a Binary-Coded Decimal (BCD) "
        "where a decimal point is implied between the 2nd and 3rd "
        "digits. For example, a value of 0x201 indicates that "
        "version 2.01 is supported.") ]
   uint16 USBVersion;
      [Description ("Indicates the USB class code.") ]
   uint8 ClassCode;
      [Description ("Indicates the USB subclass code.") ]
   uint8 SubclassCode;
      [Description ("Indicates the USB protocol code.") ]
   uint8 ProtocolCode;
      [Description (
        "Number of device configurations that are defined for the "
        "Device.") ]
   uint8 NumberOfConfigs;
      [Description (
        "Indicates the configuration currently selected for the "
        "Device. If this value is zero, the Device is "
        "unconfigured."), 
       ModelCorrespondence {"CIM_USBDevice.CurrentAlternateSettings"} ]
   uint8 CurrentConfigValue;
      [Description (
        "An array of USB 'alternate settings' for each interface "
        "in the currently selected configuration (indicated by the "
        "CurrentConfigValue property). This array has one entry for "
        "each interface in the configuration. If the property, "
        "CurrentConfigValue, is zero (indicating the Device is not "
        "configured), the array is undefined. To understand how "
        "to parse this octet string, refer to the USB Specification."), 
       ModelCorrespondence {"CIM_USBDevice.CurrentConfigValue"} ]
   uint8 CurrentAlternateSettings[];
      [Description (
        "This method returns the USBDevice Descriptor as specified by "
        "the input parameters. Each parameter is briefly described here "
        "with more detail in its Qualifier list. RequestType is an input "
        "parameter that defines whether the request is for standard, "
        "class or vendor-specific information, as well as specifying the "
        "recipient. RequestValue is also an input parameter and defines "
        "the USB Descriptor Type and Index. RequestIndex is an input "
        "parameter which describes the language used to return a string "
        "Descriptor. RequestLength is both an input and output parameter. "
        "It specifies the length of the Descriptor that should be returned "
        "(on input) and what is actually returned in the Buffer parameter "
        "(on output). Buffer is an output parameter, containing the "
        "Descriptor data. The GetDescriptor method returns an integer "
        "value of 0 if the USB Descriptor is successfully returned, "
        "1 if the request is not supported and any other number to "
        "indicate an error.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array qualifier.") ]
   uint32 GetDescriptor(
      [IN, Description ("RequestType is bit-mapped and identifies the "
           "type of Descriptor request and the recipient. The type of "
           "request may be 'standard', 'class' or 'vendor-specific'. "
           "The recipient may be 'device', 'interface', 'endpoint' "
           "or 'other'. Refer to the USB Specification for the "
           "appropriate values for each bit.") ] 
       uint8 RequestType, 
      [IN, Description ("RequestValue contains the Descriptor Type in "
           "the high byte and the Descriptor Index (for example, index "
           "or offset into the Descriptor array) in the low byte. "
           "Refer to the USB Specification for more information.") ] 
       uint16 RequestValue, 
      [IN, Description ("RequestIndex defines the 2 byte Language ID "
           "code used by the USBDevice when returning string Descriptor "
           "data. The parameter is typically 0 for non-string "
           "Descriptors. Refer to the USB Specification for more "
           "information.") ] 
       uint16 RequestIndex, 
      [IN, OUT, Description ("On input, RequestLength is the length "
           "(in octets) of the Descriptor that should be returned. "
           "If this value is less than the actual length of the "
           "Descriptor, only the requested length will be returned. "
           "If it is more than the actual length, the actual length "
           "is returned. On output, this parameter is the length, "
           "in octets, of the Buffer being returned. If the requested "
           "Descriptor does not exist, the contents of this parameter "
           "are undefined.") ] 
       uint16 RequestLength, 
      [OUT, Description ("Buffer returns the requested Descriptor "
            "information. If the Descriptor does not exist, the "
            "contents of the Buffer are undefined.") ] 
       uint8 Buffer[]); 
};


// ===================================================================
// USBHub 
// ===================================================================
   [Description ("USB Hub Device.") ]
class CIM_USBHub : CIM_USBDevice {
      [Description (
        "Indicates whether power to the Hub Ports is individually or "
        "gang-switched. If this value is FALSE, power is switched "
        "individually for each Port. If this value is TRUE, power is "
        "switched to all Ports on the Hub at once.") ]
   boolean GangSwitched;
      [Description (
        "Number of downstream Ports on the Hub, including those "
        "embedded in the Hub's silicon. Individual USBPorts are "
        "associated with the Hub using the USBPortOnHub association.") ]
   uint8 NumberOfPorts;
};


// ===================================================================
// USBPort 
// ===================================================================
   [Description ("A Port on a USBHub.") ]
class CIM_USBPort : CIM_LogicalPort {
      [Override ("Speed"), Description (
        "USB Port Speed in bits per second. This speed is determined "
        "and set by the attached Device. The 'attached Device' is "
        "indicated using the USBConnection association. At this time, "
        "only several Port speeds are valid. These are: 1.5Mbps and "
        "12Mbps. The value 0 can also be specified to indicate that the "
        "current speed is 'unknown' or 1 to indicate that the speed is "
        "'other' than 1.5 or 12Mbps."), 
       ValueMap {"0", "1", "1500000", "12000000"} ]
   uint64 Speed;
      [Override ("StatusInfo"), 
       Description ("Indicates whether the Port is currently enabled."), 
       ValueMap {"2", "3", "4"}, 
       Values {"Unknown", "Enabled", "Disabled"} ]
   uint16 StatusInfo;
      [Override ("Availability"), 
       Description ("Indicates whether the Port is currently Powered."), 
       ValueMap {"2", "3", "7"}, 
       Values {"Unknown", "Running/Full Power", "Power Off"} ]
   uint16 Availability;
      [Description (
        "The USB Port's power capability. The current specification "
        "defines that 1 or 5 loads can be supported (values 2 or 3 would "
        "be specified, respectively)."), 
       Values {"Unknown", "Other", "1 Unit Load", "5 Unit Loads"} ]
   uint16 Power;
      [Description (
        "Indicates whether the Port is currently Suspended.") ]
   boolean Suspended;
      [Description (
        "Indicates whether the Port is disabled due to an "
        "overcurrent event.") ]
   boolean Overcurrent;
};


// ===================================================================
// USBPortOnHub
// ===================================================================
   [Association, 
    Description (
       "USBPortOnHub associates a USBPort or connection point with the "
       "USBHub that includes it.") ]
class CIM_USBPortOnHub : CIM_PortOnDevice {
      [Override ("Antecedent"), 
       Min(1), Max(1), 
       Description ("The Hub that includes the USBPort.") ]
   CIM_USBHub REF Antecedent;
      [Override ("Dependent"), 
       Min(1), Description ("The Port on the USBHub.") ]
   CIM_USBPort REF Dependent;
};


// ===================================================================
// USBControllerHasHub
// ===================================================================
   [Association, Description (
     "USBControllerHasHub defines the Hub(s) that are downstream "
     "of the USBController.") ]
class CIM_USBControllerHasHub : CIM_ControlledBy {
      [Override ("Antecedent"), Min(1), Max(1), 
       Description ("The USBController.") ]
   CIM_USBController REF Antecedent;
      [Override ("Dependent"), Min(1), 
       Description (
        "The USBHub that is associated with the Controller.") ]
   CIM_USBHub REF Dependent;
};


// ===================================================================
// USBConnection 
// ===================================================================
   [Association, Description (
     "USBConnection associates a Device with the USBPort to which it "
     "is connected.") ]
class CIM_USBConnection: CIM_DeviceConnection {
      [Override ("Antecedent"), Max(1), 
       Description ("The USBPort.")  ]
   CIM_USBPort REF Antecedent;
      [Override ("Dependent"), Max(1), 
       Description ("The USBDevice that is connected to the Port.") ]
   CIM_USBDevice REF Dependent;
};


// ===================================================================
//
//    Modems
//
// ===================================================================


// ===================================================================
// Modem 
// ===================================================================
   [Abstract, Description (
     "CIM_Modem is the superclass for grouping the numerous types "
     "of Modems.") ]
class CIM_Modem : CIM_LogicalDevice {
};


// ===================================================================
// ConnectionBasedModem 
// ===================================================================
   [Abstract, Description (
     "CIM_ConnectionBasedModem is the superclass for grouping the "
     "numerous types of connection-based Modems. A CableModem is a "
     "type of connection-based Modem.") ]
class CIM_ConnectionBasedModem : CIM_Modem {
      [Description (
        "VendorID information is reported via Modem-specific requests. "
        "For example, for ADSLModem Devices the VendorID is assigned by "
        "T1E1.4 according to T1.413, Appendix D. The correct place in "
        "the CIM Schema for this information is in PhysicalElement "
        "(the Manufacturer property) for hardware and Product (the "
        "Vendor property) if the information is related to Product "
        "acquisition. This data is also reported here since it is part "
        "of the standard output from the Device, and as an "
        "optimization.") ]
   string VendorID;
};


// ===================================================================
// DSLModem 
// ===================================================================
   [Description (
     "The DSLModem class represents the superclass for Digital "
     "Subscriber Line (DSL) Devices. Properties "
     "will be defined in a future release of the model.")  ]
class CIM_DSLModem : CIM_ConnectionBasedModem {
};


// ===================================================================
// VDSLModem 
// ===================================================================
   [Description (
     "The VDSLmodem class represents Modems of the DSL type = "
     "VDSL, Very high data rate Digital Subscriber Line. Properties "
     "will be defined in a future release of the model.") ]
class CIM_VDSLModem : CIM_DSLModem {
};


// ===================================================================
// HDSLModem 
// ===================================================================
   [Description (
     "The HDSLModem class represents Modems of the DSL type = "
     "HDSL, High data rate Digital Subscribe Line, capable of "
     "delivering T1 or E1 speeds. Properties will be defined in a "
     "future release of the model.") ]
class CIM_HDSLModem : CIM_DSLModem {
};


// ===================================================================
// SDSLModem 
// ===================================================================
   [Description (
     "The SDSLModem class represents Modems of the DSL type = "
     "SDSL, Symmetric Digital Subscriber Line. Properties "
     "will be defined in a future release of the model.") ]
class CIM_SDSLModem : CIM_DSLModem {
};


// ===================================================================
// ADSLModem 
// ===================================================================
   [Description (
     "The ADSLModem class represents Modems of the DSL type = ADSL, "
     "Asymmetric Digital Subscriber Line.") ]
class CIM_ADSLModem : CIM_DSLModem {
      [Description (
        "Noise Margin of this Modem with respect to its received signal, "
        "in tenths of dB."), 
       Units ("Tenths of Decibels") ]
   uint32 NoiseMargin;
      [Gauge, Description (
        "Measured difference in the total power transmitted by the peer "
        "Modem and the total power received by this Modem. This is "
        "measured in tenths of dB."), 
       Units ("Tenths of Decibels") ]
   uint32 LineAttenuation;
      [Description (
        "Status indicates the current state of the connection (line). The "
        "property holds a bitmap describing the possible conditions. "
        "For example, 1) No Defect - There no defects on the line; "
        "2) Loss Of Framing - ATUR failure due to not receiving valid frame; "
        "4) Loss Of Signal - ATUR failure due to not receiving signal; "
        "8) Loss Of Power - ATUR failure due to loss of power; "
        "32) Loss Of Signal Quality - Loss of Signal Quality is declared "
        "when the NoiseMargin falls below the minimum NoiseMargin, or the "
        "bit-error-rate exceeds 10^-7."), 
       ValueMap {"1", "2", "4", "8", "32"}, 
       Values {"No Defect", "Loss Of Framing", "Loss Of Signal", 
               "Loss Of Power", "Loss Of Signal Quality"} ]
   uint32 LineState;
      [Gauge, Description (
        "Measured total output power (in tenths of dB) transmitted by "
        "this Modem."), 
       Units ("Tenths of Decibels") ]
   uint32 TotalOutputPower;
      [Description (
        "Indicates the maximum currently attainable data rate for the Modem. "
        "This value will be equal or greater than the current line rate."), 
       Units ("Bits per Second") ]
   uint32 MaxDataRate;
};


// ===================================================================
// CableModem 
// ===================================================================
   [Description (
     "The CableModem class represents a device for transmission "
     "across a cable infrastructure.") ]
class CIM_CableModem: CIM_ConnectionBasedModem {
};


// ===================================================================
// CallBasedModem 
// ===================================================================
   [Abstract, Description (
     "CIM_CallBasedModem is the superclass for grouping the numerous "
     "types of call-based modems. The POTSModem is a type of call-"
     "based Modem.") ]
class CIM_CallBasedModem : CIM_Modem {
      [Description (
        "Indicates whether online fallback is enabled, to be negotiated "
        "by the Modem.") ]
   boolean FallbackEnabled;
      [Description (
        "An array enumerating all the compression protocols supported "
        "by the Modem."), 
       Values {"Unknown", "Other", "No Compression", "MNP 5", "V.42bis", 
               "MNP 3", "MNP 4", "V.58", "PEP", "HST"}, 
       ModelCorrespondence {
        "CIM_CallBasedModem.OtherCompressionDescription"} ]
   uint16 CompressionSupported[];
      [Description (
        "Description of the compression type when \"Other \" (value=1) "
        "is defined in the CompressionSupported array. If there are "
        "multiple \"Other\" types, then combine their descriptions into "
        "a single string."), 
       ModelCorrespondence {"CIM_CallBasedModem.CompressionSupported"} ]
   string OtherCompressionDescription;
      [Description (
        "Describes the current data compression characteristics of the "
        "Modem. "),
       Values {"Unknown", "Other", "No Compression", "MNP 5", "V.42bis", 
               "MNP 3", "MNP 4", "V.58", "PEP", "HST"},
       ModelCorrespondence {"CIM_CallBasedModem.CompressionSupported", 
        "CIM_CallBasedModem.OtherCompressionInfoDescription"}  ]
   uint16 CompressionInfo;
      [Description (
        "Description of the current compression type when \"Other\" "
        "(value=1) is specified in the CompressionInfo property."), 
       ModelCorrespondence {"CIM_CallBasedModem.CompressionInfo"} ]
   string OtherCompressionInfoDescription;
      [Description (
        "An array enumerating all the modulation protocols supported by "
        "the Modem. The beginning entries in the Values qualifier array "
        "are mapped from the CIM_POTSModem ModulationScheme property."),
       Values {"Unknown", "Other", "Not Supported", "Bell 103", 
               "Bell 212A", "V.22bis", "V.32", "V.32bis", "V.terbo", 
               "V.FC", "V.34", "V.34bis", "V.17 (G3 Fax Call)", "V.21", 
               "V.22", "V.23 Constant Carrier (1200/75)", 
               "V.23 Switched Carrier (Half Duplex)", "V.26bis", 
               "V.26ter", "V.27ter (G3 Fax Call)", 
               "V.29 HD (G3 Fax Call)", "V.34 HD (G3 Fax Call)", 
               "V.90 Issue 1 (Asymmetric)", "V.90 Issue 2 (Symmetric)", 
               "V.58", "X2", "K56FLEX", "V.Fast", "PEP", "HST"}, 
       ModelCorrespondence {
        "CIM_CallBasedModem.OtherModulationDescription"} ]
   uint16 ModulationSupported[];
      [Description (
        "Description of the current modulation type when \"Other\" "
        "(value=1) is specified in the ModulationSupported property. "
        "If there are multiple \"Other\" types, then combine their "
        "descriptions into a single string."), 
       ModelCorrespondence {"CIM_CallBasedModem.ModulationSupported"} ]
   string OtherModulationDescription;
      [Description (
        "Describes the current modulation scheme of the Modem."),
       Values {"Unknown", "Other", "Not Supported", "Bell 103", 
               "Bell 212A", "V.22bis", "V.32", "V.32bis", "V.terbo", 
               "V.FC", "V.34", "V.34bis", "V.17 (G3 Fax Call)", "V.21", 
               "V.22", "V.23 Constant Carrier (1200/75)", 
               "V.23 Switched Carrier (Half Duplex)", "V.26bis", 
               "V.26ter", "V.27ter (G3 Fax Call)", 
               "V.29 HD (G3 Fax Call)", "V.34 HD (G3 Fax Call)", 
               "V.90 Issue 1 (Asymmetric)", "V.90 Issue 2 (Symmetric)", 
               "V.58", "X2", "K56FLEX", "V.Fast", "PEP", "HST"}, 
       ModelCorrespondence {"CIM_CallBasedModem.ModulationSupported",
        "CIM_CallBasedModem.OtherSchemeDescription"}  ]
   uint16 ModulationScheme;
      [Description (
        "Description of the current modulation type when \"Other\" "
        "(value=1) is specified in the ModulationScheme property."), 
       ModelCorrespondence {"CIM_CallBasedModem.ModulationScheme"} ]
   string OtherSchemeDescription;
      [Description (
        "An array enumerating the error control protocols supported "
        "by the Modem. The beginning entries in the Values qualifier "
        "array are mapped from the CIM_POTSModem ErrorControlInfo "
        "property."), 
       Values {"Unknown", "Other", "No Error Correction", "MNP 4", 
               "LAPM", "V.58", "ECP Enhanced Cellular Protocol", 
               "ETC Enhanced Throughput Cellular", "MNP 1", "MNP 2", 
               "MNP 3", "MNP10", "PEP", "HST"}, 
       ModelCorrespondence {
        "CIM_CallBasedModem.OtherErrorControlDescription"} ]
   uint16 ErrorControlSupported[];
      [Description (
        "Description of the error control type when \"Other\" (value="
        "1) is specified in the ErrorControlSupported property. If "
        "there are multiple \"Other\" types, then combine their "
        "descriptions into a single string."), 
       ModelCorrespondence {
        "CIM_CallBasedModem.ErrorControlSupported"} ]
   string OtherErrorControlDescription;
      [Description (
        "Describes the current error correction characteristics of the "
        "Modem."),
       Values {"Unknown", "Other", "No Error Correction", "MNP 4", 
               "LAPM", "V.58", "ECP Enhanced Cellular Protocol", 
               "ETC Enhanced Throughput Cellular", "MNP 1", "MNP 2", 
               "MNP 3", "MNP10", "PEP", "HST"},
       ModelCorrespondence {"CIM_CallBasedModem.ErrorControlSupported", 
        "CIM_CallBasedModem.OtherErrorControlInfoDescription"}  ]
   uint16 ErrorControlInfo;
      [Description (
        "Description of the error control when \"Other\" (value=1) "
        "is defined as the value of the ErrorControlInfo property."), 
       ModelCorrespondence {"CIM_CallBasedModem.ErrorControlInfo"} ]
   string OtherErrorControlInfoDescription;
      [Description ("Time of last reset of the Modem.") ]
   datetime TimeOfLastReset;
      [Description (
        "The rate at which the receiver and transmitter are or were "
        "last cooperating, on a call, before disconnection."), 
       Units ("Bits per Second") ]
   uint32 CallSpeed;
      [Description (
        "Status of the Modem. For example, information regarding "
        "modem negotiation or whether the modem is connected (values "
        "8 and 9, respectively) can be conveyed in this property."), 
       Values {"Unknown", "Other", "Offline", "On Hook", "Dialing", 
               "Waiting for Answer", "Ringing", "Modem Detected",  
               "Negotiating", "Online", "Error"} ]
   uint16 CallStatus;
      [Description (
        "Total number of characters sent by the Device on the last "
        "or current call. That a call is in-progress is indicated by "
        "the CallStatus property."), 
       Counter ]
   uint32 CharsSent;
      [Description (
        "Total number of characters received by the Device on the last "
        "or current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 CharsReceived;
      [Description (
        "Total number of characters lost by the Device on the last or "
        "current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 CharsLost;
      [Description (
        "Total number of blocks sent by the Device on the last or "
        "current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 BlocksSent;
      [Description (
        "Total number of blocks resent by the Device on the last or "
        "current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 BlocksResent;
      [Description (
        "Total number of blocks received by the Device on the last or "
        "current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 BlocksReceived;
      [Description (
        "Total number of block errors seen by the Device on the last "
        "or current call. That a call is in-progress is indicated by the "
        "CallStatus property."), 
       Counter ]
   uint32 BlockErrors;
      [Description (
        "Length of the last or current call. That a call is in-progress "
        "is indicated by the CallStatus property. The 'interval' "
        "format of the datetime data type should be used for the property "
        "value.") ]
   datetime CallLength;
      [Description (
        "Last or current number dialed to which the statistics apply, or "
        "NULL if the call was incoming.") ]
   string NumberDialed;
};


// ===================================================================
// ISDNModem 
// ===================================================================
   [Description (
     "The ISDNModem class, a kind of call-based Modem. Properties "
     "will be defined in a future release of the model.") ]
class CIM_ISDNModem: CIM_CallBasedModem {
};


// ===================================================================
// POTSModem
// ===================================================================
   [Description (
     "The POTSModem class represents a Device that translates "
     "binary data into wave modulations for sound based "
     "transmission.  It connects to the POTS (Plain Old Telephone "
     "System) network.") ] 
class CIM_POTSModem : CIM_CallBasedModem {
      [Description (
        "Capabilities of the POTSModem. For example, the Device "
        "may support distinctive ring, caller ID, fax, voice, etc."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Distinctive Ring", "Caller ID", 
               "Voice", "Fax Class 1", "Fax Class 2", "WakeOnRing", 
               "Fax Group 3", "GSM Support", "AMPS Support", 
               "OOB Alerting", "Worldwide Country Support"}, 
       ModelCorrespondence {"CIM_POTSModem.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the POTSModem features indicated "
        "in the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_POTSModem.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Specifies which capabilities are enabled from the list of "
        "ones supported, defined in the Capabilities array."), 
       Values {"Unknown", "Other", "Distinctive Ring", "Caller ID", 
               "Voice", "Fax Class 1", "Fax Class 2", "WakeOnRing", 
               "Fax Group 3", "GSM Support", "AMPS Support", 
               "OOB Alerting", "Worldwide Country Support"}, 
       ModelCorrespondence {"CIM_POTSModem.Capabilities"} ]
   uint16 EnabledCapabilities[];
      [Description (
        "Defines the maximum settable communication speed "
        "to the COM Port for an external modem.  Enter 0 if "
        "not applicable."),
       Units ("Bits per Second") ]
   uint32 MaxBaudRateToSerialPort;
      [Description (
        "Defines the maximum settable communication speed "
        "for accessing the phone system."), 
       Units ("Bits per Second") ]
   uint32 MaxBaudRateToPhone;
      [Description (
        "Boolean indicating that synchronous, as well as "
        "asynchronous, communication is supported.") ]
   boolean SupportsSynchronousConnect;
      [Description (
        "DialType is an integer indicating whether tone (value=1) or "
        "pulse dialing (value=2) is used. \"Unknown\" (0) can also be "
        "defined."),
       Values {"Unknown", "Tone", "Pulse"} ]
   uint16 DialType;
      [Description (
        "InactivityTimeout defines the time limit (in seconds) "
        "for automatic disconnection of the phone line, if no data "
        "is exchanged.  A value of 0 indicates that this "
        "feature is present but not enabled."),
       Units ("Seconds") ]
   uint32 InactivityTimeout;
      [Description (
        "Describes the volume level of the audible tones from the "
        "Modem. For example, high, medium or low volume can be "
        "reported (values 3, 4 or 5, respectively)."),
       Values {"Unknown", "Other", "Not Supported", "High", 
               "Medium", "Low", "Off", "Auto"} ]
   uint16 SpeakerVolumeInfo;
      [MaxLen (64), Description (
        "CountriesSupported is an array of strings defining the "
        "countries in which the POTSModem operates.") ]
   string CountriesSupported[];
      [MaxLen (64), Description (
        "CountrySelected is a string value defining the country "
        "for which the Modem is currently programmed. When multiple "
        "countries are supported, this property defines which one "
        "is currently selected for use.") ] 
   string CountrySelected;
      [Description (
        "Number of rings before the Modem answers an incoming call.") ]  
   uint8 RingsBeforeAnswer;
      [Description (
        "MaxNumberOfPasswords specifies the number of passwords "
        "definable in the Modem itself.  If this feature is not "
        "supported, enter 0.") ] 
   uint16 MaxNumberOfPasswords;
      [MaxLen (24), Description (
        "CurrentPasswords is an array containing the currently defined "
        "passwords for the Modem.  This array may be left blank for "
        "security reasons.") ] 
   string CurrentPasswords[];
      [Description (
        "Indication of whether the Modem supports call-back.") ]
   boolean SupportsCallback;
      [Description (
        "AnswerMode defines the current auto-answer/call-back "
        "setting for the Modem."),
       Values {"Unknown", "Other", "Disabled", "Manual Answer", 
               "Auto Answer", "Auto Answer with Call-Back"} ]
   uint16 AnswerMode;
      [Description (
        "The current equalization setting for the Modem."), 
       Values {"Unknown", "Other", "Long", "Short"} ]
   uint16 Equalization;
      [Description ("List of black-listed numbers for the Modem.") ]
   string BlackListedNumbers[];
};


// ===================================================================
// Unimodem
// ===================================================================
   [Description (
     "Unimodem is a POTSModem that supports the Unimodem 1.0 "
     "Specification.") ]
class CIM_Unimodem : CIM_POTSModem {
      [Description ("Current call setup result code."), 
       Values {"No Previous Call", "No Dial Tone Detected", 
               "Reorder Signal Detected, Network Busy", 
               "Busy Signal Detected", "No Recognized Signal Detected", 
               "Voice Detected", "Text Telephone Detected", 
               "Data Answering Signal Detected", 
               "Data Calling Signal Detected", 
               "Fax Answering Signal Detected", 
               "Fax Calling Signal Detected", "V.8bis Signal Detected"} ]
   uint16 CallSetupResultCode;
      [Description ("Current multi-media mode of the Unimodem."), 
       Values {"Data Only", "Fax Only", "Voice Only", "Voice View", 
               "ASVD V.61", "ASVD V.34Q", "DSVD Multi-Tech", "DSVD 1.2", 
               "DSVD V.70", "Video Telephony H.324", "Other V.80 Call"} ]
   uint16 MultiMediaMode;
      [Description (
        "Current DTE-DCE interface mode of the Unimodem, such as "
        "asynchronous, v.80 transparent or framed synchronous modes."), 
       Values {"Async Data", "V.80 Transparent Synchronous Mode", 
               "V.80 Framed Synchronous Mode"} ]
   uint16 DTEDCEInterfaceMode;
      [Description ("The active transmit modulation scheme."), 
       Values {"V.17 (G3 Fax Call)", "V.21", "V.22", "V.22bis", 
               "V.23 Constant Carrier (1200/75)", 
               "V.23 Switched Carrier (Half Duplex)", "V.26bis", 
               "V.26ter", "V.27ter (G3 Fax Call)", 
               "V.29 HD (G3 Fax Call)", "V.32", "V.32bis", "V.34", 
               "V.34 HD (G3 Fax Call)", "V.90 Issue 1 (Asymmetric)", 
               "V.90 Issue 2 (Symmetric)", "Reserved (V.58)", "X2", 
               "K56FLEX", "V.FC", "V.32terbo", "Bell 212A", 
               "Bell 103", "Reserved for Mfgs"} ]
   uint16 TransmitCarrierNegotiation;
      [Description ("The active receive modulation scheme."), 
       Values {"V.17 (G3 Fax Call)", "V.21", "V.22", "V.22bis", 
               "V.23 Constant Carrier (1200/75)", 
               "V.23 Switched Carrier (Half Duplex)", "V.26bis", 
               "V.26ter", "V.27ter (G3 Fax Call)", 
               "V.29 HD (G3 Fax Call)", "V.32", "V.32bis", "V.34", 
               "V.34 HD (G3 Fax Call)", "V.90 Issue 1 (Asymmetric)", 
               "V.90 Issue 2 (Symmetric)", "Reserved (V.58)", "X2", 
               "K56FLEX", "V.FC", "V.32terbo", "Bell 212A", 
               "Bell 103", "Reserved for Mfgs"}  ]
   uint16 ReceiveCarrierNegotiation;
      [Description (
        "Initial transmit carrier data rate for the current or "
        "last call, in bits per second."), 
       Units ("Bits per Second") ]
   uint32 InitialTransmitCarrierDataRate;
      [Description (
        "Initial receive carrier data rate for the current or last "
        "call, in bits per second."), 
       Units ("Bits per Second") ]
   uint32 InitialReceiveCarrierDataRate;
      [Description (
        "The number of carrier retrains requested during the current "
        "or last call."), 
       Counter ]
   uint8 CarrierRetrainsRequested;
      [Description (
        "The number of carrier retrains granted during the current "
        "or last call."), 
       Counter ]
   uint8 CarrierRetrainsGranted;
      [Description (
        "Final transmit carrier data rate of the current or last "
        "call, in bits per second."), 
       Units ("Bits per Second") ]
   uint32 FinalTransmitCarrierDataRate;
      [Description (
        "Final receive carrier data rate of the current or last "
        "call, in bits per second."), 
       Units ("Bits per Second") ]
   uint32 FinalReceiveCarrierDataRate;
      [Description ("Cause of last call termination."), 
       Values {"Cause Unidentified", "No Previous Call", 
               "Call Is Still in Progress", "Call Waiting Signal Detected", 
               "Delayed", "NMS Initiated Dial Call", 
               "NMS Initiated Leased Line Restoral", "NMS Initiated Redial", 
               "NMS Initiated Dial Disconnect", "Power Loss", 
               "Equipment Failure", "Front Panel Disconnect Requested", 
               "Front Panel Leased Line Restoral", 
               "Automatic Leased Line Restoral", "Inactivity Timer Expired", 
               "cct116 Restoral Request", "cct108 Is Off Inhibits Dial", 
               "cct108 Turned Off", "No Number Provided", "Blacklisted Number", 
               "Call Attempts Limit Exceeded", "Extension Phone Off Hook", 
               "Call Setup Fail Timer Expired", "Incoming Call Detected", 
               "Loop Current Interrupted", "No Dial Tone", "Voice Detected", 
               "Reorder Tone", "Sit Tone", "Engaged Tone", 
               "Long Space Disconnect", "Carrier Lost", "Training Failed", 
               "No Modulation in Common", "Retrain Failed", 
               "Retrain Attempt Count Exceeded", "GSTN Cleardown Received", 
               "Fax Detected", "In Test Mode", 
               "Intrusive Self Test Initiated", "Any Key Abort", 
               "DTE Hangup Command", "DTE Reset Command", "Frame Reject", 
               "No Error Control Established", "Protocol Violation", 
               "n400 Exceeded", "Negotiation Failed", 
               "Disconnect Frame Received", "Sabme Frame Received", 
               "Loss Of Synchronization"} ]
   uint16 TerminationCause;
      [Description (
        "Diagnostic Command Specification, Unimodem revision number.") ]
   string UnimodemRevision;
      [Gauge, Description (
        "Estimated noise level for the last or current call in "
        "-dBm. Values are in the range of 0-100."), 
       Units ("-dBm") ]
   uint32 EstimatedNoiseLevel;
      [Description (
        "Normalized mean squared error for the last or current call.") ]
   uint32 NormalizedMeanSquaredError;
      [Description (
        "Temporary carrier loss event count for the last or current "
        "call."), 
       Counter ]
   uint8 TemporaryCarrierLossEventCount;
      [Description (
        "Carrier Rate re-negotiation event count for the last or "
        "current call."), 
       Counter ]
   uint8 CarrierRenegotiationEventCount;
      [Description (
        "Error Control frame size in bytes for the last or current call."), 
       Units ("Bytes") ]
   uint16 ErrorControlFrameSize;
      [Description (
        "Error control link timeouts in transmission for the last or "
        "current call."), 
       Counter ]
   uint8 ErrorControlLinkTimeouts;
      [Description (
        "Error control link NAKs received for the last or current call."), 
       Counter ]
   uint8 ErrorControlLinkNAKs;
      [Description (
        "The flow control mechanism used in transmitting data."), 
       Values {"Unknown", "Off", "DC1/DC3", "V.24 ckt 106/133"} ]
   uint16 TransmitFlowControl;
      [Description (
        "The flow control mechanism used in receiving data."), 
       Values {"Unknown", "Off", "DC1/DC3", "V.24 ckt 106/133"} ]
   uint16 ReceiveFlowControl;
      [Description (
        "Number of transmit chars sent from the DTE for the last "
        "or current call. A continuous connection may exceed this value, "
        "given enough time. Typically these counters are implemented "
        "as 32 bit counters, but additional bits may be provided and "
        "are accounted for in this property. If these counters hit "
        "maximum value, the DCE manufacturer may roll over to 0."), 
       Counter ]
   uint64 TransmitCharsSentFromDTE;
      [Description (
        "Number of receive chars sent to the DTE for the last or "
        "current call. A continuous connection may exceed this value, "
        "given enough time. Typically these counters are implemented "
        "as 32 bit counters, but additional bits may be provided and "
        "are accounted for in this property. If these counters hit "
        "maximum value, the DCE manufacturer may roll over to 0."), 
       Counter ]
   uint64 ReceiveCharsSentToDTE;
      [Description (
        "Number of transmit characters lost for the last or current "
        "call. A DCE may limit this counter to 16 bits, but additional "
        "bits may be provided and are accounted for in this property."), 
       Counter ]
   uint64 TransmitCharsLost;
      [Description (
        "Number of receive characters lost for the last or current "
        "call. A DCE may limit this counter to 16 bits, but additional "
        "bits may be provided and are accounted for in this property."), 
       Counter ]
   uint64 ReceiveCharsLost;
      [Description (
        "Number of I-Frames transmitted for the last or current call. "
        "A continuous connection may exceed this value, given enough "
        "time. Typically these counters are implemented as 32 bit "
        "counters, but additional bits may be provided and are accounted "
        "for in this property. If these counters hit maximum value, the "
        "DCE manufacturer may roll over to 0."), 
       Counter ]
   uint64 TransmitIFrameCount;
      [Description (
        "Number of I-Frames received for the last or current call. "
        "A continuous connection may exceed this value, given enough "
        "time. Typically these counters are implemented as 32 bit "
        "counters, but additional bits may be provided and are "
        "accounted for in this property. If these counters hit maximum "
        "value, the DCE manufacturer may roll over to 0."), 
       Counter ]
   uint64 ReceiveIFrameCount;
      [Description (
        "Number of I-Frame errors detected for the last or current "
        "call, if error control protocol is running. A DCE may limit "
        "this counter to 16 bits, but additional bits may be provided "
        "and are accounted for in this property."), 
       Counter ]
   uint64 TransmitIFrameErrorCount;
      [Description (
        "Number of I-Frame errors detected for the last or current "
        "call, if error control protocol is running. A DCE may limit "
        "this counter to 16 bits, but additional bits may be provided "
        "and are accounted for in this property."), 
       Counter ]
   uint64 ReceivedIFrameErrorCount;
      [Description (
        "Number of Call waiting events detected for the last or "
        "current call."), 
       Counter ]
   uint8 CallWaitingEventCount;
};


// ===================================================================
//
//    Storage
//
// ===================================================================


// ===================================================================
// MediaAccessDevice
// ===================================================================
   [Description (
     "A MediaAccessDevice represents the ability to access one or "
     "more media and use this media to store and retrieve data.") ] 
class CIM_MediaAccessDevice : CIM_LogicalDevice {
      [Description (
        "Capabilities of the MediaAccessDevice. For example, the " 
        "Device may support \"Random Access\", removeable media and "
        "\"Automatic Cleaning\". In this case, the values 3, 7 and 9 "
        "would be written to the array.\n"
        "Several of the enumerated values require some explanation: "
        "1) Value 11, Supports Dual Sided Media, distinguishes a "
        "Device that can access both sides of dual sided Media, from "
        "a Device that reads only a single side and requires the "
        "Media to be flipped; and, 2) Value 12, Predismount Eject "
        "Not Required, indicates that Media does not have to be "
        "explicitly ejected from the Device before being accessed "
        "by a PickerElement."), 
       ArrayType ("Indexed"),
       Values {"Unknown", "Other", "Sequential Access", 
               "Random Access", "Supports Writing", "Encryption",
               "Compression", "Supports Removeable Media",
               "Manual Cleaning", "Automatic Cleaning", 
               "SMART Notification", "Supports Dual Sided Media", 
               "Predismount Eject Not Required" }, 
       MappingStrings {"MIF.DMTF|Storage Devices|001.9", 
        "MIF.DMTF|Storage Devices|001.11", 
        "MIF.DMTF|Storage Devices|001.12",
        "MIF.DMTF|Disks|003.7", "MIF.DMTF|Host Disk|001.2",  
        "MIF.DMTF|Host Disk|001.4"}, 
       ModelCorrespondence {
        "CIM_MediaAccessDevice.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the AccessDevice features indicated "
        "in the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_MediaAccessDevice.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "ErrorMethodology is a free-form string describing "
        "the type(s) of error detection and correction supported "
        "by this Device.") ]
   string ErrorMethodology;
      [Description (      
        "A free form string indicating the algorithm or tool used by "
        "the device to support compression. "
        "If it is not possible or not desired to describe the "
        "compression scheme (perhaps because it is not known), "
        "recommend using the following words: \"Unknown\" to "
        "represent that it is not known whether the device supports "
        "compression capabilities or not, \"Compressed\" to represent "
        "that the device supports compression capabilities but either "
        "its compression scheme is not known or not disclosed, and "
        "\"Not Compressed\" to represent that the devices does not "
        "support compression capabilities.")     ]
   string CompressionMethod;
      [Description (
        "When the MediaAccessDevice supports multiple individual "
        "Media, this property defines the maximum number which can "
        "be supported or inserted.") ]
   uint32 NumberOfMediaSupported;
      [Description (
        "Maximum size, in KBytes, of media supported by this Device. "
        "KBytes is interpreted as the number of bytes multiplied by "
        "1000 (NOT the number of bytes multiplied by 1024)."),
       MappingStrings {"MIF.DMTF|Sequential Access Devices|001.2", 
             "MIF.DMTF|Host Disk|001.5"} ]
   uint64 MaxMediaSize;
      [Description ("Default block size, in bytes, for this Device."),
       Units ("Bytes") ]
   uint64 DefaultBlockSize;
      [Description (
        "Maximum block size, in bytes, for media accessed by this "
        "Device."),
       Units ("Bytes") ]
   uint64 MaxBlockSize;
      [Description (
        "Minimum block size, in bytes, for media accessed by this "
        "Device."),
       Units ("Bytes") ]
   uint64 MinBlockSize;
    [Description (
        "Boolean indicating that the MediaAccessDevice needs cleaning. " 
        "Whether manual or automatic cleaning is possible is indicated "
        "in the Capabilities array property. ") ]
   boolean NeedsCleaning;
      [Description (
        "True indicates that the media is locked in the Device "
        "and can not be ejected. For non-removeable Devices, this "
        "value should be true.") ]
   boolean MediaIsLocked;
      [Description (
        "An enumeration indicating the operational security defined "
        "for the MediaAccessDevice. For example, information that "
        "the Device is \"Read Only\" (value=4) or \"Boot Bypass\" "
        "(value=6) can be described using this property."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7"}, 
       Values {"Other", "Unknown", "None", "Read Only", "Locked Out", 
             "Boot Bypass", "Boot Bypass and Read Only"}, 
       MappingStrings {"MIF.DMTF|Disks|003.22"} ]
   uint16 Security;
      [Description (
        "The date and time on which the Device was last cleaned.") ]
   datetime LastCleaned;
      [Description (
        "Time in milliseconds to move from the first location on "
        "the Media to the location that is furthest with respect to "
        "time. For a DiskDrive, this represents full seek + full "
        "rotational delay. For TapeDrives, this represents a search "
        "from the beginning of the tape to the most physically "
        "distant point. (The end of a tape may be at its most "
        "physically distant point, but this is not necessarily "
        "true.)"), 
       Units ("MilliSeconds") ]
   uint64 MaxAccessTime;
      [Description (
        "The sustained data transfer rate in KB/sec that the "
        "Device can read from and write to a Media. This is a "
        "sustained, raw data rate. Maximum rates or rates "
        "assuming compression should not be reported in this "
        "property."), 
       Units ("KiloBytes per Second") ]
   uint32 UncompressedDataRate;
      [Description (
        "Time in milliseconds from 'load' to being able to read "
        "or write a Media. For example, for DiskDrives, this is "
        "the interval between a disk not spinning to the disk "
        "reporting that it is ready for read/write (ie, the disk "
        "spinning at nominal speeds). For TapeDrives, this is "
        "the time from a Media being injected to reporting that "
        "it is ready for an application. This is usually at the "
        "tape's BOT area."), 
       Units ("MilliSeconds") ]
   uint64 LoadTime;
      [Description (
        "Time in milliseconds from being able to read or write a "
        "Media to its 'unload'. For example, for DiskDrives, "
        "this is the interval between a disk spinning at nominal "
        "speeds and a disk not spinning. For TapeDrives, this is "
        "the time for a Media to go from its BOT to being fully "
        "ejected and accessible to a PickerElement or human "
        "operator."), 
       Units ("MilliSeconds") ]
   uint64 UnloadTime;
      [Description (
        "For a MediaAccessDevice that supports removable Media, "
        "the number of times that Media have been mounted for "
        "data transfer or to clean the Device. For Devices "
        "accessing nonremovable Media, such as hard disks, "
        "this property is not applicable and should be set to 0."),
       Counter ]
   uint64 MountCount;
      [Description (
        "For a MediaAccessDevice that supports removable Media, "
        "the most recent date and time that Media was mounted "
        "on the Device. For Devices accessing nonremovable Media, "
        "such as hard disks, this property has no meaning and is "
        "not applicable.") ]
   datetime TimeOfLastMount;
      [Description (
        "For a MediaAccessDevice that supports removable Media, "
        "the total time (in seconds) that Media have been mounted "
        "for data transfer or to clean the Device. For Devices "
        "accessing nonremovable Media, such as hard disks, "
        "this property is not applicable and should be set to 0.") ]
   uint64 TotalMountTime;
      [Description (
        "Defines 'Units' relative to its use in the property, "
        "MaxUnitsBeforeCleaning. This describes the criteria used "
        "to determine when the MediaAccessDevice should be cleaned."),
       ModelCorrespondence {
        "CIM_MediaAccessDevice.MaxUnitsBeforeCleaning",
        "CIM_MediaAccessDevice.UnitsUsed"} ]
   string UnitsDescription;
      [Description (
        "An unsigned integer indicating the maximum 'units' "
        "that can be used, with respect to the AccessDevice, "
        "before the Device should be cleaned. The property, "
        "UnitsDescription, defines how 'units' should be "
        "interpreted."),
       ModelCorrespondence {
        "CIM_MediaAccessDevice.UnitsDescription"} ]
   uint64 MaxUnitsBeforeCleaning;
      [Description (
        "An unsigned integer indicating the currently used " 
        "'units' of the AccessDevice, helpful to describe "
        "when the Device may require cleaning. The property, "
        "UnitsDescription, defines how 'units' should be "
        "interpreted."),
       Gauge,
       ModelCorrespondence {
        "CIM_MediaAccessDevice.UnitsDescription",
        "CIM_MediaAccessDevice.MaxUnitsBeforeCleaning"}]
   uint64 UnitsUsed;
      [Description (
        "Method to lock and unlock the media in a removeable Access"
        "Device. The method takes one parameter as input - a boolean "
        "indicating whether to lock or unlock. TRUE indicates that "
        "the media should be locked in the Device, FALSE indicates "
        "that the media should be unlocked. The method returns 0 if "
        "successful, 1 if not supported, and any other value if an "
        "error occurred. The set of possible return codes should be "
        "specified in a ValueMap qualifier on the method. The strings "
        "to which the ValueMap contents are 'translated' should be "
        "specified as a Values array qualifier on the method.") ]
   uint32 LockMedia (
      [IN] boolean Lock);
};


// ===================================================================
// DiskDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a DiskDrive, a subtype of "
     "MediaAccessDevice.") ] 
class CIM_DiskDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// DisketteDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a DisketteDrive, a subtype of "
     "MediaAccessDevice.") ] 
class CIM_DisketteDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// CDROMDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a CDROMDrive, a subtype of "
     "MediaAccessDevice.") ] 
class CIM_CDROMDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// DVDDrive 
// ===================================================================
   [Description (
     "Capabilities and management of a DVDDrive, a subtype of "
     "MediaAccessDevice.") ]
class CIM_DVDDrive : CIM_MediaAccessDevice {
      [Description (
        "The CD and DVD formats that are supported by this Device. "
        "For example, the Drive may support \"CD-ROM\" and "
        "\"DVD-RAM\". In this case, the values 16 and 24 would be "
        "written to the array. This property's values align with "
        "those defined in PhysicalMedia.MediaType."), 
       ValueMap {"0", "1", "16", "17", "18", "19", "22", "23", "24", 
                 "25", "26", "27", "33", "34", "35", "36", "37", "38", 
                 "39", "40", "41", "42"}, 
       Values {"Unknown", "Other", "CD-ROM", "CD-ROM/XA", 
               "CD-I", "CD Recordable", "DVD", "DVD-RW+", 
               "DVD-RAM", "DVD-ROM", "DVD-Video", "Divx", "CD-RW", 
               "CD-DA", "CD+", "DVD Recordable", "DVD-RW", 
               "DVD-Audio", "DVD-5", "DVD-9", "DVD-10", "DVD-18"},
       ModelCorrespondence {"CIM_PhysicalMedia.MediaType"} ]
   uint16 FormatsSupported[];
};


// ===================================================================
// WORMDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a WORMDrive, a subtype of "
     "MediaAccessDevice.") ] 
class CIM_WORMDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// MagnetoOpticalDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a MagnetoOpticalDrive, a "
     "subtype of MediaAccessDevice.") ] 
class CIM_MagnetoOpticalDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// TapeDrive
// ===================================================================
   [Description (
     "Capabilities and managment of a TapeDrive, a subtype of "
     "MediaAccessDevice.") ] 
class CIM_TapeDrive : CIM_MediaAccessDevice {
      [Description (
        "EOTWarningZoneSize indicates the size, in bytes, of the "
        "area designated as 'end of tape'. Access in this area "
        "generates an 'end of tape' warning."),
       Units ("Bytes") ]
   uint32 EOTWarningZoneSize;
      [Description ("Maximum partition count for the TapeDrive.") ]
   uint32 MaxPartitionCount;
      [Description (
        "Padding indicates the number of bytes inserted between "
        "blocks on a tape Media."),
       Units ("Bytes") ]
   uint32 Padding;
      [Description (
        "Time in milliseconds to move from the most physically distant "
        "point on the tape to the beginning."), 
       Units ("MilliSeconds") ]
   uint64 MaxRewindTime;
};


// ===================================================================
// StorageExtent
// ===================================================================
   [Description (
     "StorageExtent describes the capabilities and management of "
     "the various media that exist to store data and allow data "
     "retrieval. This superclass could be used to represent the "
     "various components of RAID (Hardware or Software) or as a "
     "raw logical extent on top of physical media.") ] 
class CIM_StorageExtent : CIM_LogicalDevice {
      [Description ("Type of data organization used."), 
       Values {"Other", "Unknown", "Fixed Block", "Variable Block", 
               "Count Key Data"} ]
   uint16 DataOrganization;
      [Description (
        "A free form string describing the media and/or its use."),
       MappingStrings {
        "MIB.IETF|HOST-RESOURCES-MIB.hrStorageDescr"} ]
   string Purpose;
      [Description (
        "Access describes whether the media is readable (value=1), "
        "writeable (value=2), or both (value=3). \"Unknown\" (0) "
        "and \"Write Once\" (4) can also be defined."),
       Values {"Unknown", "Readable", "Writeable", 
               "Read/Write Supported", "Write Once"} ]
   uint16 Access;
      [Description (
        "ErrorMethodology is a free-form string describing "
        "the type of error detection and correction supported "
        "by this StorageExtent.") ]
   string ErrorMethodology;
      [Description (
        "Size in bytes of the blocks which form this StorageExtent. "
        "If variable block size, then the maximum block size in bytes "
        "should be specified. If the block size is unknown or if a "
        "block concept is not valid (for example, for Aggregate Extents, "
        "Memory or LogicalDisks), enter a 1."), 
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|Host Storage|001.4", 
        "MIB.IETF|HOST-RESOURCES-MIB.hrStorageAllocationUnits,"
        "MIF.DMTF|Storage Devices|001.5"}  ]
   uint64 BlockSize;
      [Description (
        "Total number of logically contiguous blocks, of size Block"
        "Size, which form this Extent. The total size of the Extent "
        "can be calculated by multiplying BlockSize by NumberOfBlocks. "
        "If the BlockSize is 1, this property is the total size of the "
        "Extent."),
       MappingStrings {"MIF.DMTF|Host Storage|001.5", 
        "MIB.IETF|HOST-RESOURCES-MIB.hrStorageSize"} ]
   uint64 NumberOfBlocks;
      [Description ( 
        "The maximum number of blocks, of size BlockSize, which are "
        "available for consumption when layering StorageExtents "
        "using the BasedOn association. This property only has meaning "
        "when this StorageExtent is an Antecedent reference in a "
        "BasedOn relationship. For example, a StorageExtent could be "
        "composed of 120 blocks. However, the Extent itself may use 20 "
        "blocks for redundancy data. If another StorageExtent is BasedOn "
        "this Extent, only 100 blocks would be available to it. This "
        "information ('100 blocks is available for consumption') is "
        "indicated in the ConsumableBlocks property.")  ]
   uint64 ConsumableBlocks;
      [Description (
        "True indicates that the underlying StorageExtent(s) "
        "participate in a StorageRedundancyGroup.") ]
   boolean IsBasedOnUnderlyingRedundancy;
      [Description (
        "Boolean set to TRUE if the Storage is sequentially accessed "
        "by a MediaAccessDevice. A TapePartition is an example of a "
        "sequentially accessed StorageExtent. StorageVolumes, Disk"
        "Partitions and LogicalDisks represent randomly accessed "
        "Extents.") ]
   boolean SequentialAccess;
};


// ===================================================================
// ResidesOnExtent
// ===================================================================
   [Association, Description (
     "An association between a FileSystem and the StorageExtent "
     "where it is located. Typically, a FileSystem ResidesOn "
     "a LogicalDisk.") ] 
class CIM_ResidesOnExtent : CIM_Dependency {
      [Override ("Antecedent"), Description ("The StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"), Description (
      "The FileSystem that is located on the StorageExtent.") ]
   CIM_FileSystem REF Dependent;
};


// ===================================================================
// BasedOn
// ===================================================================
   [Association, Description (
     "BasedOn is an association describing how StorageExtents can "
     "be assembled from lower level Extents. For example, "
     "ProtectedSpaceExtents are parts of PhysicalExtents, while "
     "VolumeSets are assembled from one or more Physical or "
     "ProtectedSpaceExtents. As another example, CacheMemory "
     "can be defined independently and realized in a PhysicalElement "
     "or can be 'based on' Volatile or NonVolatileStorageExtents.") ] 
class CIM_BasedOn : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "The lower level StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The higher level StorageExtent.") ]
   CIM_StorageExtent REF Dependent;
      [Description (
        "StartingAddress indicates where in lower level storage, "
        "the higher level Extent begins.") ] 
   uint64 StartingAddress;
      [Description (
        "EndingAddress indicates where in lower level storage, "
        "the higher level Extent ends. This property is useful when "
        "mapping non-contiguous Extents into a higher level grouping.") ] 
   uint64 EndingAddress;
      [Description (
        "If there is an order to the BasedOn associations that "
        "describe how a higher level StorageExtent is assembled, the "
        "OrderIndex property indicates this. When an order exists, "
        "the instances of BasedOn with the same Dependent value "
        "(i.e., the same higher level Extent) should place unique "
        "values in the OrderIndex property. The lowest value implies "
        "the first member of the collection of lower level Extents, "
        "and increasing values imply successive members of the "
        "collection. If there is no ordered relationship, a value "
        "of zero should be specified. An example of the use of this "
        "property is to define a RAID-0 striped array of 3 disks. "
        "The resultant RAID array is a StorageExtent that is "
        "dependent on (BasedOn) the StorageExtents that describe "
        "each of the 3 disks. The OrderIndex of each BasedOn "
        "association from the disk Extents to the RAID array could "
        "be specified as 1, 2 and 3 to indicate the order in which "
        "the disk Extents are used to access the RAID data.") ]
   uint16 OrderIndex;
};


// ===================================================================
// MediaPresent
// ===================================================================
   [Association, Description (
     "Where a StorageExtent must be accessed through a MediaAccess"
     "Device, this relationship is described by the MediaPresent "
     "association."),
    MappingStrings {"MIF.DMTF|Storage Devices|001.8"}  ] 
class CIM_MediaPresent : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The MediaAccessDevice.") ]
   CIM_MediaAccessDevice REF Antecedent;
      [Override ("Dependent"), Description (
        "The StorageExtent accessed using the MediaAccessDevice.") ]
   CIM_StorageExtent REF Dependent;
      [Description (
        "Boolean indicating that the accessed StorageExtent is "
        "fixed in the MediaAccessDevice and can not be ejected.") ]
   boolean FixedMedia;
};


// ===================================================================
// StorageError
// ===================================================================
   [Description (
     "StorageError defines blocks of media or memory space that are "
     "mapped 'out of use' due to errors. The Key of the class is "
     "the StartingAddress of the bytes in error.") ] 
class CIM_StorageError : CIM_ManagedElement {
      [Propagated("CIM_StorageExtent.SystemCreationClassName"),
       Key, MaxLen (256),
       Description ("The scoping System's CreationClassName.") ]
   string SystemCreationClassName;
      [Propagated("CIM_StorageExtent.SystemName"),
       Key, MaxLen (256),
       Description ("The scoping System's Name.") ]
   string SystemName;
      [Propagated("CIM_StorageExtent.CreationClassName"),
       Key, MaxLen (256),
       Description ("The scoping StorageExtent's CreationClassName.") ]
   string DeviceCreationClassName;
      [Propagated("CIM_StorageExtent.DeviceID"),
       Key, MaxLen (64),
       Description ("The scoping StorageExtent's DeviceID.") ]
   string DeviceID;
      [Key,
       Description ("The starting address of the bytes in error.") ]
   uint64 StartingAddress;
      [Description ("The ending address of the bytes in error.") ]
   uint64 EndingAddress;
};


// ===================================================================
// StorageDefect
// ===================================================================
   [Association, Aggregation, Description (
     "The StorageDefect aggregation collects the StorageErrors for "
     "a StorageExtent.") ] 
class CIM_StorageDefect {
      [Key, Aggregate, Min (1), Max (1), Description (
        "The Extent reference defines the StorageExtent on which the "
        "errors occurred.") ]
   CIM_StorageExtent REF Extent;
      [Key, Weak, Description (
        "Error references the Error object, defining the starting "
        "and ending addresses that are 'mapped out' of the Storage"
        "Extent.") ]
   CIM_StorageError REF Error;
};


// ===================================================================
// PhysicalExtent
// ===================================================================
   [Description (
     "A PhysicalExtent is used to model an SCC RAID "
     "implementation. It defines the consecutive addressable "
     "block addresses on a single storage device, that are "
     "treated as a single StorageExtent and that are in the "
     "same StorageRedundancyGroup. An alternate possibility, "
     "if automatic configuration is used, is to instantiate or "
     "extend the AggregatePExtent class.") ] 
class CIM_PhysicalExtent : CIM_StorageExtent {
// Override is used to define the MappingString qualifier 
      [Override ("BlockSize"),   
       MappingStrings {"MIF.DMTF|Physical Extent|001.4"} ]
   uint64 BlockSize;
// Override is used to define the MappingString qualifier 
      [Override ("NumberOfBlocks"),
       MappingStrings {"MIF.DMTF|Physical Extent|001.3"} ]
   uint64 NumberOfBlocks;
      [Description (
        "Number of bytes of user data to skip before "
        "starting the check data interleave."),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|Physical Extent|001.6"} ]
   uint64 UnitsBeforeCheckDataInterleave;
      [Description (
        "Number of bytes to be reserved for check data."),
       Units ("Bytes"), 
       MappingStrings {"MIF.DMTF|Physical Extent|001.7"} ]
   uint64 UnitsOfCheckData;
      [Description (
        "Number of bytes to be reserved for user data."),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|Physical Extent|001.8"} ]
   uint64 UnitsOfUserData;
};


// ===================================================================
// ProtectedSpaceExtent
// ===================================================================
   [Description (
     "A ProtectedSpaceExtent is used to model an SCC RAID "
     "implementation. ProtectedSpaceExtent defines addressable logical "
     "block addresses, treated as a single Extent, located on one or "
     "more PhysicalExtents. ProtectedSpaceExtents exclude any logical "
     "blocks mapped as check data and contain user data stripe depth "
     "mapping information. An alternate possibility, if automatic "
     "configuration is used, is to instantiate or extend the Aggregate"
     "PSExtent class.") ] 
class CIM_ProtectedSpaceExtent : CIM_StorageExtent {
// Override is used to define the MappingString qualifier 
      [Override ("BlockSize"),
       MappingStrings {"MIF.DMTF|Protected Space Extent|001.4"} ]
   uint64 BlockSize;
      [Override ("NumberOfBlocks"),
       Description (
        "The number of user data blocks contained in this Extent."),
       MappingStrings {"MIF.DMTF|Protected Space Extent|001.3"} ]
   uint64 NumberOfBlocks;
      [Description (
        "For a ProtectedSpaceExtent that is allocated to a VolumeSet, "
        "(i.e. is named in a CIM_VolumeSetBasedOnPSExtent "
        "association), this property is the number of user data bytes "
        "placed on this ProtectedSpaceExtent before moving on to the "
        "next ProtectedSpaceExtent in the VolumeSet.  Otherwise, this "
        "ProtectedSpaceExtent is considered to be unallocated and "
        "this property shall be set to zero (0h.)"),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|Protected Space Extent|001.6"} ]
    uint64 UserDataStripeDepth;
};


// ===================================================================
// PSExtentBasedOnPExtent
// ===================================================================
   [Association, Description (
     "ProtectedSpaceExtents are BasedOn a PhysicalExtent. This "
     "relationship is made explicit in this association.") ] 
class CIM_PSExtentBasedOnPExtent : CIM_BasedOn {
      [Override ("Antecedent"), Description (
        "The PhysicalExtent.") ]
   CIM_PhysicalExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The ProtectedSpaceExtent which is built on the Physical"
        "Extent.") ]
   CIM_ProtectedSpaceExtent REF Dependent;
      [Override ("StartingAddress"), Description (
        "The starting logical block address of the PhysicalExtent "
        "from which this ProtectedSpaceExtent is derived."), 
       MappingStrings {"MIF.DMTF|Protected Space Extent|001.2"} ]
   uint64 StartingAddress;
};


// ===================================================================
// StorageVolume 
// ===================================================================
   [Description (
     "A StorageVolume is an Extent that is presented to the Operating"
     "System (for example, by a hardware RAID cabinet), to a File"
     "System (for example, by a software volume manager) or to another "
     "entity. StorageVolumes do NOT participate in StorageRedundancy"
     "Groups. They are directly Realized in hardware or are the end "
     "result of assembling lower level Extents.") ]
class CIM_StorageVolume : CIM_StorageExtent {
};


// ===================================================================
// VolumeSet
// ===================================================================
   [Description (
     "A VolumeSet is used to model an SCC RAID implementation. "
     "VolumeSets represent a contiguous range of logical blocks "
     "presented to the operating environment. VolumeSets may overlap. "
     "However, the underlying PhysicalExtents within the overlap "
     "shall not contain any check data. They are BasedOn one or more "
     "ProtectedSpaceExtents. These BasedOn associations should be "
     "instantiated or subclassed as needed.") ] 
class CIM_VolumeSet : CIM_StorageVolume {
// Override is used to define the MappingString qualifier 
      [Override ("NumberOfBlocks"), 
       MappingStrings {"MIF.DMTF|Volume Set|001.3"} ]
   uint64 NumberOfBlocks;
      [Description (
        "Number of contiguous ProtectedSpaceExtents counted "
        "before looping back to the first ProtectedSpaceExtent "
        "of the current stripe. It is the number of Extents forming "
        "the user data stripe."),
       MappingStrings {"MIF.DMTF|Volume Set|001.4"} ]
   uint64 PSExtentStripeLength;
      [Description (
        "Number of ProtectedSpaceExtents to stripe as a collective "
        "set. In SCC, this value is defined as the number of stripes "
        "to count before continuing to map into the next contiguous "
        "set of Extents, beyond the current stripe."), 
       MappingStrings {"MIF.DMTF|Volume Set|001.5"} ]
   uint64 PSExtentInterleaveDepth;
      [Description (
        "VolumeSets in SCC have additional status information "
        "beyond that captured in the Availability and StatusInfo "
        "properties, inherited from ManagedSystemElement. This "
        "additional information (for example, \"Protection Disabled\", "
        "value=9) is captured in the VolumeStatus property."), 
       Values {"Other", "Unknown", "None/Not Applicable", "Broken", 
               "Data Lost", "Dynamic Reconfig", "Exposed", 
               "Fractionally Exposed", "Partially Exposed", 
               "Protection Disabled", "Readying", "Rebuild", 
               "Recalculate", "Spare in Use", "Verify In Progress"} ]
   uint16 VolumeStatus;
};


// ===================================================================
// VolumeSetBasedOnPSExtent
// ===================================================================
   [Association, Description (
     "VolumeSets are BasedOn on one or more ProtectedSpaceExtents. "
     "This relationship is made explicit in this association.") ]
class CIM_VolumeSetBasedOnPSExtent : CIM_BasedOn {
      [Override ("Antecedent"), Min (1), 
       Description ("The ProtectedSpaceExtent.") ]
   CIM_ProtectedSpaceExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The VolumeSet which is built on the ProtectedSpaceExtent.") ]
   CIM_VolumeSet REF Dependent;
      [Description (
        "True if logical blocks in the ProtectedSpaceExtent are mapped "
        "in decrementing order. This property corresponds to the INCDEC "
        "value in the SCC-2 Volume Set PS_Extent Descriptor.") ]
   boolean LBAsMappedByDecrementing;
      [Description (
        "True if the logical block mapping algorithm includes check data "
        "bytes. This property corresponds to the NOCHKSKIP attribute in "
        "the SCC-2 Volume Set PS_Extent Descriptor.") ]
   boolean LBAMappingIncludesCheckData;
};


// ===================================================================
// MediaPartition
// ===================================================================
   [Description (
     "A MediaPartition is a presentation of a contiguous range "
     "of logical blocks and has identifying data written on/to it. "
     "It may include a signature written by the OS or by "
     "an application.  This class is a common superclass for Disk and "
     "TapePartions. Partitions are directly realized by Physical"
     "Media (indicated by the RealizesExtent association) or built "
     "on StorageVolumes (indicated by the BasedOn association.") ] 
class CIM_MediaPartition : CIM_StorageExtent {
      [Description (
        "Boolean indicating that the Partition is labeled as "
        "bootable. (Note that this does not mean that an Operating"
        "System is actually loaded on the Partition.) With the advent "
        "of bootable Tape and other bootable media, this property is "
        "included in the higher level MediaPartition class, rather "
        "than in a subclass such as DiskPartition.") ]
   boolean Bootable;
      [Description (
        "Boolean indicating that the Partition is available and "
        "may be allocated for use.") ]
   boolean Allocatable;
      [Description (
        "An identifying string written to the Partition. Additional "
        "information related to this 'Signature' may be found in the "
        "properties, SignatureState and SignatureAlgorithm."), 
       ModelCorrespondence {"CIM_MediaPartition.SignatureState",
        "CIM_MediaPartition.SignatureAlgorithm"} ]
   string Signature;
      [Description (
        "A free-form string describing the algorithm used to "
        "define the Partition Signature. The value of this property "
        "is dependent on the Signature's State. "),
       ModelCorrespondence {"CIM_MediaPartition.Signature", 
        "CIM_MediaPartition.SignatureState"} ]
   string SignatureAlgorithm;
      [Description (
        "An enumeration describing the state of the Partition's "
        "identifying Signature string. Information such as "
        "\"Uninitialized\" (value=2), or \"Assigned by Owning "
        "Application\" (value=5) are possible entries. "),
       Values {"Unknown", "Unimplemented", "Uninitialized",
               "Calculated by Operating System", 
               "Calculated by a Media Manager", 
               "Assigned by Owning Application"},
       ModelCorrespondence {"CIM_MediaPartition.Signature",
        "CIM_MediaPartition.SignatureAlgorithm"} ]
   string SignatureState;
      [Description (
        "Boolean indicating that the Partition can be grown/extended "
        "without reformatting.") ]
   boolean Extendable;
};


// ===================================================================
// DiskPartition
// ===================================================================
   [Description (
     "A DiskPartition is a presentation of a contiguous range "
     "of logical blocks that is identifiable by the Operating"
     "System via the Partition's type and subtype fields. Disk"
     "Partitions should be directly realized by PhysicalMedia "
     "(indicated by the RealizesDiskPartition association) or built "
     "on StorageVolumes (indicated by the PartitionBasedOnVolume "
     "association.") ] 
class CIM_DiskPartition : CIM_MediaPartition {
      [Description (
        "Boolean indicating that the DiskPartition is labelled as "
        "the primary partition for a ComputerSystem.") ]
   boolean PrimaryPartition;
      [Description ("The type of Partition."), 
       Values {"Unknown", "Primary", "Extended", "Logical"} ]
   uint16 PartitionType;
      [Description (
        "The 'sub' type of a primary, extended, or logical Partition. "
        "The list of possible values corresponds to the decimal "
        "representation of the typical values in the Partition record."), 
       ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", 
                 "10", "11", "12", "14", "15", "16", "17", "18", 
                 "20", "22", "23", "27", "28", "33", "35", "36", 
                 "38", "49", "51", "52", "53", "54", "55", "60", 
                 "64", "65", "66", "67", "80", "81", "82", "83", 
                 "84", "85", "86", "97", "99", "100", "101", "102", 
                 "103", "104", "105", "113", "115", "116", "117", 
                 "118", "119", "120", "121", "128", "129", "130", 
                 "131", "132", "134", "135", "147", "148", "161", 
                 "163", "164", "165", "166", "177", "179", "180", 
                 "182", "183", "184", "193", "196", "198", "199", 
                 "216", "219", "225", "227", "228", "229", "230", 
                 "239", "240", "241", "242", "243", "244", "246", 
                 "254", "255", "65535"}, 
       Values {"Empty | Microsoft", "DOS 12-bit FAT", 
               "XENIX root", "XENIX usr", "DOS 16-bit FAT", 
               "DOS Extended", "DOS 16-bit FAT (> 32MB)", 
               "OS/2 HPFS | Win NTFS | QNX Ver 2 | Adv UNIX", 
               "AIX Boot | OS /2 | Dell (Array) | Commodore DOS", 
               "AIX Data, Coherent", "OS/2 Boot Manager", 
               "32-bit FAT", "32-bit FAT", "Microsoft 16-bit FAT", 
               "Microsoft DOS Extended", "OPUS | OS/2 2.0", 
               "OS/2 (MOSS) Inactive Type 1", 
               "Compaq Diagnostics Partition | Microsoft", 
               "OS/2 (MOSS) Inactive Type 4", 
               "OS/2 (MOSS) Inactive Type 6", 
               "OS/2 (MOSS) Inactive Type 7", 
               "OS/2 (MOSS) Inactive Type B", 
               "OS/2 (MOSS) Inactive Type C", "Microsoft", 
               "Microsoft", "Microsoft", "Microsoft", "Microsoft", 
               "Microsoft", "Microsoft", "OS/2 Logical Volume Manager", 
               "Microsoft", "OS/2 JFS Log", "PowerQuest", 
               "VENIX 80286 | Series/1 Disk", "Personal RISC Boot", 
               "Veritas", "Veritas", "OnTrack Disk Manager Read Only DOS", 
               "OnTrack Disk Manager Read/Write DOS", 
               "CPM | Microport System V/386 | OnTrack Disk Mgr | Microsoft", 
               "OnTrack Disk Manager", "OnTrack Disk Manager Non-DOS", 
               "Micro House EZ-Drive Non-DOS", 
               "Golden Bow Vfeature | Microsoft", 
               "Storage Dimensions SpeedStor | Microsoft", 
               "UNIX - AT&T System V/386 | SCO UNIX", 
               "Novell NetWare | Speedstore", "Novell NetWare", 
               "Novell NetWare", "Novell", "Novell", "Novell", 
               "Microsoft", "Microsoft", "Microsoft", "PC/IX IBM", 
               "Microsoft", "QNX POSIX", "QNX POSIX (Secondary)", 
               "QNX POSIX (Secondary)", 
               "Minix (<=1.4a) | Linux | Microsoft", 
               "Minix (>=1.4b) | Microsoft", "Linux Swap | Prime", 
               "Linux Native | Apple", "System Hibernation for APM", 
               "Microsoft", "HPFS FT mirror", "Amoeba | Microsoft", 
               "Amoeba BBT | Microsoft", "Microsoft", "Microsoft", 
               "Microsoft", "BSD/386", "Microsoft", "Microsoft", 
               "Microsoft", "Microsoft", "Microsoft", 
               "BSDI fs | Microsoft", "BSDI Swap | Microsoft", 
               "Microsoft", "Microsoft", "Microsoft", 
               "Syrinx | HPFS FT Disabled Mirror", "CP/M 86", 
               "Digital Research CPM-86 | Concurrent DOS | OUTRIGGER", 
               "SpeedStor 12-bit FAT Extended", 
               "DOS Read-Only | Storage Dimensions", 
               "SpeedStor 16-bit FAT Extended", "Microsoft", 
               "Microsoft", "Intel", "OS/2 Raw Data", 
               "Storage Dimensions", "DOS (Secondary)", "Microsoft", 
               "SpeedStor Large | Storage Dimensions", "Microsoft", 
               "Lan Step | SpeedStor | IBM PS/2 IML", 
               "Bad Block Tables", "Unknown"} ]
   uint16 PartitionSubtype;
};


// ===================================================================
// DiskPartitionBasedOnVolume
// ===================================================================
   [Association, Description (
     "DiskPartitions should be BasedOn a single StorageVolume (for "
     "example, exposed by a hardware RAID cabinet), an SCC VolumeSet, "
     "or realized directly in PhysicalMedia. The first two "
     "relationships are made explicit in this association. The latter "
     "is conveyed by the RealizesDiskPartition association.") ]
class CIM_DiskPartitionBasedOnVolume : CIM_BasedOn {
      [Override ("Antecedent"), Max (1), 
       Description ("The StorageVolume.") ]
   CIM_StorageVolume REF Antecedent;
      [Override ("Dependent"), Description (
        "The DiskPartition which is built on the Volume.") ]
   CIM_DiskPartition REF Dependent;
};


// ===================================================================
// TapePartition
// ===================================================================
   [Description (
     "Capabilities and management of a TapePartition StorageExtent. "
     "Note that if a PhysicalTape is not partitioned, only a "
     "generic StorageExtent that represents the entire Tape should "
     "be instantiated. TapePartitions may be BasedOn other "
     "StorageExtents or directly Realized on a PhysicalTape.") ]
class CIM_TapePartition : CIM_MediaPartition {
      [Gauge, Description (
        "Number of blocks that are currently unused/not written on "
        "the Partition. When this number is multiplied by the "
        "BlockSize, inherited from StorageExtent, the total number "
        "of bytes available for writing can be computed.") ]
   uint64 UnusedBlocks;

};


// ===================================================================
// TapePartitionOnSurface
// ===================================================================
   [Association, Description (
     "TapePartitionOnSurface represents the ability to have one or "
     "more TapePartitions on each surface of a PhysicalTape. The "
     "individual surfaces are represented as instances of "
     "CIM_StorageExtent.") ]
class CIM_TapePartitionOnSurface : CIM_BasedOn {
      [Override ("Antecedent"), Max (1), 
       Description (
        "The StorageExtent that represents the Tape's surface.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The TapePartition which is built on the Extent.") ]
   CIM_TapePartition REF Dependent;
};


// ===================================================================
// LogicalDisk
// ===================================================================
   [Description (
     "A LogicalDisk is a presentation of a contiguous range of "
     "logical blocks that is identifiable by a FileSystem via the "
     "Disk's DeviceId (key) field. For example in a Windows "
     "environment, the DeviceID field would contain a drive letter. "
     "In a Unix environment, it would contain the access path; and in "
     "a NetWare environment, DeviceID would contain the volume name. "
     "LogicalDisks are typically built on a DiskPartition or Storage"
     "Volume (for example, exposed by a software volume manager) "
     "using the LogicalDiskBasedOnPartition or LogicalDiskBasedOn"
     "Volume associations. However, it can be based on other "
     "StorageExtents, like CIM_Memory, in the case of a RAM disk. "
     "The latter is described using the LogicalDiskBasedOnExtent "
     "relationship. (Indeed, the BasedOnExtent association is the "
     "superclass for the BasedOnPartition and BasedOnVolume "
     "relationships.)") ] 
class CIM_LogicalDisk : CIM_StorageExtent {
};


// ===================================================================
// LogicalDiskBasedOnExtent 
// ===================================================================
   [Association, Description (
     "LogicalDisks can be BasedOn a single StorageVolume, Memory "
     "(in the case of a RAM Disk), a DiskPartition or other " 
     "StorageExtent. These relationships are made explicit in this "
     "association. Subclasses of the association, LogicalDiskBasedOn"
     "Partition and LogicalDiskBasedOnVolume, detail the 'typical' "
     "semantics.") ]
class CIM_LogicalDiskBasedOnExtent : CIM_BasedOn {
      [Override ("Antecedent"), Max (1), 
       Description ("The StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The LogicalDisk which is built on the StorageExtent.") ]
   CIM_LogicalDisk REF Dependent;
};


// ===================================================================
// LogicalDiskBasedOnVolume
// ===================================================================
   [Association, Description (
     "LogicalDisks can be BasedOn a single Volume (for example, "
     "exposed by a software volume manager), or be BasedOn a Disk"
     "Partition directly. The former relationship is made explicit "
     "in this association.") ]
class CIM_LogicalDiskBasedOnVolume : CIM_LogicalDiskBasedOnExtent {
      [Override ("Antecedent"), Max (1), 
       Description ("The StorageVolume.") ]
CIM_StorageVolume REF Antecedent; 
};


// ===================================================================
// LogicalDiskBasedOnVolumeSet
// ===================================================================
   [Association, Description (
     "LogicalDisks can be BasedOn a VolumeSet. This association is "
     "an optimization where software RAID doesn't exist and the "
     "LogicalDisk is built right on top of a VolumeSet presented by "
     "an SCC cabinet. However, this would be better modeled by a "
     "DiskPartition BasedOn the VolumeSet (described using the "
     "DiskPartitionBasedOnVolume association) and then basing the "
     "LogicalDisk on the DiskPartition (using the LogicalDisk"
     "BasedOnPartition association).") ] 
class CIM_LogicalDiskBasedOnVolumeSet : CIM_LogicalDiskBasedOnVolume {
      [Override ("Antecedent"), Max (1),
       Description ("The VolumeSet.") ]
   CIM_VolumeSet REF Antecedent;
};


// ===================================================================
// LogicalDiskBasedOnPartition
// ===================================================================
   [Association, Description (
     "LogicalDisks can be BasedOn a DiskPartition. For example, a "
     "personal computer's C: drive may be located on a Partition on "
     "local PhysicalMedia. In this association of LogicalDisks to "
     "Partitions, note that the cardinality of the Antecedent, Disk"
     "Partition, is Max(1). This dictates that a LogicalDisk can not "
     "span more than one Partition. However, there are cases where "
     "this is true. When it occurs, the LogicalDisk is really based "
     "on some kind of RAID configuration (for example, a mirror or "
     "stripe set). In these scenarios, the LogicalDisk is more "
     "correctly BasedOn a StorageVolume. To prevent incorrectly using "
     "the LogicalDiskBasedOnPartition association, the Max(1) "
     "qualifier was put on the Antecedent reference to the "
     "DiskPartition.") ] 
class CIM_LogicalDiskBasedOnPartition : CIM_LogicalDiskBasedOnExtent {
      [Override ("Antecedent"), Max (1),
       Description ("The DiskPartition.") ]
   CIM_DiskPartition REF Antecedent;
};


// ===================================================================
// AggregatePExtent
// ===================================================================
   [Description (
     "An AggregatePExtent is used to model an SCC RAID "
     "implementation. AggregatePExtents provide summary information "
     "about the addressable logical blocks which are in the same "
     "StorageRedundancyGroup and reside on the same storage device. "
     "This is an alternative grouping for PhysicalExtents, when only "
     "summary information is needed or when automatic configuration "
     "is used.") ] 
class CIM_AggregatePExtent : CIM_StorageExtent {
      [Override ("NumberOfBlocks"),
       Description (
        "Total number of blocks (including the check data blocks) "
        "contained in this AggregatePExtent.  The block size (an "
        "inherited property) should be set to the same value as for "
        "the MediaAccessDevice associated with this Extent."),
       MappingStrings {"MIF.DMTF|Aggregate Physical Extent|001.2"} ]
   uint64 NumberOfBlocks;
      [Description (
        "The number of blocks contained in this AggregatePExtent "
        "to be used as check data. If this AggregatePExtent is "
        "available, then this value shall be zero."), 
       MappingStrings {"MIF.DMTF|Aggregate Physical Extent|001.3"} ]
   uint64 BlocksOfCheckData;
};


// ===================================================================
// AggregatePSExtent
// ===================================================================
   [Description (
     "An AggregatePSExtent is used to model an SCC RAID "
     "implementation. AggregatePSExtents define the number of "
     "addressable logical blocks on a single storage device, "
     "excluding any logical blocks mapped as check data. "
     "This is an alternative grouping for ProtectedSpaceExtents, "
     "when only summary information is needed or when automatic "
     "configuration is used.") ] 
class CIM_AggregatePSExtent : CIM_StorageExtent {
      [Override ("NumberOfBlocks"), Description (
        "Total number of user data blocks that are contained in this "
        "Extent."),
       MappingStrings {
        "MIF.DMTF|Aggregate Protected Space Extent|001.2"} ]
   uint64 NumberOfBlocks;   
};


// ===================================================================
// AggregatePSExtentBasedOnPExtent
// ===================================================================
   [Association, Description (
     "AggregatePSExtents are BasedOn a single PhysicalExtent. This "
     "relationship is made explicit in this association.") ]
class CIM_AggregatePSExtentBasedOnPExtent : CIM_BasedOn {
      [Override ("Antecedent"), Max (1), 
       Description ("The PhysicalExtent.")]
   CIM_PhysicalExtent REF Antecedent;
      [Override ("Dependent"),  Description (
        "The AggregatePSExtent which is built on the "
        "PhysicalExtent.") ]
   CIM_AggregatePSExtent REF Dependent;
};


// ===================================================================
// AggregatePSExtentBasedOnAggregatePExtent
// ===================================================================
   [Association, Description (
     "AggregatePSExtents are BasedOn a single AggregatePExtent. This "
     "relationship is made explicit in this association.") ]
class CIM_AggregatePSExtentBasedOnAggregatePExtent : CIM_BasedOn {
      [Override ("Antecedent"), Max (1),
       Description ("The AggregatePExtent.")]
   CIM_AggregatePExtent REF Antecedent;
      [Override ("Dependent"), Description (
        "The AggregatePSExtent which is built on the Aggregate"
        "PExtent.") ]
   CIM_AggregatePSExtent REF Dependent;
};


// ===================================================================
// Snapshot 
// ===================================================================
   [Description (
     "The Snapshot class is an optional construct. It can be "
     "used to represent an Extent that contains a full copy of "
     "another Extent, or the changes to that Extent when performing "
     "a delta-based (delta before or delta after) copy.\n"
     "Snapshot's definition in CIM is not equivalent to the act "
     "of creating a volume or file-based snapshot, or a point in "
     "time copy. It is at a much lower level and represents the "
     "use of storage to hold a copied image of an Extent, or to hold "
     "changes to an Extent.  Use of the Snapshot object when making "
     "a full copy is only recommended if the purpose is to describe "
     "the existence of a copy. (This use will be very infrequent.) "
     "The problem with describing an Extent solely as a 'snapshot' "
     "is that when the snapshot/copy is broken, the object must be "
     "destroyed. Typically, this object still holds valid data, and "
     "would have to be reinstantiated. If the 'full copy' object "
     "is to be treated as a StorageVolume or more general Extent, "
     "then it should be modeled as such from the beginning - "
     "i.e., not as an instance of Snapshot but as an instance of a "
     "generic StorageExtent or StorageVolume. In this case, the "
     "Synchronized association would be used to describe that one "
     "StorageExtent is synchronized with another.\n"
     "When describing a delta-based snapshot/point in time copy, "
     "the Snapshot object represents the store holding the before/after "
     "image changes to the original Extent. For example, when doing a "
     "'delta before' Snapshot, the resultant target would be modeled "
     "as a StorageExtent that is BasedOn the original Extent and the "
     "instance of Snapshot (that holds the changes to the original Extent).") ]
class CIM_Snapshot : CIM_StorageExtent {
      [Description ("True indicates that the snapshot is synced.") ]
   boolean IsSynced;
      [Description (
        "The time stamp indicating when the sync occurred.") ]
   datetime SyncTime;
};


// ===================================================================
// SnapshotOfExtent
// ===================================================================
   [Association, Description (
     "SnapshotOfExtent is an association between an Extent and "
     "its Snapshot. This relationship is made explicit in this "
     "association.") ]
class CIM_SnapshotOfExtent : CIM_Dependency {
      [Override ("Antecedent"), Max (1), 
       Description ("The StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"), 
       Description ("The Snapshot.") ]
   CIM_Snapshot REF Dependent;
      [Description ("The type of snapshot."), 
       Values {"Other", "Unknown", "Copy", "Before Delta", 
               "After Delta"} ]
   uint16 SnapshotType;
};


// ===================================================================
// Memory
// ===================================================================
   [Description (
     "Capabilities and management of Memory-related LogicalDevices.") ] 
class CIM_Memory : CIM_StorageExtent {
      [Override ("ErrorMethodology"),
       Description (
        "ErrorMethodology for Memory is a string property that "
        "indicates whether parity or CRC algorithms, ECC or other "
        "mechanisms are used. Details on the algorithm can also "
        "be supplied."),
       MappingStrings {"MIF.DMTF|Physical Memory Array|001.7"} ]
   string ErrorMethodology;
      [Description (
        "The beginning address, referenced by an application or "
        "operating system and mapped by a memory controller, for "
        "this Memory object. The starting address is specified in "
        "KBytes."),
       Units ("KiloBytes"),
       MappingStrings {"MIF.DMTF|Memory Array Mapped Addresses|001.3",
        "MIF.DMTF|Memory Device Mapped Addresses|001.4"} ]
   uint64 StartingAddress;
      [Description (
        "The ending address, referenced by an application or "
        "operating system and mapped by a memory controller, for "
        "this Memory object. The ending address is specified in "
        "KBytes."),
       Units ("KiloBytes"),
       MappingStrings {"MIF.DMTF|Memory Array Mapped Addresses|001.4",
        "MIF.DMTF|Memory Device Mapped Addresses|001.5"} ]
   uint64 EndingAddress;
      [Description (
        "An integer enumeration describing the type of error that "
        "occurred most recently. For example, single (value=6) or "
        "double bit errors (7) can be specified using this property. "
        "The values, 12-14, are undefined in the CIM Schema since in "
        "DMI, they mix the semantics of the type of error and whether "
        "it was correctable or not.  The latter is indicated in the "
        "property, CorrectableError."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
                 "11", "12", "13", "14"},
       Values {"Other", "Unknown", "OK", "Bad Read", "Parity Error",
               "Single-Bit Error", "Double-Bit Error", "Multi-Bit Error",
               "Nibble Error", "Checksum Error", "CRC Error", "Undefined",
               "Undefined", "Undefined"}, 
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.8"},
       ModelCorrespondence {"CIM_Memory.OtherErrorDescription"} ]
   uint16 ErrorInfo;
      [Description (
        "Free form string providing more information if the Error"
        "Type property is set to 1, \"Other\". If not set to 1, this "
        "string has no meaning."),
       ModelCorrespondence {"CIM_Memory.ErrorInfo"} ]
   string OtherErrorDescription;
      [Description (
        "Boolean indicating that the most recent error was "
        "correctable. If the ErrorInfo property is equal to 3, " 
        "\"OK\", then this property has no meaning."),
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.8"} ]
   boolean CorrectableError;
      [Description (
        "The time that the last memory error occurred. The type of "
        "error is described by the ErrorInfo property. If the Error"
        "Info property is equal to 3, \"OK\", then this property has "
        "no meaning.") ]
   datetime ErrorTime;
      [Description (
        "An integer enumeration indicating the memory access "
        "operation that caused the last error. The type of error is "
        "described by the ErrorInfo property. If the ErrorInfo "
        "property is equal to 3, \"OK\", then this property "
        "has no meaning."),
       ValueMap {"1", "2", "3", "4", "5"}, 
       Values {"Other", "Unknown", "Read", "Write", "Partial Write"},
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.10"} ]
   uint16 ErrorAccess;
      [Description (
        "The size of the data transfer in bits that caused the last "
        "error. 0 indicates no error. If the ErrorInfo property "
        "is equal to 3, \"OK\", then this property should be set "
        "to 0."),
       Units ("Bits"),       
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.11"} ]
   uint32 ErrorTransferSize;
      [OctetString, Description (
        "Data captured during the last erroneous mebmory access. "
        "The data occupies the first n octets of the array necessary "
        "to hold the number of bits specified by the ErrorTransferSize "
        "property. If ErrorTransferSize is 0, then this property "
        "has no meaning."),
       ArrayType ("Indexed"),   
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.12"} ]
   uint8 ErrorData[64];
      [Description (
        "The ordering for data stored in the ErrorData property. "
        "\"Least Significant Byte First\" (value=1) or "
        "\"Most Significant Byte First\" (2) can be specified. If "
        "ErrorTransferSize is 0, then this property has no meaning."),
       Values {"Unknown", "Least Significant Byte First",
               "Most Significant Byte First"}       ]
   uint16 ErrorDataOrder;
      [Description (
        "Specifies the address of the last memory error. The type "
        "of error is described by the ErrorInfo property. "
        "If the ErrorInfo property is equal to 3, \"OK\", then this "
        "property has no meaning."),     
       MappingStrings {"MIF.DMTF|Memory Device|005", 
        "MIF.DMTF|Memory Device|005", 
        "MIF.DMTF|Physical Memory Array|001.14"} ]
   uint64 ErrorAddress;
      [Description (
        "Boolean indicating whether the address information in "
        "the property, ErrorAddress, is a system-level address (TRUE) " 
        "or a physical address (FALSE). If the ErrorInfo property is "
        "equal to 3, \"OK\", then this property has no meaning.") ]
   boolean SystemLevelAddress;
      [Description (
        "Specifies the range, in bytes, to which the last error can be "
        "resolved. For example, if error addresses are resolved to bit "
        "11 (ie, on a typical page basis), then errors can be "
        "resolved to 4K boundaries and this property is set to 4000. "
        "If the ErrorInfo property is equal to 3, \"OK\", then this "
        "property has no meaning."),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|Memory Device|005",
       "MIF.DMTF|Physical Memory Array|001.15"} ]
   uint64 ErrorResolution;
      [OctetString, Description (
        "An array of octets holding additional error information. "
        "An example is ECC Syndrome or the return of the check bits "
        "if a CRC-based ErrorMethodology is used. In the latter case, "
        "if a single bit error is recognized and the CRC algorithm "
        "is known, it is possible to determine the exact bit that "
        "failed.  This type of data (ECC Syndrome, Check Bit or "
        "Parity Bit data, or other vendor supplied information) is "
        "included in this field. If the ErrorInfo property is "
        "equal to 3, \"OK\", then AdditionalErrorData has no meaning."),
       MappingStrings {"MIF.DMTF|Memory Device|005",
        "MIF.DMTF|Physical Memory Array|001.13"} ]
   uint8 AdditionalErrorData[64];
};


// ===================================================================
// AssociatedMemory
// ===================================================================
   [Association, Description (
     "LogicalDevices may have Memory installed on them or "
     "otherwise associated with them - such as CacheMemory. "
     "This is made explicit in this association.") ] 
class CIM_AssociatedMemory : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "Memory installed on or associated with a Device.") ]
   CIM_Memory REF Antecedent;
      [Override ("Dependent"), Description (
        "The LogicalDevice.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// ComputerSystemMemory
// ===================================================================
   [Association, Aggregation, Description (
     "Association indicating that memory is installed and required "
     "for the UnitaryComputerSystem to operate. At least one "
     "Memory StorageExtent is required. Note that this relationship "
     "inherits from the SystemDevice association, and therefore, "
     "the Memory StorageExtent is weak to the aggregating Unitary"
     "ComputerSystem.") ] 
class CIM_ComputerSystemMemory : CIM_SystemDevice {
      [Override ("GroupComponent"), Aggregate,
       Description ("The UnitaryComputerSystem.") ]
   CIM_UnitaryComputerSystem REF GroupComponent;
      [Override ("PartComponent"), Description (
        "The Memory StorageExtent which is part of the "
        "UnitaryComputerSystem.") ]
   CIM_Memory REF PartComponent;
};


// ===================================================================
// AssociatedProcessorMemory
// ===================================================================
   [Association, Description (
     "Associates the Processor and system Memory, or a Processor's "
     "Cache. ")  ]
class CIM_AssociatedProcessorMemory : CIM_AssociatedMemory { 
      [Override ("Dependent"), 
       Description (
        "The Processor that accesses the Memory or uses the Cache.") ]
   CIM_Processor REF Dependent; 
      [Description (
        "Speed of the bus, in MHertz, between the Processor and "
        "Memory. "), 
       Units ("MegaHertz") ]
   uint32 BusSpeed;
};


// ===================================================================
// NonVolatileStorage
// ===================================================================
   [Description (
     "Capabilities and management of NV Storage. Non-volatile memory "
     "natively includes flash and ROM storage. In addition, NV memory "
     "can be BasedOn VolatileStorage, if the volatile memory is backed "
     "by a Battery. This scenario would be completely described by an "
     "instance of the AssociatedBattery relationship, referencing the "
     "NonVolatileStorage as the Dependent and the Battery as the "
     "Antecedent, and an instance of the BasedOn relationship, "
     "referencing the NonVolatileStorage as the Dependent and the "
     "VolatileStorage as the Antecedent.") ]
class CIM_NonVolatileStorage : CIM_Memory {
      [Description ("Indicating that the NV storage is writeable.") ]
   boolean IsWriteable;
      [Description (
        "Boolean indicating that at least some portion of the "
        "NonVolatileStorage is writeable by applications.") ]
   boolean ApplicationWriteable;
      [Description (
        "When at least some portion of the NonVolatileStorage is "
        "writeable (ApplicationWriteable property = TRUE), StartAddress"
        "forApplcationWrite indicates the starting address for "
        "application data. If the ApplicationWriteable property is "
        "FALSE, this property is undefined."), 
       ModelCorrespondence {
        "CIM_NonVolatileStorage.ApplicationWriteable"} ]
   uint64 StartAddressForApplicationWrite;
      [Description (
        "When at least some portion of the NonVolatileStorage is "
        "writeable (ApplicationWriteable property = TRUE), Application"
        "WritableSize indicates the number of bits available for "
        "application data. If the ApplicationWriteable property is "
        "FALSE, this property is undefined."), 
       Units ("Bits"), 
       ModelCorrespondence {
        "CIM_NonVolatileStorage.ApplicationWriteable"} ]
   uint64 ApplicationWriteableSize;
};


// ===================================================================
// BIOSLoadedInNV
// ===================================================================
   [Association, Description (
     "A link between BIOSElement and NonVolatileStorage where "
     "the BIOS is loaded.") ] 
class CIM_BIOSLoadedInNV : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The non-volatile storage.") ]
   CIM_NonVolatileStorage REF Antecedent;
      [Override ("Dependent"),
       Description ("The BIOS stored in the NonVolatile Extent.") ]
   CIM_BIOSElement REF Dependent;
      [Description (
        "The starting address where the BIOS is located in "
        "non-volatile storage.") ]
   uint64 StartingAddress;
      [Description (
        "The ending address where the BIOS is located in "
        "non-volatile storage.") ]
   uint64 EndingAddress;        
};


// ===================================================================
// VolatileStorage
// ===================================================================
   [Description (
     "Capabilities and management of Volatile Storage.") ] 
class CIM_VolatileStorage : CIM_Memory {
      [Description (
        "Indicates whether this Memory can be cached or not."),
       MappingStrings {"MIF.DMTF|System Resource Memory Info|002"} ]
   boolean Cacheable;
      [Description (
        "An enumeration indicating the cache type that is "
        "compatible with this Memory. For example, 4 indicates "
        "write-through cache.  If the Cacheable property is "
        "set to false, then this property does not have meaning and "
        "should be set to 5, \"Not Applicable\"."),
       Values {"Other", "Unknown", "Write-Back", "Write-Through",
               "Not Applicable"},
       MappingStrings {"MIF.DMTF|System Resource Memory Info|002"} ]
   uint16 CacheType;
};


// ===================================================================
// CacheMemory
// ===================================================================
   [Description (
     "Capabilities and management of Cache Memory. Cache memory is "
     "dedicated or allocated RAM that a Processor searches first "
     "for data, before going to 'regular' memory. CacheMemory is "
     "used to speed up the delivery of data to a Processor. It is "
     "usually described by its closeness to the Processor (for "
     "example, Primary or Secondary Cache).\n"
     "If a DiskDrive includes RAM allocated for holding the disk's "
     "most recently read and/or adjacent data (in order to speed "
     "up retrieval), this also would be modeled as CacheMemory. "
     "Note that CacheMemory is NOT operating system or application "
     "level buffers but actual RAM allocated for caching data for "
     "a Processor, from a hard disk, etc.") ]
class CIM_CacheMemory : CIM_Memory {
      [Description (
        "Defines whether this is the Primary (value=3), Secondary "
        "(value=4) or Tertiary (value=5) Cache. Also, \"Other\" (1), "
        "\"Unknown\" (2) and \"Not Applicable\" (6) can be defined."),
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Primary", "Secondary", "Tertiary", 
               "Not Applicable"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 Level;
      [Description (
        "Defines whether this is write-back (value=3) or write-through "
        "(value=4) Cache, or whether this information \"Varies with "
        "Address\" (5) or is defined individually for each I/O (6). "
        "Also, \"Other\" (1) and \"Unknown\" (2) can be specified."),         
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Write Back", "Write Through",
               "Varies with Address", "Determination Per I/O"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 WritePolicy;
      [Description (
        "Defines whether this is for instruction caching (value=3), "
        "data caching (value=4) or both (value=5, \"Unified\"). "
        "Also, \"Other\" (1) and \"Unknown\" (2) can be defined."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "Instruction", "Data", "Unified"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 CacheType;
      [Description (
        "Size, in bytes, of a single cache bucket or line."),
       Units ("Bytes"),
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint32 LineSize;
      [Description (
        "An integer enumeration describing the algorithm to "
        "determine which cache lines or buckets should be re-used."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8"},
       Values {"Other", "Unknown", "Least Recently Used (LRU)",
               "First In First Out (FIFO)", "Last In First Out (LIFO)",
               "Least Frequently Used (LFU)", 
               "Most Frequently Used (MFU)", 
               "Data Dependent Multiple Algorithms"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 ReplacementPolicy;
      [Description (
        "Policy that shall be employed by the Cache for handling "
        "read requests. For example, \"Read\", \"Read-Ahead\" or "
        "both can be specified using the values, 3, 4 or 5, "
        "respectively. If the read policy is determined individually "
        "(ie, for each request), then the value 6 (\"Determination "
        "per I/O\") should be specified. \"Other\" (1) and "
        "\"Unknown\" (2) are also valid values."),         
       ValueMap {"1", "2", "3", "4", "5", "6"},
       Values {"Other", "Unknown", "Read", "Read-Ahead", 
               "Read and Read-Ahead", "Determination Per I/O"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 ReadPolicy;
      [Description (
        "Maximum amount of time, in seconds, dirty lines or "
        "buckets may remain in the Cache before they are flushed. "
        "A value of zero indicated that a cache flush is not "
        "controlled by a flushing timer."), 
       Units ("Seconds"),
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint32 FlushTimer;
      [Description (
        "An integer enumeration defining the system cache "
        "associativity. For example, 6 indicates a fully associative "
        "cache."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8"},
       Values {"Other", "Unknown", "Direct Mapped", 
               "2-way Set-Associative",
               "4-way Set-Associative", "Fully Associative",
               "8-way Set-Associative", "16-way Set-Associative"},
       MappingStrings {"MIF.DMTF|System Cache|006"} ]
   uint16 Associativity;
};


// ===================================================================
// MediaTransferDevice
// ===================================================================
   [Description (
     "A MediaTransferDevice represents hardware that moves Physical"
     "Media. It is a superclass for Devices like PickerElement, "
     "ChangerDevice and InterLibraryPort.") ]
class CIM_MediaTransferDevice : CIM_LogicalDevice {
};

// ===================================================================
// PickerElement
// ===================================================================
   [Description (
     "PickerElements represent hardware used to pick or place "
     "PhysicalMedia from/into StorageMediaLocations.") ]
class CIM_PickerElement : CIM_MediaTransferDevice {
      [Description (
        "The maximum time in seconds for a PickerElement to grab "
        "a PhysicalMedia from a StorageMediaLocation, once the "
        "Picker has arrived at that Location. The maximum time "
        "interval for moving a Media from one point to another is "
        "the sum of the PickerElement's MaxPickTime, the Changer"
        "Device's MaxTransitTime and the PickerElement's MaxPutTime."), 
       Units ("Seconds") ]
   uint32 MaxPickTime;
      [Description (
        "The maximum time in seconds for a PickerElement to place "
        "a PhysicalMedia into a StorageMediaLocation, once the "
        "Picker has arrived at that Location. The maximum time "
        "interval for moving a Media from one point to another is "
        "the sum of the PickerElement's MaxPickTime, the Changer"
        "Device's MaxTransitTime and the PickerElement's MaxPutTime."), 
       Units ("Seconds") ]
   uint32 MaxPutTime;
      [Description (
        "String describing the location in the StorageLibrary "
        "where the Picker is currently positioned.") ] 
   string CellLocation;
};


// ===================================================================
// ChangerDevice 
// ===================================================================
   [Description (
     "ChangerDevices represent hardware that moves PhysicalMedia "
     "within a System, such as a StorageLibrary.") ]
class CIM_ChangerDevice : CIM_MediaTransferDevice {
      [Description (
        "The maximum time in seconds between a PickerElement pick "
        "and place. It should be reported as the transit time "
        "between the two most physically distant StorageMedia"
        "Locations in a System. The maximum time interval for "
        "moving a Media from one point to another is the sum of "
        "the PickerElement's MaxPickTime, the ChangerDevice's Max"
        "TransitTime and the PickerElement's MaxPutTime."), 
       Units ("Seconds") ]
   uint32 MaxTransitTime;
      [Description (
        "Boolean set to TRUE if the Changer supports media flipping. "
        "Media needs to be flipped when multi-sided PhysicalMedia "
        "are placed into a MediaAccessDevice that does NOT support "
        "dual sided access.") ]
   boolean MediaFlipSupported;
      [Description (
        "Boolean set to TRUE if an audit is currently being performed "
        "by the Changer.") ]
   boolean AuditInProgress;
      [Description (
        "A count of the number of audits performed by the Changer."), 
       Counter ]
   uint64 AuditsPerformed;
};


// ===================================================================
// PickerForChanger 
// ===================================================================
   [Association, Description (
     "PickerForChanger indicates the PickerElement(s) that access "
     "StorageMediaLocations and deliver PhysicalMedia to the Changer, "
     "for movement through the System. A Changer may have several "
     "Pickers for faster exchange of Media.") ]
class CIM_PickerForChanger : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "The PickerElement that accesses StorageMediaLocations "
        "to deliver Media to the Changer.") ]
   CIM_PickerElement REF Antecedent;
      [Override ("Dependent"), Max (1), 
       Description ("The ChangerDevice.") ]
   CIM_ChangerDevice REF Dependent;
};


// ===================================================================
// LimitedAccessPort 
// ===================================================================
   [Description (
     "LimitedAccessPorts represent hardware that transports Physical"
     "Media into or out of a System, such as a StorageLibrary. They "
     "are identified as 'limited' since these Ports do not provide "
     "access to ALL the PhysicalMedia or StorageMediaLocations in a "
     "Library, but only to a subset.") ]
class CIM_LimitedAccessPort : CIM_MediaTransferDevice {
      [Description (
        "Boolean indicating that the Port is 'locked' (TRUE) or "
        "'unlocked' (FALSE). When the Port is locked, access its Media "
        "Locations is prevented without the use of a physical key, "
        "front panel activity or the issuance of a software unlock "
        "command.") ]
   boolean Locked;
      [Description (
        "When a Port is 'Extended' or 'open' (value=TRUE), its Storage"
        "MediaLocations are accessible to a human operator. If not "
        "extended (value=FALSE), the Locations are accessible to a "
        "PickerElement.") ]
   boolean Extended;
      [Description (
        "When a LimitedAccessPort is 'Extended', all related media-"
        "transfer componentry may be stopped. The ExtendTimeout "
        "property provides a mechanism to event on a Port left open "
        "for a period of time (in seconds) exceeding the property's "
        "value."), 
       Units ("Seconds") ]
   uint32 ExtendTimeout;
      [Description ("Date and time that the Port was last extended.") ]
   datetime LastExtended;
      [Counter, Description (
        "The number of times that the LimitedAccessPort was used to "
        "move a PhysicalMedia into the System/StorageLibrary.") ]
   uint64 ImportCount;
      [Counter, Description (
        "The number of times that the LimitedAccessPort was used to "
        "move a PhysicalMedia out of the System/StorageLibrary.") ]
   uint64 ExportCount;
      [Description (
        "An enumeration expressing whether the Port is used for "
        "import into the Library/System which scopes and names it " 
        "(value=1), export from the Library/System (value=2), or "
        "both (value=3)."),
       Values {"Unknown", "Import", "Export", "Both Import and Export"} ]
   uint16 Direction;
};


// ===================================================================
// InterLibraryPort 
// ===================================================================
   [Description (
     "InterLibraryPorts represent hardware that transports Physical"
     "Media between connected StorageLibraries. The LibraryExchange "
     "association identifies the connected Libraries, by identifying "
     "the connected InterLibraryPorts.") ]
class CIM_InterLibraryPort : CIM_MediaTransferDevice {
      [Description (
        "Date and time that the Port was last accessed by its "
        "System/StorageLibrary. This value may be different "
        "than that specified for the Port(s) to which this Inter"
        "LibraryPort is connected. Connected Ports are identified "
        "using the LibraryExchange association.") ]
   datetime LastAccessed;
      [Counter, Description (
        "The number of times that the InterLibraryPort was used to "
        "move a PhysicalMedia into the System/StorageLibrary.") ]
   uint64 ImportCount;
      [Counter, Description (
        "The number of times that the InterLibraryPort was used to "
        "move a PhysicalMedia out of the System/StorageLibrary.") ]
   uint64 ExportCount;
      [Description (
        "An enumeration expressing whether the Port is used for "
        "import into the Library/System which scopes and names it " 
        "(value=1), export from the Library/System (value=2), or "
        "both (value=3)."),
       Values {"Unknown", "Import", "Export", "Both Import and Export"} ]
   uint16 Direction;
};


// ===================================================================
// LibraryExchange 
// ===================================================================
   [Association, Description (
     "LibraryExchange indicates that two StorageLibraries are "
     "connected through their InterLibraryPorts.") ]
class CIM_LibraryExchange : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The InterLibraryPort of one StorageLibrary.") ]
   CIM_InterLibraryPort REF Antecedent;
      [Override ("Dependent"), 
       Description ("The InterLibraryPort of the connected Library.") ]
   CIM_InterLibraryPort REF Dependent;
      [Description (
        "Enumeration indicating whether the Antecedent (value=1), "
        "Dependent (value=2), or neither Library (value=3) currently has "
        "access to the Port."), 
       Values {"Unknown", "Antecedent", "Dependent", "Neither"} ]
   uint16 CurrentlyAccessingPort;
};


// ===================================================================
// LabelReader 
// ===================================================================
   [Description (
     "LabelReaders represent hardware capable of scanning or reading "
     "a physical label or the NonVolatileMemory on a PhysicalMedia. "
     "Examples of labels include barcode and OCR tags.") ]
class CIM_LabelReader : CIM_LogicalDevice {
      [Description (
        "An array of enumerated integers describing the formats of "
        "the labels that can be read or scanned by the LabelReader. "
        "The values specified for this property correspond to "
        "those defined for CIM_PhysicalMedia.LabelFormats."), 
       Values {"Barcode", "Radio Frequency Identification", 
               "OCR (Optical Character Recognition)", 
               "MICR (Magnetic Ink Character Recognition)",
               "7 Character Barcode", "9 Character Barcode"},
       ModelCorrespondence {"CIM_PhysicalMedia.LabelFormats"} ]
   uint16 SupportedFormats[];
      [Description (
        "The technology used by the LabelReader. One entry of the "
        "Values array requires some explanation - \"Memory Reader\". "
        "The latter describes the ability to access memory in a Physical"
        "Media's packaging (for example, memory on an AIT tape). The "
        "existence of this Memory is indicated by the MemoryWithMedia "
        "association on the physical side, or by AssociatedMemory on "
        "the logical side."), 
       Values {"Unknown", "Other", "Laser", "Infrared", "RF", 
               "Camera", "Memory Reader"} ]
   uint16 Technology;
};


// ===================================================================
// AssociatedLabelReader
// ===================================================================
   [Association, Description (
     "A LogicalDevice may use or require one or more LabelReaders, to "
     "scan barcodes or otherwise identify entities. This relationship "
     "is described by the AssociatedLabelReader dependency. ") ]
class CIM_AssociatedLabelReader : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The LabelReader.") ]
   CIM_LabelReader REF Antecedent;
      [Override ("Dependent"), Description (
        "The Device that is dependent on the Reader Device.") ]
   CIM_LogicalDevice REF Dependent;
};


// ===================================================================
// PickerLabelReader
// ===================================================================
   [Association, Description (
     "PickerLabelReader is used to indicate that one or more Label"
     "Readers works in conjunction with PickerElements, to identify "
     "PhysicalMedia as they are being picked/placed.") ]
class CIM_PickerLabelReader : CIM_AssociatedLabelReader {
      [Override ("Dependent"), Description (
        "The PickerElement that is dependent on the Reader Device.") ]
   CIM_PickerElement REF Dependent;
};

 
// ===================================================================
// AccessLabelReader
// ===================================================================
   [Association, Description (
     "AccessLabelReader is used to indicate that one or more Label"
     "Readers works in conjunction with MediaAccessDevices, "
     "to identify PhysicalMedia before read/write.") ]
class CIM_AccessLabelReader : CIM_AssociatedLabelReader {
      [Override ("Dependent"),  Description (
        "The MediaAccessDevice that is dependent on the Reader "
        "Device.") ]
   CIM_MediaAccessDevice REF Dependent;
};


// ===================================================================
//
//    Services and Printing
//
// ===================================================================


// ===================================================================
// DeviceServiceImplementation
// ===================================================================
   [Association, Description (
     "An association between a Service and how it is implemented. "
     "The cardinality of this association is many-to-many. "
     "A Service may be provided by more than one Logical"
     "Device, operating in conjunction.  And, any Device may "
     "provide more than one Service.  When multiple Devices are "
     "associated with a single Service, it is assumed that these "
     "elements operate in conjunction to provide the Service.  If "
     "different implementations of a Service exist, each of these "
     "implementations would result in individual instantiations "
     "of the Service object.  These individual instantiations "
     "would then have associations to the unique implementations.") ]
class CIM_DeviceServiceImplementation : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The LogicalDevice.") ]
   CIM_LogicalDevice REF Antecedent;
      [Override ("Dependent"),
       Description ("The Service implemented using the LogicalDevice.") ]
   CIM_Service REF Dependent;
};


// ===================================================================
// DeviceSAPImplementation
// ===================================================================
   [Association, Description (
     "An association between a ServiceAccessPoint and how "
     "it is implemented. The cardinality of this association "
     "is many-to-many.  A SAP may be provided by more "
     "than one LogicalDevice, operating in conjunction.  And, any "
     "Device may provide more than one ServiceAccessPoint. "
     "When many LogicalDevices are associated with a single "
     "SAP, it is assumed that these elements operate in "
     "conjunction to provide the AccessPoint.  If different "
     "implementations of a SAP exist, each of these implementations "
     "would result in individual instantiations of the "
     "ServiceAccessPoint object.  These individual instantiations "
     "would then have associations to the unique implementations.") ]
class CIM_DeviceSAPImplementation : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The LogicalDevice.") ]
   CIM_LogicalDevice REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The ServiceAccessPoint implemented using the LogicalDevice.") ]
   CIM_ServiceAccessPoint REF Dependent;
};


// ===================================================================
// VideoBIOSFeature
// ===================================================================
   [Description (
     "VideoBIOSFeature represents the capabilities of the low-level "
     "software that is used to bring up, configure and use a "
     "ComputerSystem's VideoController and Display.")  ] 
class CIM_VideoBIOSFeature : CIM_SoftwareFeature {
      [Description (
        "An array of integers that specify the features supported by "
        "the VideoBIOS. For example, one could indicate support for "
        "VESA power management (value=6) or video BIOS shadowing (8). "
        "The value, 3, is not valid in the CIM Schema since in DMI it "
        "represents that no BIOS Features are supported.  In this "
        "case, the object should not be instantiated."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9"},
       Values {"Other", "Unknown", "Undefined", "Standard Video BIOS",
               "VESA BIOS Extensions Supported", 
               "VESA Power Management Supported", 
               "VESA Display Data Channel Supported", 
               "Video BIOS Shadowing Allowed", "Video BIOS Upgradeable"},
       ArrayType ("Indexed"), 
       MappingStrings {"MIF.DMTF|Video BIOS Characteristic|001.3"},
       ModelCorrespondence {
        "CIM_VideoBIOSFeature.CharacteristicDescriptions"} ]
   uint16 Characteristics[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the VideoBIOS features indicated in "
        "the Characteristics array. Note, each entry of this array "
        "is related to the entry in the Characteristics array that "
        "is located at the same index."),
       ArrayType ("Indexed"),
       MappingStrings {"MIF.DMTF|Video BIOS Characteristic|001.4"},
       ModelCorrespondence {"CIM_VideoBIOSFeature.Characteristics"} ]
   string CharacteristicDescriptions[];
};


// ===================================================================
// VideoBIOSElement
// ===================================================================
   [Description (
     "VideoBIOSElement represents the low-level software that is "
     "loaded into non-volatile storage and used to bring up, "
     "configure and access a ComputerSystem's VideoController and "
     "Display.") ] 
class CIM_VideoBIOSElement : CIM_SoftwareElement {
      [Override ("Version"),
       MappingStrings {"MIF.DMTF|Video BIOS|001.3"} ]
   string Version;
      [Override ("Manufacturer"),
       MappingStrings {"MIF.DMTF|Video BIOS|001.2"} ]
   string Manufacturer; 
      [Description (
        "If true, indicates that the Video BIOS is shadowed."),
       MappingStrings {"MIF.DMTF|Video BIOS|001.5"} ]
   boolean IsShadowed;
      [Description (
        "Date that this BIOS was released."),
       MappingStrings {"MIF.DMTF|Video BIOS|001.4"} ]
   datetime ReleaseDate;
};


// ===================================================================
// VideoBIOSFeatureVideoBIOSElements
// ===================================================================
   [Association, Aggregation, Description (
     "A link between VideoBIOSFeature and its aggregated "
     "VideoBIOSElements.") ] 
class CIM_VideoBIOSFeatureVideoBIOSElements : 
 CIM_SoftwareFeatureSoftwareElements {
      [Override ("GroupComponent"), Aggregate,
       Description ("The VideoBIOSFeature.") ]
   CIM_VideoBIOSFeature REF GroupComponent;
      [Override ("PartComponent"),
       Description (
        "The VideoBIOSElement that implements the capabilities "
        "described by VideoBIOSFeature.") ]
   CIM_VideoBIOSElement REF PartComponent;
};


// ===================================================================
// DeviceSoftware
// ===================================================================
   [Association, Description (
     "The DeviceSoftware relationship identifies any software that "
     "is associated with a Device - such as drivers, configuration "
     "or application software, or firmware.") ] 
class CIM_DeviceSoftware : CIM_Dependency {
      [Override ("Antecedent"),
       Description ("The SoftwareElement.") ]
   CIM_SoftwareElement REF Antecedent;
      [Override ("Dependent"),
       Description (
        "The LogicalDevice that requires or uses the software.") ]
   CIM_LogicalDevice REF Dependent;
      [Description (
        "An enumerated integer to indicate the role this software "
        "plays in regards to its associated Device. For example, this "
        "software could be instrumentation (value=5) or firmware (6)."),
       Values {"Unknown", "Other", "Driver", "Configuration Software", 
               "Application Software", "Instrumentation", "Firmware",
               "BIOS", "Boot ROM"},
       ModelCorrespondence {"CIM_DeviceSoftware.PurposeDescription"},
       MappingStrings {"MIF.DMTF|SubComponent Software|001.2"}  ]
   uint16 Purpose;
      [Description (
        "A free-form string to provide more information for "
        "the Purpose property, e.g. \"Application Software\"."),
       ModelCorrespondence {"CIM_DeviceSoftware.Purpose"} ] 
   string PurposeDescription;
      [Description (
        "Boolean indicating that the software is 'burned into' or "
        "otherwise located on the hardware of the LogicalDevice.") ]
   boolean LoadedOnDevice; 
      [Description (
        "Boolean indicating whether the software is upgradeable, "
        "when it is LoadedOnDevice. Software that is loaded as "
        "part of the OperatingSystem is typically changeable and "
        "upgradeable. However, when DeviceSoftware is burned into "
        "EEPROM or a chip that Realizes the LogicalDevice, then "
        "it may not be upgradeable. This property indicates the "
        "ability to update and upgrade DeviceSoftware.") ]
   boolean UpgradeableOnDevice;
};


// ===================================================================
// Printer
// ===================================================================
   [Description (
     "Capabilities and management of the Printer LogicalDevice.") ] 
class CIM_Printer : CIM_LogicalDevice {   
      [Description (
        "Status information for a Printer, beyond that specified "
        "in the LogicalDevice Availability property. Values include "
        "\"Idle\" (3) and an indication that the Device is currently "
        "printing (4)."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7"},
       Values {"Other", "Unknown", "Idle", "Printing", "Warmup",
               "Stopped Printing", "Offline"},
       MappingStrings {"MIB.IETF|Printer-MIB.hrPrinterStatus"} ]
   uint16 PrinterStatus;
      [Description ("Printer error information."),
       Values {"Unknown", "Other", "No Error", "Low Paper", 
               "No Paper", "Low Toner", 
               "No Toner", "Door Open", "Jammed", "Offline", 
               "Service Requested", "Output Bin Full"}, 
       ModelCorrespondence {"CIM_Printer.ErrorInformation"}, 
       MappingStrings {
        "MIB.IETF|Printer-MIB.hrPrinterDetectedErrorState"} ]
   uint16 DetectedErrorState;
      [Description (
        "An array providing supplemental information for the "
        "current error state, indicated in DetectedErrorState."),
       ModelCorrespondence {"CIM_Printer.DetectedErrorState"} ]
   string ErrorInformation[];
      [Description (
        "An integer array indicating the types of paper supported."),
       Values {"Unknown", "Other", "A", "B", "C", "D", "E", 
               "Letter", "Legal", "NA-10x13-Envelope", "NA-9x12-Envelope", 
               "NA-Number-10-Envelope", "NA-7x9-Envelope", 
               "NA-9x11-Envelope", "NA-10x14-Envelope",
               "NA-Number-9-Envelope", "NA-6x9-Envelope",
               "NA-10x15-Envelope", "A0", "A1", "A2", "A3", "A4", "A5",
               "A6", "A7", "A8", "A9" "A10", "B0", "B1", "B2", "B3", "B4",
               "B5", "B6", "B7", "B8", "B9", "B10", "C0", "C1", "C2" "C3",
               "C4", "C5", "C6", "C7", "C8", "ISO-Designated", "JIS B0",
               "JIS B1", "JIS B2", "JIS B3", "JIS B4", "JIS B5", "JIS B6",
               "JIS B7", "JIS B8", "JIS B9", "JIS B10", 
               "NA-Letter", "NA-Legal", "B4-Envelope", "B5-Envelope", 
               "C3-Envelope", "C4-Envelope", "C5-Envelope", "C6-Envelope", 
               "Designated-Long-Envelope", "Monarch-Envelope", 
               "Executive", "Folio", "Invoice", "Ledger", "Quarto"} ]
   uint16 PaperSizesSupported[];
      [Description (
        "An array of free-form strings specifying the types of "
        "paper that are currently available on the Printer. Each "
        "string should be expressed in the form specified by "
        "ISO/IEC 10175 Document Printing Application (DPA) which "
        "is also summarized in Appendix C of RFC 1759 (Printer MIB). "
        "Examples of valid strings are \"iso-a4-colored\" and "
        "\"na-10x14-envelope\". By definition a paper size that "
        "is available and listed in PaperTypesAvailable should "
        "also appear in the PaperSizesSupported property."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_PrintJob.RequiredPaperType", 
        "CIM_PrintService.PaperTypesAvailable"}, 
       MappingStrings {"MIB.IETF|Printer-MIB.prtInputMediaName"} ]
   string PaperTypesAvailable[];
      [Description (
        "Specifies the paper type that the Printer will use if a "
        "PrintJob does not specify a particular type. The string "
        "should be expressed in the form specified by ISO/IEC "
        "10175 Document Printing Application (DPA) which is also "
        "summarized in Appendix C of RFC 1759 (Printer MIB)."), 
       ModelCorrespondence {"CIM_Printer.PaperTypesAvailable"} ]
   string DefaultPaperType;
      [Description (
        "Specifies the paper type that the Printer is currently "
        "using. The string should be expressed in the form specified "
        "by ISO/IEC 10175 Document Printing Application (DPA) which "
        "is also summarized in Appendix C of RFC 1759 (Printer MIB)."), 
       ModelCorrespondence {"CIM_Printer.PaperTypesAvailable"} ]
   string CurrentPaperType;
      [Description (
        "An array indicating the print languages natively supported."),
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "13", "14", "15", "16", "17", "18", "19",
                 "20", "21", "22", "23", "24", "25", "26", "27", "28", 
                 "29", "30", "31", "32", "33", "34", "35", "36", "37", 
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", "47"},
       Values {"Other", "Unknown", "PCL", "HPGL", "PJL", "PS",
               "PSPrinter", "IPDS", "PPDS", "EscapeP", "Epson", "DDIF", 
               "Interpress", "ISO6429", "Line Data", "MODCA", "REGIS", 
               "SCS", "SPDL", "TEK4014", "PDS", "IGP", "CodeV", "DSCDSE", 
               "WPS", "LN03", "CCITT", "QUIC", "CPAP", "DecPPL", 
               "Simple Text", "NPAP", "DOC", "imPress", "Pinwriter",
               "NPDL", "NEC201PL", "Automatic", "Pages", "LIPS", "TIFF", 
               "Diagnostic", "CaPSL", "EXCL", "LCDS", "XES", "MIME"},
       MappingStrings {"MIB.IETF|Printer-MIB.prtInterpreterLangFamily"},
       ModelCorrespondence {"CIM_Printer.MimeTypesSupported", 
        "CIM_PrintJob.Language", 
        "CIM_PrintService.LanguagesSupported"} ]
   uint16 LanguagesSupported[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations of any mime types that are supported by "
        "the Printer. If data is provided for this property, then "
        "the value 47, \"Mime\", should be included in the Languages"
        "Supported property."), 
       ModelCorrespondence {"CIM_Printer.LanguagesSupported", 
        "CIM_PrintJob.MimeTypes", 
        "CIM_PrintService.MimeTypesSupported"} ]
   string MimeTypesSupported[];
      [Description (
        "Indicates the current printer language being used. A "
        "language that is being used by the Printer should also be "
        "listed in LanguagesSupported."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "13", "14", "15", "16", "17", "18", "19",
                 "20", "21", "22", "23", "24", "25", "26", "27", "28", 
                 "29", "30", "31", "32", "33", "34", "35", "36", "37", 
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", 
                 "47"},
       Values {"Other", "Unknown", "PCL", "HPGL", "PJL", "PS",
               "PSPrinter", "IPDS", "PPDS", "EscapeP", "Epson", "DDIF", 
               "Interpress", "ISO6429", "Line Data", "MODCA", "REGIS", 
               "SCS", "SPDL", "TEK4014", "PDS", "IGP", "CodeV", "DSCDSE", 
               "WPS", "LN03", "CCITT", "QUIC", "CPAP", "DecPPL", 
               "Simple Text", "NPAP", "DOC", "imPress", "Pinwriter",
               "NPDL", "NEC201PL", "Automatic", "Pages", "LIPS", "TIFF", 
               "Diagnostic", "CaPSL", "EXCL", "LCDS", "XES", "MIME"},
       ModelCorrespondence {"CIM_Printer.LanguagesSupported", 
        "CIM_Printer.CurrentMimeType"} ]
   uint16 CurrentLanguage;
      [Description (
        "Specifies the mime type currently being used by the "
        "Printer if the CurrentLanguage is set to indicate a "
        "mime type is in use (value = 47)."), 
       ModelCorrespondence {"CIM_Printer.CurrentLanguage"} ]
   string CurrentMimeType;
      [Description (
        "Indicates the default printer language. A language that "
        "is used as a default by the Printer should also be listed "
        "in LanguagesSupported."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
                 "11", "12", "13", "14", "15", "16", "17", "18", "19",
                 "20", "21", "22", "23", "24", "25", "26", "27", "28", 
                 "29", "30", "31", "32", "33", "34", "35", "36", "37", 
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", 
                 "47"},
       Values {"Other", "Unknown", "PCL", "HPGL", "PJL", "PS",
               "PSPrinter", "IPDS", "PPDS", "EscapeP", "Epson", "DDIF", 
               "Interpress", "ISO6429", "Line Data", "MODCA", "REGIS", 
               "SCS", "SPDL", "TEK4014", "PDS", "IGP", "CodeV", "DSCDSE", 
               "WPS", "LN03", "CCITT", "QUIC", "CPAP", "DecPPL", 
               "Simple Text", "NPAP", "DOC", "imPress", "Pinwriter",
               "NPDL", "NEC201PL", "Automatic", "Pages", "LIPS", "TIFF", 
               "Diagnostic", "CaPSL", "EXCL", "LCDS", "XES", "MIME"},
       ModelCorrespondence {"CIM_Printer.LanguagesSupported", 
        "CIM_Printer.DefaultMimeType"} ]
   uint16 DefaultLanguage;
      [Description (
        "Specifies the default mime type used by the Printer if the "
        "DefaultLanguage is set to indicate a mime type is in use "
        "(value=47)."), 
       ModelCorrespondence {"CIM_Printer.DefaultLanguage"} ]
   string DefaultMimeType;
      [Description (
        "Printer jobs processed since last reset.  These jobs may be "
        "processed from one or more PrintQueues."), 
       Counter ] 
   uint32 JobCountSinceLastReset;
      [Description ("Time of last reset of the Printer Device.") ]
   datetime TimeOfLastReset;
      [Description (
        "An array of integers indicating Printer capabilities. "
        "Information such as \"Duplex Printing\" (value=3) or "
        "\"Transparency Printing\" (7) is specified in this "
        "property."),
     ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Color Printing", 
               "Duplex Printing", "Copies", "Collation", "Stapling", 
               "Transparency Printing", "Punch", "Cover", "Bind", 
               "Black and White Printing", "One Sided", 
               "Two Sided Long Edge", "Two Sided Short Edge", 
               "Portrait", "Landscape", "Reverse Portrait", 
               "Reverse Landscape", "Quality High", "Quality Normal", 
               "Quality Low"}, 
       ModelCorrespondence {"CIM_Printer.CapabilityDescriptions", 
        "CIM_PrintJob.Finishing", 
        "CIM_PrintService.Capabilities"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the Printer features indicated in "
        "the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."),
       ArrayType ("Indexed"),
     ModelCorrespondence {"CIM_Printer.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Specifies which finishings and other capabilities of "
        "the Printer will be used by default. An entry in Default"
        "Capabilities should also be listed in the Capabilities "
        "array."), 
       Values {"Unknown", "Other", "Color Printing", 
               "Duplex Printing", "Copies", "Collation", "Stapling", 
               "Transparency Printing", "Punch", "Cover", "Bind", 
               "Black and White Printing", "One Sided", 
               "Two Sided Long Edge", "Two Sided Short Edge", 
               "Portrait", "Landscape", "Reverse Portrait", 
               "Reverse Landscape", "Quality High", "Quality Normal", 
               "Quality Low"}, 
       ModelCorrespondence {"CIM_Printer.Capabilities"} ]
   uint16 DefaultCapabilities[];
      [Description (
        "Specifies which finishings and other capabilities of "
        "the Printer are currently being used. An entry in this "
        "property should also be listed in the Capabilities array."), 
       Values {"Unknown", "Other", "Color Printing", 
               "Duplex Printing", "Copies", "Collation", "Stapling", 
               "Transparency Printing", "Punch", "Cover", "Bind", 
               "Black and White Printing", "One Sided", 
               "Two Sided Long Edge", "Two Sided Short Edge", 
               "Portrait", "Landscape", "Reverse Portrait", 
               "Reverse Landscape", "Quality High", "Quality Normal", 
               "Quality Low"}, 
       ModelCorrespondence {"CIM_Printer.Capabilities"} ]
   uint16 CurrentCapabilities[];
      [Description (
        "The maximum number of copies that can be produced by "
        "the Printer from a single Job."), 
       ModelCorrespondence {"CIM_PrintJob.Copies"} ]
   uint32 MaxCopies;
      [Description (
        "The number of copies that will be produced for a "
        "single Job unless otherwise specified.") ]
   uint32 DefaultCopies;
      [Description (
        "The maximum number of print-stream pages that the "
        "Printer can render onto a single media sheet."), 
       ModelCorrespondence {"CIM_PrintJob.NumberUp"} ]
   uint32 MaxNumberUp;
      [Description (
        "The number of print-stream pages that the Printer will "
        "render onto a single media sheet unless a Job specifies "
        "otherwise.") ]
   uint32 DefaultNumberUp;
      [Description (
        "Printer's horizontal resolution in Pixels per Inch."),
       Units ("Pixels per Inch"), 
       ModelCorrespondence {"CIM_PrintJob.HorizontalResolution"} ]
   uint32 HorizontalResolution;
      [Description (
        "Printer's vertical resolution in Pixels per Inch."),
       Units ("Pixels per Inch"),
       ModelCorrespondence {"CIM_PrintJob.HorizontalResolution"} ]
   uint32 VerticalResolution;
      [Description (
        "Identifies the available character sets for the output "
        "of text related to managing the Printer. Strings "
        "provided in this property should conform to the "
        "semantics and syntax specified by section 4.1.2 "
        "(\"Charset parameter\") in RFC 2046 (MIME Part 2) and "
        "contained in the IANA character-set registry. Examples "
        "include \"utf-8\", \"us-ascii\" and \"iso-8859-1\"."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_PrintJob.CharSet"}, 
       MappingStrings {
        "MIB.IETF|Printer-MIB.prtLocalizationCharacterSet"} ]
   string CharSetsSupported[];
      [Description (
        "Specifies the current character set being used for "
        "the output of text relating to management of the "
        "Printer. The character set described by this property "
        "should also be listed in CharsetsSupported. The string "
        "specified by this property should conform to the "
        "semantics and syntax specified by section 4.1.2 "
        "(\"Charset parameter\") in RFC 2046 (MIME Part 2) and "
        "contained in the IANA character-set registry. Examples "
        "include \"utf-8\", \"us-ascii\" and \"iso-8859-1\"."), 
       ModelCorrespondence {"CIM_Printer.CharSetsSupported"} ]
   string CurrentCharSet;
      [Description (
        "Identifies the available languages for strings used by "
        "the Printer for the output of management information. "
        "The strings should conform to RFC 1766, for example "
        "\"en\" is used for English."), 
       ArrayType ("Indexed"), 
       MappingStrings {
           "MIB.IETF|Printer-MIB.prtLocalizationLanguage"}, 
       ModelCorrespondence {"CIM_PrintJob.NaturalLanguage"} ]
   string NaturalLanguagesSupported[];
      [Description (
        "Identifies the current language being used by the "
        "Printer for management. The language listed in the "
        "CurrentNaturalLanguage property should also be listed "
        "in NaturalLanguagesSupported."), 
       ModelCorrespondence {"CIM_Printer.NaturalLanguagesSupported"} ]
   string CurrentNaturalLanguage;
      [Description (
        "Specifies the largest Job (as a byte stream) that the "
        "Printer will accept in units of Kbytes. A value of zero "
        "indicates that no limit has been set."), 
       Units ("KiloBytes"), 
       ModelCorrespondence {"CIM_PrintJob.JobSize"} ]
   uint32 MaxSizeSupported;
      [Description (
        "Describes all of the job sheets that are available on "
        "the Printer. This can also be used to describe the banner "
        "that a Printer might provide at the beginning of each Job, "
        "or can describe other user specified options."), 
       ModelCorrespondence {"CIM_PrintJob.RequiredJobSheets"} ]
   string AvailableJobSheets[];
      [Description (
        "Specifies the marking technology used by the Printer."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", 
                 "10", "11", "12", "13", "14", "15", "16", "17", 
                 "18", "19", "20", "21", "22", "23", "24", "25", 
                 "26", "27"}, 
       Values {"Other", "Unknown", "Electrophotographic LED", 
               "Electrophotographic Laser",  
               "Electrophotographic Other", 
               "Impact Moving Head Dot Matrix 9pin", 
               "Impact Moving Head Dot Matrix 24pin", 
               "Impact Moving Head Dot Matrix Other", 
               "Impact Moving Head Fully Formed", 
               "Impact Band", "Impact Other", "Inkjet Aqueous", 
               "Inkjet Solid", "Inkjet Other", "Pen", 
               "Thermal Transfer", "Thermal Sensitive", 
               "Thermal Diffusion", "Thermal Other", 
               "Electroerosion", "Electrostatic", 
               "Photographic Microfiche", 
               "Photographic Imagesetter", "Photographic Other", 
               "Ion Deposition", "eBeam", "Typesetter"}, 
       MappingStrings {"MIB.IETF|Printer-MIB.prtMarkerMarkTech"} ]
   uint16 MarkingTechnology;
};


// ===================================================================
// PrintQueue 
// ===================================================================
   [Description (
     "Capabilities and management of a Printer Queue. A PrintQueue "
     "holds PrintJobs - which are placed on the Queue by a Print"
     "Service. Jobs can move from Queue to Queue.") ]
class CIM_PrintQueue : CIM_JobDestination {
      [Description (
        "Indicates that Jobs on the Queue will be passed to a "
        "Printer. When FALSE, a Job will remain on the Queue and "
        "will not be passed to a Printer for output.") ]
   boolean QueueEnabled;
      [Description (
        "When FALSE, no PrintService can place PrintJobs on the "
        "PrintQueue. The ability of an individual PrintService "
        "to place a Job on the Queue can be specified using the "
        "QueueAcceptingFromService property in the QueueForPrint"
        "Service association.") ]
   boolean QueueAccepting;
      [Description ("The current number of Jobs on the Queue."),
       Gauge ]
   uint32 NumberOnQueue;
      [Description (
        "Gives Queue-specific status information, beyond the "
        "ManagedSystemElement.Status property. This may be used to "
        "provide further qualification as to the status of the "
        "Queue or to indicate a secondary condition (e.g. spool "
        "area is full)."), 
       Values {"Other", "Unknown", "No Additional Status", 
               "QueueSpoolAreaFull"} ]
   uint16 QueueStatus;
      [Description (
        "Provides a textual explanation for the status of the Queue. "
        "The settings of both QueueStatus and the Status property "
        "inherited from ManagedSystemElement may be described by "
        "QueueStatusInfo. For example, if \"Stopping\" is the value "
        "assigned to Status, then this property may contain an "
        "explanation as to why the Queue is being stopped.") ]
   string QueueStatusInfo;
      [Description (
        "Specifies the largest possible Job (in terms of a single "
        "byte stream) that may be submitted to this Queue. A value "
        "of zero indicates that no limit has been set. Units "
        "are Kbytes."), 
       Units ("KiloBytes"), 
       ModelCorrespondence {"CIM_PrintJob.JobSize"} ]
   uint32 MaxJobSize;
      [Description (
        "Specifies the priority that will be assigned to a new Job "
        "being submitted to this Queue, if the Job does not "
        "explicitly specify a priority. The range of valid priorities "
        "and the interpretation of priorities may be determined from "
        "the JobPriorityHigh and JobPriorityLow properties."), 
       ModelCorrespondence {"CIM_PrintQueue.JobPriorityHigh", 
        "CIM_PrintQueue.JobPriorityLow"} ]
   uint32 DefaultJobPriority;
      [Description (
        "Specifies the numeric value that is used to represent the "
        "highest priority Jobs that are submitted to this Queue. The "
        "range of numeric values for priority may be inversed, e.g. "
        "a high priority job is represented by a low integer value. "
        "This is indicated by JobPriorityLow being greater than "
        "JobPriorityHigh. If both values (PriorityLow and Priority"
        "High) are assigned to zero, then the Queue does not support "
        "Job priorities."), 
       ModelCorrespondence {"CIM_PrintQueue.JobPriorityLow", 
        "CIM_Job.Priority"} ]
   uint32 JobPriorityHigh;
      [Description (
        "Specifies the numeric value that is used to represent the "
        "lowest priority Jobs that are submitted to this Queue. The "
        "range of numeric values for priority may be inversed, e.g. "
        "a low priority job is represented by a high integer value. "
        "This is indicated by JobPriorityLow being greater than "
        "JobPriorityHigh. If both values (PriorityLow and PriorityHigh) "
        "are assigned to zero, then the Queue does not support "
        "Job priorities."), 
       ModelCorrespondence {"CIM_PrintQueue.JobPriorityHigh", 
        "CIM_Job.Priority"} ]
   uint32 JobPriorityLow;
      [Description (
        "Specifies the job sheets that are supported by this Queue. "
        "Typically the job sheets provided by a Queue will be the "
        "union or aggregation of those provided by all the Printers "
        "that it supports. However, a system administrator may choose "
        "to restrict access to some job sheets on a particular Queue. "
        "A Queue might also support additional job sheets through the "
        "use of a filter that adds a banner or some other page when a "
        "Job is taken from the Queue."), 
       ModelCorrespondence {"CIM_PrintJob.RequiredJobSheets"} ]
   string AvailableJobSheets[];
};


// ===================================================================
// PrintJob
// ===================================================================
   [Description (
     "Description of a print request that is either waiting on a "
     "Queue for a Printer to become available, in the process of "
     "being output on a Printer, or that has previously been "
     "printed on a Printer. PrintJobs are weak to their current "
     "Queue, or to the last Queue that held them.") ]
class CIM_PrintJob : CIM_Job {
      [Propagated ("CIM_PrintQueue.SystemCreationClassName"), 
       Key, MaxLen (256),
       Description ("The scoping System's CreationClassName.") ]
   string SystemCreationClassName;
      [Propagated ("CIM_PrintQueue.SystemName"), 
       Key, MaxLen (256),
       Description ("The scoping System's Name.") ] 
   string SystemName;
      [Propagated ("CIM_PrintQueue.CreationClassName"), 
       Key, MaxLen (256),
       Description ("The scoping Queue's CreationClassName.") ]
   string QueueCreationClassName;
      [Propagated ("CIM_PrintQueue.Name"), 
       Key, MaxLen (256),
       Description ("The scoping Queue's Name.") ]
   string QueueName;
      [Override("JobStatus"), 
       Description (
        "The inherited JobStatus is used to provide additional "
        "information about the status of a PrintJob beyond that "
        "enumerated by PrintJobStatus."), 
       ModelCorrespondence {"CIM_PrintJob.PrintJobStatus"} ]
   string JobStatus;
      [Key, Description (
        "Uniquely identifies this Job within its scoping Queue.")]
   string JobID;
      [Description (
        "Provides additional textual descriptions of how this "
        "Job should be scheduled.") ]
   string SchedulingInformation;
      [Description (
        "Specifies the size of the PrintJob (as a byte stream) in "
        "units of Kbytes."), 
       Units ("KiloBytes"), 
       ModelCorrespondence {"CIM_Printer.MaxSizeSupported", 
        "CIM_PrintQueue.MaxJobSize"} ]
   uint32 JobSize;
      [Description (
        "Specifies the print language used by this Job."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
                 "11", "12", "13", "14", "15", "16", "17", "18", "19", 
                 "20", "21", "22", "23", "24", "25", "26", "27", "28", 
                 "29", "30", "31", "32", "33", "34", "35", "36", "37", 
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", 
                 "47"},
       Values {"Other", "Unknown", "PCL", "HPGL", "PJL", "PS",
               "PSPrinter", "IPDS", "PPDS", "EscapeP", "Epson", "DDIF", 
               "Interpress", "ISO6429", "Line Data", "MODCA", "REGIS", 
               "SCS", "SPDL", "TEK4014", "PDS", "IGP", "CodeV", "DSCDSE", 
               "WPS", "LN03", "CCITT", "QUIC", "CPAP", "DecPPL", 
               "Simple Text", "NPAP", "DOC", "imPress", "Pinwriter",
               "NPDL", "NEC201PL", "Automatic", "Pages", "LIPS", "TIFF", 
               "Diagnostic", "CaPSL", "EXCL", "LCDS", "XES", "MIME"}, 
       ArrayType ("Indexed"), 
       MappingStrings {"MIB.IETF|Printer-MIB.prtInterpreterLangFamily"}, 
       ModelCorrespondence {"CIM_Printer.LanguagesSupported", 
        "CIM_PrintService.LanguagesSupported", 
        "CIM_PrintJob.MimeTypes"} ]
   uint16 Language;
      [Description (
        "Specifies the mime types used by the PrintJob if "
        "Language is set to indicate a mime type is in use (value=47)."), 
       ModelCorrespondence {"CIM_PrintJob.Language", 
        "CIM_Printer.MimeTypesSupported", 
        "CIM_PrintService.MimeTypesSupported"} ]
   string MimeTypes[];
      [Description (
        "A string specifying the type of paper that is required by "
        "this PrintJob. Each string should be expressed in the form "
        "specified by ISO/IEC 10175 Document Printing Application (DPA) "
        "which is also summarized in Appendix C of RFC 1759 (Printer "
        "MIB). Examples of valid strings are \"iso-a4-colored\" and "
        "\"na-10x14-envelope\"."), 
       ModelCorrespondence {"CIM_Printer.PaperTypesAvailable", 
        "CIM_PrintService.PaperTypesAvailable"} ]
   string RequiredPaperType;
      [Description (
        "An array of integers indicating the type of finishing "
        "required by this Job. It is equivalent to the Capabilities "
        "property provided by the Printer."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Color Printing", 
               "Duplex Printing", "Copies", "Collation", "Stapling", 
               "Transparency Printing", "Punch", "Cover", "Bind", 
               "Black and White Printing", "One Sided", 
               "Two Sided Long Edge", "Two Sided Short Edge", 
               "Portrait", "Landscape", "Reverse Portrait", 
               "Reverse Landscape", "Quality High", "Quality Normal", 
               "Quality Low"}, 
       ModelCorrespondence {"CIM_Printer.Capabilities", 
        "CIM_PrintService.Capabilities"} ]
   uint16 Finishing[];
      [Description (
        "The number of physical copies of the output that will be "
        "produced from this Job."), 
       ModelCorrespondence {"CIM_Printer.MaxCopies"} ]
   uint32 Copies;
      [Description (
        "The horizontal resolution in Pixels per Inch for the Job."), 
       Units ("Pixels per Inch"), 
       ModelCorrespondence {"CIM_Printer.HorizontalResolution"} ]
   uint32 HorizontalResolution;
      [Description (
        "The vertical resolution in Pixels per Inch for the Job."), 
       Units ("Pixels per Inch"), 
       ModelCorrespondence {"CIM_Printer.VerticalResolution"} ]
   uint32 VerticalResolution;
      [Description (
        "Specifies the character set and encoding method that "
        "should be used by the Printer for the management of "
        "this Job. The strings should conform to the semantics and "
        "syntax specified by section 4.1.2 (\"Charset parameter\") "
        "in RFC 2046 (MIME Part 2) and contained in the IANA "
        "character-set registry. Examples include \"utf-8\", "
        "\"us-ascii\" and \"iso-8859-1\"."), 
       ModelCorrespondence {"CIM_Printer.CharSetsSupported"} ]
   string CharSet;
      [Description (
        "Identifies the language that should be used by the Printer "
        "for the management of this Job. The specified value should "
        "conform to RFC 1766. For example, \"en\" is used for "
        "English."), 
       ModelCorrespondence {"CIM_Printer.NaturalLanguagesSupported"} ]
   string NaturalLanguage;
      [Description (
        "The number of print-stream pages that should be rendered "
        "onto a single media sheet when the Printer outputs this "
        "PrintJob."), 
       ModelCorrespondence {"CIM_Printer.MaxNumberUp"} ]
   uint32 NumberUp;
      [Description (
        "Describes the current state of this Job with respect "
        "to the PrintQueue and the Printer. Additional information "
        "may be specified in JobStatus."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7"}, 
       Values {"Other", "Unknown", "Pending", "Blocked", 
               "Complete", "Completed With Error", "Printing"}, 
       ModelCorrespondence {"CIM_PrintJob.TimeCompleted", 
        "CIM_PrintJob.JobStatus"} ]
   uint16 PrintJobStatus;
      [Description (
        "Time when this Job was completed. This value is only "
        "valid if the PrintJobStatus has been assigned to "
        "\"Complete\" (value=5) or \"Completed With Error\" "
        "(value=6)."), 
       ModelCorrespondence {"CIM_PrintJob.PrintJobStatus"} ]
   datetime TimeCompleted;
      [Description (
        "Describes the job sheets that should be used when this "
        "Job is output on the Printer."), 
       ModelCorrespondence {"CIM_Printer.AvailableJobSheets"} ]
   string RequiredJobSheets[];
      [Description (
        "Provides additional information, beyond Job Owner "
        "inherited from CIM_Job, to identify the origins of the "
        "PrintJob. This property could include information such as "
        "the System, application or Process that created the Job.") ]
   string JobOrigination;
};


// ===================================================================
// PrintSAP
// ===================================================================
   [Description ("The ServiceAccessPoint for a printing Service.") ]
class CIM_PrintSAP : CIM_ServiceAccessPoint {
      [Description (
        "Specifies the print procotols that this AccessPoint uses. "
        "Note that each entry of this array is related to the entry in "
        "the PrintProtocolInfo array that is located at the same "
        "index."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "SMB", "BSD", "SYSV","HPNP", "IPP", 
               "Local"}, 
       ModelCorrespondence {"CIM_PrintSAP.PrintProtocolInfo"} ]
   uint16 PrintProtocol[];
      [Description (
        "Provides clarifying or additional information about the "
        "protocols supported by this AccessPoint. Note, each entry "
        "of this array is related to the entry in the PrintProtocol "
        "array that is located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_PrintSAP.PrintProtocol"} ]
   string PrintProtocolInfo[];
};


// ===================================================================
// PrintService
// ===================================================================
   [Description (
     "The Service that provides support for printing. The basic "
     "assumption of the Printing Model is that a PrintService accepts "
     "a PrintJob for processing, via its PrintSAP. The Job is then "
     "placed on a PrintQueue (indicated by the QueueForPrintService "
     "association). Printers take Jobs from Queues (indicated by the "
     "PrinterServicingQueue association).") ]
class CIM_PrintService : CIM_Service {
      [Description (
        "An array of free-form strings specifying the types of "
        "paper that may be used by Jobs that are submitted to this "
        "PrintService. This may be different than the paper types that "
        "are installed on the Printer, because the PrintService may "
        "include support for manually making other types available or "
        "only a subset of paper types may be exported via this Service. "
        "Each string should be expressed in the form specified by "
        "ISO/IEC 10175 Document Printing Application (DPA) which is "
        "also summarized in Appendix C of RFC 1759 (Printer MIB). "
        "Examples of valid strings are \"iso-a4-colored\" and "
        "\"na-10x14-envelope\"."), 
       ModelCorrespondence {"CIM_Printer.PaperTypesAvailable", 
        "CIM_PrintJob.RequiredPaperType"} ]
   string PaperTypesAvailable[];
      [Description (
        "An array indicating the print languages supported by the "
        "PrintService. A PrintService may support more languages "
        "than those available on the underlying Printer through the "
        "use of filters. An administrator may also choose to prevent "
        "some languages from being exported by the PrintService."), 
       ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
                 "11", "12", "13", "14", "15", "16", "17", "18", "19", 
                 "20", "21", "22", "23", "24", "25", "26", "27", "28", 
                 "29", "30", "31", "32", "33", "34", "35", "36", "37", 
                 "38", "39", "40", "41", "42", "43", "44", "45", "46", 
                 "47"},
       Values {"Other", "Unknown", "PCL", "HPGL", "PJL", "PS",
               "PSPrinter", "IPDS", "PPDS", "EscapeP", "Epson", "DDIF", 
               "Interpress", "ISO6429", "Line Data", "MODCA", "REGIS", 
               "SCS", "SPDL", "TEK4014", "PDS", "IGP", "CodeV", "DSCDSE", 
               "WPS", "LN03", "CCITT", "QUIC", "CPAP", "DecPPL", 
               "Simple Text", "NPAP", "DOC", "imPress", "Pinwriter",
               "NPDL", "NEC201PL", "Automatic", "Pages", "LIPS", "TIFF", 
               "Diagnostic", "CaPSL", "EXCL", "LCDS", "XES", "MIME"}, 
       ArrayType ("Indexed"), 
       MappingStrings {"MIB.IETF|Printer-MIB.prtInterpreterLangFamily"}, 
       ModelCorrespondence {"CIM_Printer.LanguagesSupported", 
        "CIM_PrintJob.Language", 
        "CIM_PrintService.MimeTypesSupported"} ]
   uint16 LanguagesSupported[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any mime types that are supported by "
        "the PrintService. Support for mime types is indicated "
        "by specifying a value of 47 in the LanguagesSupported array."), 
       ModelCorrespondence {"CIM_Printer.MimeTypesSupported", 
        "CIM_PrintJob.MimeTypes", 
        "CIM_PrintService.LanguagesSupported"} ]
   string MimeTypesSupported[];
      [Description (
        "An array of integers indicating the capabilities supported "
        "by this service. Information such as \"Duplex Printing\" "
        "(value=3) or \"Transparency Printing\" (7) is specified in "
        "this property."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Color Printing", "Duplex Printing", 
               "Copies", "Collation", "Stapling", "Transparency Printing", 
               "Punch", "Cover", "Bind", "Black and White Printing", 
               "One Sided", "Two Sided Long Edge", "Two Sided Short Edge", 
               "Portrait", "Landscape", "Reverse Portrait", 
               "Reverse Landscape", "Quality High", "Quality Normal", 
               "Quality Low"}, 
       ModelCorrespondence {"CIM_Printer.Capabilities", 
        "CIM_PrintJob.Finishing", 
        "CIM_PrintService.CapabilityDescriptions"} ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the Printer features indicated in "
        "the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."), 
       ArrayType ("Indexed"), 
       ModelCorrespondence {"CIM_PrintService.Capabilities"} ]
   string CapabilityDescriptions[];
      [Description (
        "Describes the filters that are available within this Print"
        "Service. For example, a PrintService may be able to convert "
        "a Job submitted in one page description language to another, "
        "so that it can be passed to an available Printer.") ]
   string AvailableFilters[];
};


// ===================================================================
// PrinterServicingQueue 
// ===================================================================
   [Association, Description (
     "This association indicates that a Printer can be passed "
     "PrintJobs from a particular Queue.") ]
class CIM_PrinterServicingQueue : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "A destination Printer for Jobs enqueued on the Dependent "
        "Queue.") ]
   CIM_Printer REF Antecedent;
      [Override ("Dependent"), Description (
        "A Queue that is providing Jobs to the Printer.") ]
   CIM_PrintQueue REF Dependent;
};


// ===================================================================
// PrinterServicingJob 
// ===================================================================
   [Association, Description (
     "This association indicates that a Printer is currently "
     "servicing a particular PrintJob.") ]
class CIM_PrinterServicingJob : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The destination Printer for a PrintJob.") ]
   CIM_Printer REF Antecedent;
      [Override ("Dependent"), Description ("The PrintJob.") ]
   CIM_PrintJob REF Dependent;
};


// ===================================================================
// PrintJobFile 
// ===================================================================
   [Association, Aggregation, Description (
     "This association indicates which files are associated with "
     "a PrintJob.") ]
class CIM_PrintJobFile : CIM_Component {
      [Override ("GroupComponent"), Aggregate,
       Description ("The PrintJob that is based on one or more Files.") ]
   CIM_PrintJob REF GroupComponent;
      [Override ("PartComponent"), 
       Description ("The File(s) that make up a PrintJob.") ]
   CIM_DataFile REF PartComponent;
};


// ===================================================================
// QueueForPrintService 
// ===================================================================
   [Association, Description (
     "This association indicates that a PrintService utilizes a "
     "particular PrintQueue.") ]
class CIM_QueueForPrintService : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The PrintQueue that the Service utilizes.") ]
   CIM_PrintQueue REF Antecedent;
      [Override ("Dependent"), 
       Description ("The PrintService that puts Jobs on the Queue.") ]
   CIM_PrintService REF Dependent;
      [Description (
        "Indicates that the PrintService can accept Jobs and "
        "place them on the Queue.") ]
   boolean QueueAcceptingFromService;
};


// ===================================================================
// QueueForwardsToPrintSAP 
// ===================================================================
   [Association, Description (
     "This association indicates that the Jobs from a PrintQueue "
     "can be sent to the referenced PrintSAP, to be handled by the "
     "SAP's backing PrintService.") ]
class CIM_QueueForwardsToPrintSAP : CIM_Dependency {
      [Override ("Antecedent"), 
       Description ("The PrintSAP for the PrintService.") ]
   CIM_PrintSAP REF Antecedent;
      [Override ("Dependent"), 
       Description ("The PrintQueue that forwards Jobs to the SAP.") ]
   CIM_PrintQueue REF Dependent;
};


// ===================================================================
// OwningPrintQueue 
// ===================================================================
   [Association, Description (
     "This association indicates which Queue holds a PrintJob and "
     "where the Job is located within that Queue. A Job may remain on "
     "its final Queue once it has been printed with a PrintJobStatus "
     "of \"Complete\" or \"Completed With Error\".") ]
class CIM_OwningPrintQueue : CIM_JobDestinationJobs {
      [Override ("Antecedent"), Min(1), Max(1),
       Description ("The PrintQueue on which the Job is held.") ]
   CIM_PrintQueue REF Antecedent;
      [Override ("Dependent"), Weak,
       Description ("The PrintJob.") ]
   CIM_PrintJob REF Dependent;
      [Description (
        "The position of the PrintJob on the Queue. The top of the "
        "Queue is indicated by a value of 1 with higher values being "
        "used to represent Jobs that are further away from the top of "
        "the Queue. A QueuePosition of zero indicate that the Job has "
        "completed (either with or without error).") ]
   uint32 QueuePosition;
};


// ===================================================================
// CIM_OOBAlertService 
// ===================================================================
   [Description (
     "This Service is implemented by a LogicalDevice (e.g. a "
     "NetworkAdapter or Modem) that is capable of sending alert "
     "messages to a remote destination. The alert messages reflect "
     "the state of one or more ManagedSystemElements. The Elements "
     "for which alert messages are forwarded, are defined by "
     "enumerating the ProvidesServiceToElement association for the "
     "Service. Out of Band (OOB) refers to the mechanisms in use when "
     "normal OS-based management mechanisms are not possible. This "
     "occurs when the OS is down or not functioning properly.") ]
class CIM_OOBAlertService : CIM_Service {
      [Description (
        "The type of the alert destination. For example, the alert "
        "may be received by an application listening on a UDP Port on "
        "a remote destination, or could be sent to a pager (values "
        "4 or 2, respectively)."), 
       Values {"Unknown", "Other", "Pager", "TCP Port", "UDP Port"}, 
       ModelCorrespondence {
        "CIM_OOBAlertService.OtherDestinationTypeDescription"} ]
   uint16 DestinationType;
      [Description (
        "The description of the alert DestinationType. This is used "
        "when the DestinationType is set to \"Other\" (value=1)."), 
       ModelCorrespondence {"CIM_OOBAlertService.DestinationType"} ]
   string OtherDestinationTypeDescription;
      [Description (
        "The address where this Service sends the alerts. The "
        "format of this address depends on the DestinationType. For "
        "example, if the DestinationType is a UDP Port (value=4), "
        "then this property contains a string identifying the IP "
        "address of the Port (for example, 111.222.333.444:4567). "
        "If DestinationType is a pager (value=2), then the "
        "address is a Pager number (for example, 18002257654).") ]
   string DestinationAddress;
      [Description (
        "The format of the Alert Message sent by the Service."), 
        Values {"Unknown", "Other", "Numeric", "AlphaNumeric", 
                "Free Form Text", "Platform Event Trap"}, 
        ModelCorrespondence {
         "CIM_OOBAlertService.OtherMessageFormatDescription"} ]
   uint16 MessageFormat;
      [Description (
        "The description of the format of the alert message used "
        "by the Service when the AlertMessageFormat property is "
        "set to \"Other\" (value=1)."), 
       ModelCorrespondence {"CIM_OOBAlertService.MessageFormat"} ]
   string OtherMessageFormatDescription;
      [Description (
        "If the AlertService only uses a fixed message to send "
        "an alert, then this flag should be set to TRUE.") ]
   boolean OnlySendsFixedMessage;
      [Description (
        "The AlertService may require some fixed data to send as "
        "part of the message. This may include things like the "
        "address or name of the System. This string contains the "
        "complete message when the property, OnlySendsFixedMessage, "
        "is set to TRUE.") ]
   string FixedPartOfMessage;
      [Description (
        "If the destination is capable of sending an acknowledgement "
        "to the alert, then this flag is set to TRUE. The format of "
        "the acknowledgement is determined by the DestinationType "
        "and the MessageFormat.") ]
   boolean DestinationIsAckCapable;
      [Description (
        "The AlertService may retry and send an alert more than "
        "once. The RetryCount identifies how often the operation will "
        "be repeated. If DestinationIsAckCapable is set to TRUE, then "
        "the retry will only be done if an Ack is not received. "
        "Otherwise, the retries are done unconditionally.") ]
   uint16 RetryCount;
      [Description (
        "The interval between each successive retry, in seconds. "
        "If DestinationIsAckCapable is set to TRUE, then this "
        "interval is used as a timeout interval, before the next "
        "retry is done."), 
       Units ("Seconds") ]
   uint16 RetryInterval;
};


// ===================================================================
// WakeUpService 
// ===================================================================
   [Description (
     "WakeUpService allows a UnitaryComputerSystem to be woken up "
     "from a low power sleep state. This Service is implemented "
     "by a LogicalDevice (e.g. NetworkAdapter or Modem) that is "
     "capable of receiving wakeup messages, and notifying the "
     "System.") ]
class CIM_WakeUpService : CIM_Service {
      [Description ("The Type of the WakeUp Service."), 
       Values {"Unknown", "Other", "Wake On LAN - Magic Packet", 
               "Wake on LAN - Packet Filtering", "Wake On Ring"}, 
       ModelCorrespondence {
        "CIM_WakeUpServcice.OtherWakeUpTypeDescription"} ]
   uint16 WakeUpType;
      [Description (
        "A description of the type of WakeUpService used when "
        "WakeUpType is set to \"Other\" (value=1)."), 
       ModelCorrespondence {"CIM_WakeUpService.WakeUpType"} ]
   string OtherWakeUpTypeDescription;
      [Description (
        "The filter type on the packets/messages that trigger "
        "the WakeUpService. This field is only used when the WakeUp"
        "Type is set to \"Wake On LAN - Packet Filtering\" (value"
        "=3)."), 
       Values {"Unknown", "Other", "ARP Broadcast", 
               "Neighbor Discovery Multicast", 
               "IP Packet with Directed MAC Address", 
               "IPX Diagnostic Responder", "NBT Name Query", 
               "Binary Match"}, 
       ModelCorrespondence {
        "CIM_WakeUpService.OtherFilterTypeDescription"} ]
   uint16 FilterType;
      [OctetString, Description (
        "The binary data that is used to compare the contents "
        "of the received packet. This is used when the FilterType is "
        "set to \"Binary Match\" (value=7). This could also be used "
        "when the FilterType is set to \"Other\" (value=1).") ]
   uint8 FilterData[];
      [Description (
        "The description of the format of the FilterType used by "
        "the Service when the FilterType is set to \"Other\" "
        "(value=1)."), 
       ModelCorrespondence {"CIM_WakeUpService.FilterType"} ]
   string OtherFilterTypeDescription;
};


// ===================================================================
// OOBAlertServiceOnModem 
// ===================================================================
   [Association, Description (
     "OOBAlertServiceOnModem defines where the out of band alerting "
     "Service is implemented. The Service can either employ a Modem "
     "or NetworkAdapter to send alerts.") ]
class CIM_OOBAlertServiceOnModem : CIM_DeviceServiceImplementation {
      [Override ("Antecedent"), Max (1),
       Description ("The Modem which implements the alerting Service.") ]
   CIM_Modem REF Antecedent;
      [Override ("Dependent"), 
       Description ("The alerting Service provided on the Modem.") ]
   CIM_OOBAlertService REF Dependent;
};


// ===================================================================
// WakeUpServiceOnModem 
// ===================================================================
   [Association, Description (
     "WakeUpServiceOnModem defines where the WakeUpService is "
     "implemented. The Service can either employ a Modem or "
     "NetworkAdapter to receive a wakeup signal.") ]
class CIM_WakeUpServiceOnModem : CIM_DeviceServiceImplementation {
      [Override ("Antecedent"), Max (1), 
       Description ("The Modem which implements the WakeUpService.") ]
   CIM_Modem REF Antecedent;
      [Override ("Dependent"), 
       Description ("The wakeup Service provided on the Modem.") ]
   CIM_WakeUpService REF Dependent;
};


// ===================================================================
// OOBAlertServiceOnNetworkAdapter 
// ===================================================================
   [Association, 
    Description (
       "OOBAlertServiceOnNetworkAdapter defines where the out of band "
       "alerting Service is implemented. Currently, the Service can "
       "either employ a Modem or a NetworkAdapter to send alerts.") ]
class CIM_OOBAlertServiceOnNetworkAdapter : CIM_DeviceServiceImplementation {
      [Override ("Antecedent"), Max (1), Description (
        "The NetworkAdapter which implements the Service.") ]
   CIM_NetworkAdapter REF Antecedent;
      [Override ("Dependent"), Description (
        "The alerting Service provided on the NetworkAdapter.") ]
   CIM_OOBAlertService REF Dependent;
};


// ===================================================================
// WakeUpServiceOnNetworkAdapter 
// ===================================================================
   [Association, Description (
     "WakeUpServiceOnNetworkAdapter defines where the WakeUpService "
     "is implemented. Currently, the Service can either employ a Modem "
     "or a NetworkAdapter for wakeup.") ]
class CIM_WakeUpServiceOnNetworkAdapter : CIM_DeviceServiceImplementation {
      [Override ("Antecedent"), Max (1), Description (
        "The NetworkAdapter which implements the Service.") ]
   CIM_NetworkAdapter REF Antecedent;
      [Override ("Dependent"), Description (
        "The wakeup Service provided on the NetworkAdapter.") ]
   CIM_WakeUpService REF Dependent;
};


// ==================================================================
// FibreProtocolService 
// ==================================================================
   [Description (
     "FibreProtocolService abstracts and allows the management of "
     "the Alias, Management, Time, Security, Directory (Naming) and "
     "other services and functions available in a Fibre Channel "
     "network. This class will be further defined in a later "
     "release of CIM.") ]
class CIM_FibreProtocolService : CIM_Service {
};


// ===================================================================
// AGPSoftwareFeature
// ===================================================================
   [Description (
     "AGPSoftwareFeature adds two attributes to SoftwareFeature "
     "to represent the capabilities of an AGP device driver. An "
     "instance of this class would be associated with the "
     "Driver's SoftwareElement using the SoftwareFeatureSoftware"
     "Elements relationship. The driver's SoftwareElement is "
     "associated with the AGPVideoController via the Device"
     "Software relationship.") ]
class CIM_AGPSoftwareFeature : CIM_SoftwareFeature {
      [Description (
        "An array of integers indicating various capabilities and "
        "characteristics of the AGPVideoController."), 
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "OS support", 
               "Hardware Acceleration", "Hardware Blit", 
               "OpenGL Support", "Cache Coherency"}, 
       ModelCorrespondence {
        "CIM_AGPSoftwareFeature.CharacteristicDescriptions"} ]
   uint16 Characteristics[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the features indicated in the "
        "Characteristics array. Each entry in this array is "
        "related to the Characteristics array entry located at "
        "the same index."), 
      ArrayType ("Indexed"), 
      ModelCorrespondence {"CIM_AGPSoftwareFeature.Characteristics"} ]
   string CharacteristicDescriptions[];
};


// ===================================================================
//
//    Settings, Logs, and Redundancy
//
// ===================================================================


// ===================================================================
// RedundancyGroup
// ===================================================================
   [Description (
     "A class derived from LogicalElement that is a special "
     "collection of ManagedSystemElements. This collection indicates "
     "that the aggregated components together provide redundancy. "
     "All elements aggregated in a RedundancyGroup should be "
     "instantiations of the same object class.") ] 
class CIM_RedundancyGroup : CIM_LogicalElement {
      [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Override("Name"), 
       Key, MaxLen (256), Description (
      "The RedundancyGroup Name serves as the key for the "
      "Group's instance in an enterprise environment.") ]
   string Name;
      [Description (
        "RedundancyStatus provides information on the state of the "
        "RedundancyGroup. \"Fully Redundant\" (value=2) means that "
        "all of the configured redundancy is still available; "
        "\"Degraded Redundancy\" (3) means that some failures have "
        "been experienced but some reduced amount of redundancy is "
        "still available; \"Redundancy Lost\" (4) means that a "
        "sufficient number of failures have been experienced such "
        "that no redundancy is available and the next failure "
        "experienced will cause overall failure. Also, the values, "
        "\"Other\" (1) and \"Unknown\" (0), are defined."),
       Values {"Unknown", "Other", "Fully Redundant", 
               "Degraded Redundancy", "Redundancy Lost"} ]
   uint16 RedundancyStatus;
};


// ===================================================================
// RedundancyComponent
// ===================================================================
   [Association, Aggregation, Description (
     "A RedundancyGroup aggregates Managed System Elements and "
     "indicates that these elements, taken together, provide "
     "redundancy. All elements aggregated in a RedundancyGroup "
     "should be instantiations of the same object class.") ] 
class CIM_RedundancyComponent : CIM_Component {
      [Override ("GroupComponent"), Aggregate,
       Description (
        "The RedundancyComponent association indicates that "
        "'this set of fans' or 'these physical extents' participate "
        "in a single RedundancyGroup.") ]
   CIM_RedundancyGroup REF GroupComponent;
};


// ===================================================================
// SpareGroup
// ===================================================================
   [Description (
     "A class derived from RedundancyGroup indicating that one or "
     "more of the aggregated elements can be spared. (The actual "
     "Spares are defined using the ActsAsSpare association.) An "
     "example is the use of redundant NICs in a ComputerSystem - "
     "where one NIC is primary and the other is Spare. The 'primary' "
     "NIC would be a member of the SpareGroup (associated using the "
     "RedundancyComponent class) and the 'other' NIC would be "
     "associated using the ActsAsSpare relationship.") ] 
class CIM_SpareGroup : CIM_RedundancyGroup {
      [Description (
        "This method is forces a failover from one ManagedSystemElement "
        "to another.  There are two parameters to the Failover method, " 
        "FailoverFrom and FailoverTo. The FailoverFrom parameter is a "
        "reference to the primary ManagedSystemElement that will become "
        "inactive after the method. This Element should be associated "
        "with the SpareGroup through the RedundancyComponent relationship. "
        "The FailoverTo parameter is a reference to the ManagedSystem"
        "Element that will take over for the primary. This Element "
        "should be associated with the SpareGroup through the ActsAsSpare "
        "association. Once the failover has occurred, the SpareGroup and "
        "the RedundancyComponent and ActsAsSpare associations will be "
        "updated with current status.  For example, the ActsAsSpare "
        "association that contained the FailoverTo Element will "
        "be deleted and a new RedundancyComponent association instantiated "
        "in its place. The method should return 0 if successful, 1 if "
        "the request is not supported, and some other value if any other "
        "error occurred. In a subclass, the set of possible return codes "
        "could be specified, using a ValueMap qualifier on the method. "
        "The strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array qualifier.") ]
   uint32 Failover(
       [IN] CIM_ManagedSystemElement REF FailoverFrom, 
       [IN] CIM_ManagedSystemElement REF FailoverTo);      
};


// ===================================================================
// ActsAsSpare
// ===================================================================
   [Association,
    Description (
     "The ActsAsSpare association indicates which elements can spare "
     "or replace the other aggregated elements.  The fact that a "
     "spare can operate in \"hot standby\" mode is specified on an "
     "element by element basis.") ]
class CIM_ActsAsSpare  {
      [Key, Description ("The SpareGroup") ]
   CIM_SpareGroup REF Group;
      [Key, Description (
        "A ManagedSystemElement acting as a spare and participating "
        "in the SpareGroup.") ]
   CIM_ManagedSystemElement REF Spare; 
      [Description (
        "HotStandby is a boolean indicating that the spare is "
        "operating as a hot standby.") ]
   boolean HotStandby;   
};


// ===================================================================
// StorageRedundancyGroup
// ===================================================================
   [Description (
     "A class derived from RedundancyGroup containing mass "
     "storage-related redundancy information. StorageRedundancy"
     "Groups are used to protect user data.  They are made up of one "
     "or more PhysicalExtents, or one or more AggregatePExtents. "
     "StorageRedundancyGroups may overlap.  However, the "
     "underlying Extents within the overlap should not contain "
     "any check data.") ] 
class CIM_StorageRedundancyGroup : CIM_RedundancyGroup  {
      [Description (
        "The TypeOfAlgorithm specifies the algorithm used for data "
        "redundancy and reconstruction. For example, \"P+Q\" (value"
        "=5) or \"P+S\" (7) may be specified. The value of 0, is "
        "defined as \"None\" to indicate that data redundancy is not "
        "active. An inactive redundancy should only be instantiated "
        "if data striping or concatenation are active. These are "
        "indicated by the IsStriped or IsConcatentated boolean "
        "properties of this RedundancyGroup."), 
       Values {"None", "Other", "Unknown", "Copy", "XOR", "P+Q", 
               "S", "P+S"}, 
       MappingStrings {"MIF.DMTF|Redundancy Group|001.2"} ]
   uint16 TypeOfAlgorithm;
      [Description (
        "StorageRedundancy provides additional information on the "
        "state of the RedundancyGroup, beyond the RedundancyStatus "
        "property. Information like \"Reconfig In Progress\" (value"
        "=1) or \"Redundancy Disabled\" can be specified using "
        "this property."), 
       Values {"No Additional Status", "Reconfig In Progress", 
               "Data Lost", "Not Currently Configured", 
               "Protected Rebuild", "Redundancy Disabled", 
               "Unprotected Rebuild", "Recalculating", "Verifying"} ]
   uint16 StorageRedundancy;
      [Description (
        "True indicates that the data is striped across the various "
        "StorageExtents in the Group.") ]
   boolean IsStriped;
      [Description (
        "True indicates that the data is concatenated across the "
        "various StorageExtents in the Group.") ]
   boolean IsConcatenated;
};


// ===================================================================
// ExtraCapacityGroup
// ===================================================================
   [Description (
     "A class derived from RedundancyGroup indicating that the "
     "aggregated elements have more capacity or capability than is "
     "needed.  An example of this type of redundancy is the "
     "installation of N+1 power supplies or fans in a system.") ] 
class CIM_ExtraCapacityGroup : CIM_RedundancyGroup {
      [Description (
        "MinNumberNeeded indicates the smallest number of elements "
        "that must be operational in order to have redundancy.  "
        "For example, in an N+1 redundancy relationship, "
        "the MinNumberNeeded property should be set equal to N.") ]
   uint32 MinNumberNeeded;
      [Description (
        "Boolean indicating whether load balancing is supported by "
        "the ExtraCapacityGroup.") ]
   boolean LoadBalancedGroup; 
};


// ===================================================================
// MonitorResolution
// ===================================================================
   [Description (
     "MonitorResolution describes the relationship between "
     "horizontal and vertical resolutions, refresh rate and scan "
     "mode for a DesktopMonitor. The actual resolutions, etc. that "
     "are in use, are the values specified in the VideoController "
     "object.") ] 
class CIM_MonitorResolution : CIM_Setting {
      [Override ("SettingID"),
       Key, MaxLen (256),
       Description (
        "The inherited SettingID serves as part of the key for a "
        "MonitorResolution instance.") ]
   string SettingID; 
      [Description ("Monitor's horizontal resolution in Pixels."),
       Units ("Pixels"),
       ModelCorrespondence {
        "CIM_VideoController.CurrentHorizontalResolution"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.2"} ]
   uint32 HorizontalResolution;
      [Description ("Monitor's vertical resolution in Pixels."),
       Units ("Pixels"),
       ModelCorrespondence {
        "CIM_VideoController.CurrentVerticalResolution"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.3"} ]
   uint32 VerticalResolution;
      [Description (
        "Monitor's refresh rate in Hertz. If a range of rates is "
        "supported, use the MinRefreshRate and MaxRefreshRate "
        "properties, and set RefreshRate (this property) to 0."), 
       Units ("Hertz"),
       ModelCorrespondence {
        "CIM_VideoController.CurrentRefreshRate"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.4"} ]
   uint32 RefreshRate;
      [Description (
        "Monitor's minimum refresh rate in Hertz, when a range of "
        "rates is supported at the specified resolutions."),
       Units ("Hertz"),
       ModelCorrespondence {
        "CIM_VideoController.MinRefreshRate"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.6"} ]
   uint32 MinRefreshRate;
      [Description (
        "Monitor's maximum refresh rate in Hertz, when a range of "
        "rates is supported at the specified resolutions."),
       Units ("Hertz"),
       ModelCorrespondence {
        "CIM_VideoController.MaxRefreshRate"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.7"} ]
   uint32 MaxRefreshRate;
      [Description (
        "Integer indicating whether the monitor operates in "
        "interlaced (value=5) or non-interlaced (4) mode."),
       ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "Not Supported",
               "Non-Interlaced Operation", "Interlaced Operation"},
       ModelCorrespondence {
        "CIM_VideoController.CurrentScanMode"},
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.5"} ]
   uint16 ScanMode;
};


// ===================================================================
// MonitorSetting
// ===================================================================
   [Association, Description (
     "MonitorSetting associates the MonitorResolution Setting object "
     "with the DesktopMonitor to which it applies.") ] 
class CIM_MonitorSetting : CIM_ElementSetting {
      [Override ("Element"), Description (
        "The DesktopMonitor.") ] 
   CIM_DesktopMonitor REF Element;
      [Override ("Setting"), Description (
        "The MonitorResolution associated with the DesktopMonitor.") ]   
   CIM_MonitorResolution REF Setting;
};


// ===================================================================
// NetworkAdapterRedundancyComponent
// ===================================================================
   [Association, Description (
     "CIM_NetworkAdapterRedundancyComponent indicates the role that "
     "a NetworkAdapter plays in a ExtraCapacityGroup, providing "
     "load balancing.") ]
class CIM_NetworkAdapterRedundancyComponent : CIM_RedundancyComponent {
      [Override("GroupComponent"), Aggregate,
       Description (
        "The RedundancyGroup representing a set of load balanced "
        "NetworkAdapters.") ]
   CIM_ExtraCapacityGroup REF GroupComponent;
      [Override("PartComponent"), 
       Description (
        "The Network Adapter(s) belonging to the RedundancyGroup.") ]
   CIM_NetworkAdapter REF PartComponent;
      [Description (
        "Indicates the scope of load balancing for the NetworkAdapters "
        "involved in the RedundancyGroup. Load balancing may be "
        "restricted to transmitting data only (value=1), "
        "receiving data only (value=2), or used for both transmit "
        "and receive (value=3)."), 
       Values {"Unknown", "Load Balancing - Transmit Only",
               "Load Balancing - Receive Only", "Full Load Balancing"} ]
   uint16 ScopeOfBalancing;
      [Description (
        "Boolean indicating whether the Network Adapter is an original "
        "primary adapter (value=1), a preferred primary adapter (2), "
        "or both (3). Values of \"Unknown\" and \"Not Applicable\" may "
        "also be specified."),
       Values {"Unknown", "Original Primary", "Preferred Primary", 
               "Both", "Not Applicable"} ]
   uint16 PrimaryAdapter;
};


// ===================================================================
// NetworkVirtualAdapter
// ===================================================================
   [Association, Description (
     "NetworkVirtualAdapter describes that an instance of Network"
     "Adapter is actually the result of several Adapters "
     "participating in a load balanced RedundancyGroup.") ]
class CIM_NetworkVirtualAdapter : CIM_LogicalIdentity {
      [Override ("SystemElement"), 
       Description ("The 'virtual' NetworkAdapter.") ]
   CIM_NetworkAdapter REF SystemElement;
      [Override ("SameElement"), 
       Description (
        "The ExtraCapacity RedundancyGroup that describes the load "
        "balancing. The result of the load balancing is the 'virtual' "
        "Adapter.")  ]
   CIM_ExtraCapacityGroup REF SameElement;
};

 
// ===================================================================
// VideoControllerResolution
// ===================================================================
   [Description (
     "VideoControllerResolution describes the various video modes "
     "that a VideoController can support. Video modes are defined by "
     "the possible horizontal and vertical resolutions, refresh "
     "rate, scan mode and number of colors settings supported by a "
     "Controller. The actual resolutions, etc. that are in use, are "
     "the values specified in the VideoController object.") ]
class CIM_VideoControllerResolution : CIM_Setting {
      [Override ("SettingID"), 
       Key, MaxLen (256), Description (
        "The inherited SettingID serves as part of the key for a "
        "VideoControllerResolution instance.") ]
   string SettingID;
      [Description ("Controller's horizontal resolution in Pixels."), 
       Units ("Pixels"), 
       ModelCorrespondence {
        "CIM_VideoController.CurrentHorizontalResolution"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.2"} ]
   uint32 HorizontalResolution;
      [Description ("Controller's vertical resolution in Pixels."), 
       Units ("Pixels"), 
       ModelCorrespondence {
        "CIM_VideoController.CurrentVerticalResolution"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.3"} ]
   uint32 VerticalResolution;
      [Description (
        "Refresh rate in Hertz. If a range of rates is supported, use "
        "the MinRefreshRate and MaxRefreshRate properties, and set "
        "RefreshRate (this property) to 0."), 
       Units ("Hertz"), 
       ModelCorrespondence {"CIM_VideoController.CurrentRefreshRate"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.4"} ]
   uint32 RefreshRate;
      [Description (
        "Minimum refresh rate in Hertz, when a range of rates is "
        "supported at the specified resolutions."), 
       Units ("Hertz"), 
       ModelCorrespondence {"CIM_VideoController.MinRefreshRate"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.6"} ]
   uint32 MinRefreshRate;
      [Description (
        "Maximum refresh rate in Hertz, when a range of rates is "
        "supported at the specified resolutions."), 
       Units ("Hertz"), 
       ModelCorrespondence {"CIM_VideoController.MaxRefreshRate"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.7"} ]
   uint32 MaxRefreshRate;
      [Description (
        "Integer indicating whether the Controller operates in "
        "interlaced (value=5) or non-interlaced (4) mode."), 
       ValueMap {"1", "2", "3", "4", "5"}, 
       Values {"Other", "Unknown", "Not Supported", 
               "Non-Interlaced Operation", "Interlaced Operation"}, 
       ModelCorrespondence {"CIM_VideoController.CurrentScanMode"}, 
       MappingStrings {"MIF.DMTF|Monitor Resolutions|002.5"} ]
   uint16 ScanMode;
      [Description (
        "Number of colors supported at the current resolutions."), 
       ModelCorrespondence {
        "CIM_VideoController.CurrentNumberOfColors"} ]
   uint64 NumberOfColors;
};


// ===================================================================
// VideoSetting
// ===================================================================
   [Association, Description (
     "VideoSetting associates the VideoControllerResolution Setting "
     "with the Controller(s) to which it applies.") ]
class CIM_VideoSetting : CIM_ElementSetting {
      [Override ("Element"), 
       Description ("The VideoController.") ]
   CIM_VideoController REF Element;
      [Override ("Setting"), 
       Description (
        "The resolutions, refresh rates, scan mode and number of colors "
        "that can be set for the Controller.") ]
   CIM_VideoControllerResolution REF Setting;
};


// ===================================================================
// ExtentRedundancyComponent
// ===================================================================
   [Association, Aggregation, Description (
     "Describes the StorageExtents participating in a Storage"
     "RedundancyGroup.") ]
class CIM_ExtentRedundancyComponent : CIM_RedundancyComponent {
      [Override ("GroupComponent"), Aggregate, 
       Description ("The StorageRedundancyGroup.") ]
   CIM_StorageRedundancyGroup REF GroupComponent;
      [Override ("PartComponent"),  Description (
        "The StorageExtent participating in the RedundancyGroup.") ]
   CIM_StorageExtent REF PartComponent;
};


// ===================================================================
// PExtentRedundancyComponent
// ===================================================================
   [Association, Aggregation, Description (
     "Describes the PhysicalExtents participating in a Storage"
     "RedundancyGroup.") ] 
class CIM_PExtentRedundancyComponent : CIM_ExtentRedundancyComponent {
      [Override ("GroupComponent"), Aggregate,
       Description ("The StorageRedundancyGroup.")   ]
   CIM_StorageRedundancyGroup REF GroupComponent;
      [Override ("PartComponent"), Description (
        "The PhysicalExtent participating in the RedundancyGroup.") ]
   CIM_PhysicalExtent REF PartComponent;
};


// ===================================================================
// AggregateRedundancyComponent
// ===================================================================
   [Association, Aggregation, Description (
     "Describes the AggregatePExtent in a StorageRedundancyGroup.") ] 
class CIM_AggregateRedundancyComponent : CIM_ExtentRedundancyComponent {
      [Override ("GroupComponent"), Aggregate,
       Description ("The StorageRedundancyGroup.")  ]
   CIM_StorageRedundancyGroup REF GroupComponent;
      [Override ("PartComponent"), Description (
      "The AggregatePExtent participating in the RedundancyGroup.") ]
   CIM_AggregatePExtent REF PartComponent;
};


// ==============================================================
// DiskGroup 
// ==============================================================
   [Description (
     "A DiskGroup is a named collection of DiskDrives and the "
     "StorageExtent(s) accessed via those Drives. The "
     "collection is used to limit the BasedOn relationships of "
     "the Extents in the DiskGroup. Extents in the Group can NOT "
     "be BasedOn storage accessed from Drives outside of the "
     "Group. For example, a SoftwareVolume created 'within the "
     "DiskGroup' is restricted to be completely accessed using "
     "Drives in the Group. Actions such as 'replicate' or "
     "'migrate' on an Extent must operate within the scope of "
     "the Extents present in the DiskGroup.") ]
class CIM_DiskGroup : CIM_CollectionOfMSEs {
      [Override ("CollectionID"), Key]
   string CollectionID;
};


// ===================================================================
// DriveInDiskGroup
// ===================================================================
   [Association, Aggregation, Description (
     "CIM_DriveInDiskGroup defines the DiskDrive(s) that participate "
     "in the Group.") ]
class CIM_DriveInDiskGroup : CIM_CollectedMSEs {
      [Override ("Collection"), Aggregate, Max (1), 
       Description (
        "The DiskGroup. A Drive is a member of at most one "
        "DiskGroup.") ]
   CIM_DiskGroup REF Collection;
      [Override ("Member"), Description (
        "The DiskDrive in the Group.") ]
   CIM_DiskDrive REF Member;
};


// ===================================================================
// ExtentInDiskGroup
// ===================================================================
   [Association, Aggregation, Description (
     "CIM_ExtentInDiskGroup defines the StorageExtent(s) that are "
     "located within and restricted by the Group.") ]
class CIM_ExtentInDiskGroup : CIM_CollectedMSEs {
      [Override ("Collection"), Aggregate, Max (1), 
       Description (
        "The DiskGroup. An Extent is defined within at most one "
        "DiskGroup.") ]
   CIM_DiskGroup REF Collection;
      [Override ("Member"), Description (
        "The StorageExtent restricted by and participating in the "
        "Group.") ]
   CIM_StorageExtent REF Member;
};


// ===================================================================
// GroupInDiskGroup
// ===================================================================
   [Association, Aggregation, Description (
     "CIM_GroupInDiskGroup describes that a DiskGroup may be "
     "divided into smaller named Collections.") ]
class CIM_GroupInDiskGroup : CIM_CollectedCollections {
      [Override ("Collection"), Aggregate, Max (1), 
       Description (
        "The DiskGroup that is subsetted into smaller "
        "Collections.") ]
   CIM_DiskGroup REF Collection;
      [Override ("CollectionInCollection"), Description (
        "The DiskGroup that is a subset of the larger Group.") ]
   CIM_DiskGroup REF CollectionInCollection;
};


// ===================================================================
// MessageLog
// ===================================================================
   [Description (
     "MessageLog represents any type of event, error or informational "
     "register or chronicle. The object describes the existence of "
     "the log and its characteristics. Several methods are defined "
     "for retrieving, writing and deleting log entries, and "
     "maintaining the log.") ] 
class CIM_MessageLog : CIM_LogicalElement {
      [Key, MaxLen (256),
       Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Override ("Name"), 
       Key, MaxLen (256), 
       Description (
        "The inherited Name serves as part of the key (a unique "
        "identifier) for the MessageLog instance.") ] 
   string Name; 
      [Description (
        "An array of integers indicating the Log capabilities. "
        "Information such as \"Write Record Supported\" (value="
        "2) or \"Variable Length Records Supported\" (8) is "
        "specified in this property."),
       ArrayType ("Indexed"),
       Values {"Unknown", "Other", "Write Record Supported", 
               "Delete Record Supported", 
               "Can Move Backward in Log", "Freeze Log Supported", 
               "Clear Log Supported", 
               "Supports Addressing by Ordinal Record Number",
               "Variable Length Records Supported", 
               "Variable Formats for Records", 
               "Can Flag Records for Overwrite"}, 
       ModelCorrespondence {
        "CIM_MessageLog.CapabilitiesDescriptions"}  ]
   uint16 Capabilities[];
      [Description (
        "An array of free-form strings providing more detailed "
        "explanations for any of the Log features indicated in "
        "the Capabilities array. Note, each entry of this array "
        "is related to the entry in the Capabilities array that "
        "is located at the same index."),
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_MessageLog.Capabilities"} ]
   string CapabilitiesDescriptions[];
      [Description (
        "The maximum size, in bytes, to which the Log can grow. "
        "If there is no maximum, then MaxLogSize should be set "
        "to 0."),
       Units ("Bytes") ]
   uint64 MaxLogSize;
      [Description (
        "The size of the Log header, in bytes, if one is "
        "present. If there is no Log header, then this property "
        "should be set to 0. Headers may include general "
        "information about the Log such as the current number of "
        "records, time of last update, or a pointer to the location "
        "of the first Log entry. Note that this property is NOT the "
        "size of the header for an individual Log entry. The latter "
        "is described by the property, SizeOfRecordHeader."), 
       Units ("Bytes") ]
   uint64 SizeOfHeader;
      [Description (
        "If the SizeOfHeader property is non-zero, this property "
        "describes the structure and format of the Log header. It "
        "is a free-form string. If the SizeOfHeader property is 0, "
        "then the information in this property is undefined.") ]
   string HeaderFormat;
      [Description (
        "Maximum size, in bytes, to which an individual Log "
        "entry (record) can grow - if the Capabilities array "
        "includes a value of 7 (\"Variable Length Records "
        "Supported\"). If the Capabilities array does not "
        "include a 7, then the Log only supports fixed length "
        "entries. The size of these entries is described by "
        "this property."), 
       Units ("Bytes") ]
   uint64 MaxRecordSize;
      [Description (
        "The size of the header for the Log's individual entries, "
        "in bytes, if record headers are defined. If there are no "
        "record headers, then this property should be set to 0. "
        "Record headers may include information such as the type of "
        "the Log entry, the date/time that the entry was last "
        "updated, or a pointer to the start of optional data. Note "
        "that this property defines the header size for individual "
        "records in the Log, while the SizeOfHeader property "
        "describes the Log's overall header, typically located at "
        "the start of the MessageLog."), 
       Units ("Bytes") ]
   uint64 SizeOfRecordHeader;
      [Description (
        "If the SizeOfRecordHeader property is non-zero, this "
        "property describes the structure and format of the "
        "record headers. It is a free-form string. If the "
        "SizeOfRecordHeader property is 0, then the information "
        "in this property is undefined.") ]
   string RecordHeaderFormat;
      [Description (
        "Maximum number of records that can be captured in "
        "the Log. If undefined, a value of zero should be "
        "specified. Note that when the Capabilities array "
        "indicates that variable length records are supported "
        "(value=7), then it is possible that this maximum may "
        "not be achieved.") ]
   uint64 MaxNumberOfRecords;
      [Description (
        "Current number of entries (records) in the Log."),
       Gauge ]
   uint64 CurrentNumberOfRecords;
      [Description (
        "An enumeration describing the behavior of the Log, when "
        "it becomes full or near full. For example, the Log may "
        "wrap (value=2) or may simply stop recording entries (value"
        "=7).\n\n"
        "Some of the property's possible values need further "
        "explanation:\n"
        "3=\"Clear When Near Full\" indicates that all of the Log's "
        "entries will be deleted when a specified record capacity is "
        "reached. The capacity is specified in percentage, using the "
        "property, PercentageNearFull. 'Near Full' may be less than "
        "100% if the Log takes time to clear, and a position should "
        "always be available for new records.\n"
        "4=\"Overwrite Outdated When Needed\" describes that Log "
        "entries (timestamped later than the date/time specified in "
        "the property, TimeWhenOutdated) can be overwritten.\n"
        "5=\"Remove Outdated Records\" specifies that records "
        "(timestamped later than the date/time specified in the "
        "property, TimeWhenOutdated) are logically and/or physically "
        "removed from the Log.\n"
        "6=\"Overwrite Specific Records\" indicates that specially "
        "flagged records may be overwritten. This property only makes "
        "sense when the Capabilities array includes a value of 10, "
        "\"Can Flag Records for Overwrite\"."),
       Values {"Unknown", "Other", "Wraps When Full",
               "Clear When Near Full", 
               "Overwrite Outdated When Needed", 
               "Remove Outdated Records",
               "Overwrite Specific Records", 
               "Never Overwrite"},
       ModelCorrespondence {"CIM_MessageLog.OtherPolicyDescription", 
        "CIM_MessageLog.TimeWhenOutdated", 
        "CIM_MessageLog.PercentageNearFull"} ]
   uint16 OverwritePolicy;
      [Description (
        "When the OverwritePolicy specifies a value of 1 "
        "(\"Other\"), the Log's behavior can be explained "
        "using this property. If OverwritePolicy is not 1, "
        "then this property's contents are undefined."), 
       ModelCorrespondence {"CIM_MessageLog.OverwritePolicy"} ]
   string OtherPolicyDescription;
      [Description (
        "If the OverwritePolicy is based on 'outdated' records "
        "(values 4 or 5), this property defines when a Log entry "
        "is considered to be outdated - either by time interval or "
        "at a specific date and time."), 
       ModelCorrespondence {"CIM_MessageLog.OverwritePolicy"} ]
   datetime TimeWhenOutdated;
      [Description (
        "If the OverwritePolicy is based on clearing records "
        "when the Log is near full (value=3), this property defines "
        "the record capacity (in percentage) that is considered to "
        "be 'near full'."),
       Units ("Percent"), 
       ModelCorrespondence {"CIM_MessageLog.OverwritePolicy"} ]
   uint8 PercentageNearFull;
      [Description (
        "An enumeration describing the last change to the "
        "MessageLog."), 
       Values {"Unknown", "Add", "Delete", "Modify", "Log Cleared"} ]
   uint16 LastChange;
      [Description (
        "When a change is made to the Log, the date/time of "
        "that modification is captured. This property could be "
        "used to event against any update to the MessageLog.") ]
   datetime TimeOfLastChange;
      [Description (
        "When a change is made to the Log, the record number that "
        "was modified is captured.") ]
   uint64 RecordLastChanged;
      [Description (
        "Boolean indicating that the Log is currently frozen and "
        "modifications are not allowed.") ]
   boolean IsFrozen;
      [Description (
        "An enumeration describing the character set used to record "
        "data in the individual Log entries. For example, the "
        "Log records may contain ASCII data (value=2), or be raw octet "
        "strings (value=10)."), 
       Values {"Unknown", "Other", "ASCII", "Unicode", "ISO2022", 
               "ISO8859", "Extended UNIX Code", "UTF-8", "UCS-2", 
               "Bitmapped Data", "OctetString", 
               "Defined by Individual Records"} ]
   uint16 CharacterSet; 
      [Description (
        "Requests that the MessageLog be cleared of all entries. "
        "The return value should be 0 if the request was successfully "
        "executed, 1 if the request is not supported and some other "
        "value if an error occurred. If the request is not supported, "
        "check the Capabilities array that a value of 6 (\"Clear Log "
        "Supported\") is specified.\n\n"
        "Note: In a subclass, the set of possible return codes could "
        "be described using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 ClearLog();
      [Description (
        "Requests that an iteration of the MessageLog be established "
        "and that the iterator be set to the first entry in the Log. "
        "An identifier for the iterator is returned as an output "
        "parameter of the method.\n\n"
        "Regarding iteration, you have 2 choices:  1) Embed iteration "
        "data in the method call, and allow implementations to track/"
        "store this data manually; or, 2) Iterate using a separate "
        "object (for example, class ActiveIterator) as an iteration "
        "agent. The first approach is used here for interoperability. "
        "The second requires an instance of the Iterator object for "
        "EACH iteration in progress. 2's functionality could be "
        "implemented underneath 1.\n\n"
        "The return value from PositionToFirstRecord should be 0 if "
        "the request was successfully executed, 1 if the request is "
        "not supported and some other value if an error occurred. In "
        "a subclass, the set of possible return codes could be specified, "
        "using a ValueMap qualifier on the method. The strings to which "
        "the ValueMap contents are 'translated' may also be specified "
        "in the subclass as a Values array qualifier.")  ]
   uint32 PositionToFirstRecord (
      [OUT] string IterationIdentifier);
      [Description (
        "Requests that the Log's iteration identifier be advanced or "
        "retreated a specific number of records, or set to the "
        "entry at a specified numeric location. These two different "
        "behaviors are accomplished using the input parameters of the "
        "method. Advancing or retreating is achieved by setting the "
        "MoveAbsolute boolean to FALSE, and then specifying the number of "
        "entries to advance or retreat as positive or negative values "
        "in the RecordNumber parameter. Moving to a specific record "
        "number is accomplished by setting the MoveAbsolute input "
        "parameter to TRUE, and then placing the record number into "
        "the RecordNumber parameter. This can only be done if the "
        "Capabilities array includes a value of 7, \"Supports "
        "Addressing by Ordinal Record Number\".\n\n"
        "After the method completes and if ordinal record numbers are "
        "supported (the Capabilities array includes a 7), the current "
        "record number is returned in the RecordNumber output parameter. "
        "Otherwise, the value of the parameter is undefined.\n\n"
        "IterationIdentifier is defined as an Input/Output method "
        "parameter to allow the Log to embed state information in "
        "the Identifier and potentially let the identifier be "
        "maintained by the using application.\n\n"
        "The return value from PositionAtRecord should be 0 if "
        "the request was successfully executed, 1 if the request is "
        "not supported and some other value if an error occurred. If "
        "the request is not supported, check the Capabilities array "
        "regarding support for ordinal record number addressing and "
        "backward movement in the Log (values 7 and 4, respectively).\n\n"
        "Note: In a subclass, the set of possible return codes could "
        "be described using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 PositionAtRecord (
      [IN, OUT] string IterationIdentifier, 
      [IN, Description ("Advancing or retreating the IterationIdentifier "
           "is achieved by setting the MoveAbsolute boolean to FALSE, and "
           "specifying the number of entries to advance or retreat as "
           "positive or negative values in the RecordNumber parameter. "
           "Moving to a specific record number is accomplished by setting "
           "the MoveAbsolute parameter to TRUE, and placing the record "
           "number into the RecordNumber parameter.") ] 
       boolean MoveAbsolute, 
      [IN, OUT] sint64 RecordNumber);
      [Description (
        "Requests that the record indicated by the IterationIdentifier "
        "be retrieved from the MessageLog. After retrieval, the Iteration"
        "Identifier may be advanced to the next record by setting the "
        "PositionToNext input parameter to TRUE. Two output parameters "
        "are defined for the method - RecordData which holds the contents "
        "of the Log entry (as an array of bytes that can be recast to an "
        "appropriate format), and RecordNumber which returns the current "
        "record number addressed via the IterationIdentifier. The "
        "RecordNumber parameter is only defined/valid when the "
        "Capabilities array indicates that ordinal record number "
        "addressing is supported (a value of 7).\n\n"
        "IterationIdentifier is defined as an Input/Output method "
        "parameter to allow the Log to embed state information in "
        "the Identifier and potentially let the identifier be "
        "maintained by the using application.\n\n"
        "The return value from GetRecord should be 0 if the request "
        "was successfully executed, 1 if the request is not supported, "
        "and some other value if an error occurred. In a subclass, the "
        "set of possible return codes could be specified, using a "
        "ValueMap qualifier on the method. The strings to which the "
        "ValueMap contents are 'translated' may also be specified in "
        "the subclass as a Values array qualifier.")  ]
   uint32 GetRecord (
      [IN, OUT] string IterationIdentifier, 
      [IN, Description ("Boolean indicating that the Iteration"
           "Identifier should be advanced to the next record, after "
           "retrieving the current Log entry.") ] 
       boolean PositionToNext, 
      [OUT] uint64 RecordNumber,
      [OUT] uint8 RecordData[]); 
      [Description (
        "Requests that the record indicated by the IterationIdentifier "
        "be deleted from the MessageLog. After deletion, the Iteration"
        "Identifier may be advanced to the next record by setting the "
        "PositionToNext input parameter to TRUE. If set to FALSE, then "
        "the IterationIdentifier will be positioned at the previous "
        "record. Two output parameters are defined for the method - "
        "RecordData which holds the contents of the deleted Log entry "
        "(as an array of bytes that can be recast to an appropriate "
        "format or discarded), and RecordNumber which returns the current "
        "record number addressed via the IterationIdentifier. The "
        "RecordNumber parameter is only defined/valid when the "
        "Capabilities array indicates that ordinal record number "
        "addressing is supported (a value of 7).\n\n"
        "IterationIdentifier is defined as an Input/Output method "
        "parameter to allow the Log to embed state information in "
        "the Identifier and potentially let the identifier be "
        "maintained by the using application.\n\n"
        "The return value from DeleteRecord should be 0 if the request "
        "was successfully executed, 1 if the request is not supported, "
        "and some other value if an error occurred. If the request is "
        "not supported, check the Capabilities array that a value of 3 "
        "(\"Delete Record Supported\") is specified.\n\n"
        "Note: In a subclass, the set of possible return codes could "
        "be described using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 DeleteRecord (
       [IN, OUT] string IterationIdentifier, 
       [IN, Description ("Boolean that when set to TRUE requests the "
            "IterationIdentifier to be advanced to the next record, "
            "after the current entry is deleted. If set to FALSE, "
            "IterationIdentifier is set to the previous record.") ]
       boolean PositionToNext, 
      [OUT] uint64 RecordNumber,
      [OUT] uint8 RecordData[]); 
      [Description (
        "Requests that a record be inserted at the Log position "
        "indicated by the IterationIdentifier. The entry's data is "
        "provided in the RecordData input parameter. After insertion, "
        "the IterationIdentifier may be advanced to the next record "
        "by setting the PositionToNext input parameter to TRUE. "
        "The output parameter, RecordNumber, returns the current "
        "record number addressed via the IterationIdentifier. This "
        "parameter is only defined/valid when the Capabilities array "
        "indicates that ordinal record number addressing is supported " 
        "(a value of 7).\n\n"
        "IterationIdentifier is defined as an Input/Output method "
        "parameter to allow the Log to embed state information in "
        "the Identifier and potentially let the identifier be "
        "maintained by the using application.\n\n"
        "The return value from WriteRecord should be 0 if the request "
        "was successfully executed, 1 if the request is not supported, "
        "and some other value if an error occurred. If the request is "
        "not supported, check the Capabilities array that a value of 2 "
        "(\"Write Record Supported\") is specified.\n\n"
        "Note: In a subclass, the set of possible return codes could "
        "be described using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 WriteRecord (
      [IN, OUT] string IterationIdentifier, 
      [IN, Description ("Boolean indicating that the Iteration"
           "Identifier should be advanced to the next record, after "
           "writing the Log entry.") ] boolean PositionToNext, 
      [IN] uint8 RecordData[],
      [OUT] uint64 RecordNumber); 
      [Description (
        "Requests that an iteration of the Log, identified by the "
        "IterationIdentifier input parameter, be stopped. The "
        "return value from CancelIteration should be 0 if the "
        "request was successfully executed, 1 if the request is "
        "not supported and some other value if an error occurred. In "
        "a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 CancelIteration (
      [IN] string IterationIdentifier);
      [Description (
        "Requests that the MessageLog be placed in a frozen state "
        "(\"Freeze\" input parameter = TRUE) or 'unfrozen' (= FALSE). "
        "If frozen, modifications to the Log will not be allowed. "
        "If successful, the Log's IsFrozen boolean property will "
        "be updated to reflect the desired state.\n\n"
        "The method's return code should be 0 if the request was "
        "successfully executed, 1 if the request is not supported "
        "and some other value if an error occurred. If the request "
        "is not supported, check the Capabilities array that a value "
        "of 5 (\"Freeze Log Supported\") is specified.\n\n"
        "Note: In a subclass, the set of possible return codes could "
        "be described using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.")  ]
   uint32 FreezeLog(
      [IN] boolean Freeze);
      [Description (
        "Requests that the record indicated by the IterationIdentifier "
        "be flagged as overwriteable. This method is only supported "
        "when the Capabilities array includes a value of 10, \"Can Flag "
        "Records for Overwrite\". After updating the entry, the Iteration"
        "Identifier may be advanced to the next record by setting the "
        "PositionToNext input parameter to TRUE. One output parameter "
        "is defined for the method RecordNumber. It returns the "
        "current record number addressed via the Iteration"
        "Identifier. This parameter is only defined/valid when the "
        "Capabilities array indicates that ordinal record number "
        "addressing is supported (a value of 7).\n\n"
        "IterationIdentifier is defined as an Input/Output method "
        "parameter to allow the Log to embed state information in "
        "the Identifier and potentially let the identifier be "
        "maintained by the using application.\n\n"
        "The return value from FlagRecordForOverwrite should be 0 if "
        "the request was successfully executed, 1 if the request is not "
        "supported, and some other value if an error occurred. In a "
        "subclass, the set of possible return codes could be specified, "
        "using a ValueMap qualifier on the method. The strings to which "
        "the ValueMap contents are 'translated' may also be specified "
        "in the subclass as a Values array qualifier.")  ]
   uint32 FlagRecordForOverwrite (
      [IN, OUT] string IterationIdentifier, 
      [IN, Description ("Boolean indicating that the Iteration"
           "Identifier should be advanced to the next record, after "
           "updating the current Log entry.") ] 
       boolean PositionToNext, 
      [OUT] uint64 RecordNumber); 
};

 
// ===================================================================
// LogRecord
// ===================================================================
   [Description (
     "The LogRecord object can describe the definitional format for "
     "entries in a MessageLog, or can be used to instantiate the "
     "actual records in the Log. The latter approach provides a "
     "great deal more semantic definition and management control over "
     "the individual entries in a MessageLog, than do the record "
     "manipulation methods of the Log class. It is recommended that "
     "the data in individual Log entries be modeled using subclasses "
     "of LogRecord, to avoid the creation of LogRecords with one "
     "property (such as RecordData) without semantics.\n"
     "Definitional formats for LogRecords could be specified by "
     "establishing a naming convention for the RecordID and Message"
     "Timestamp key properties.")  ] 
class CIM_LogRecord : CIM_ManagedElement {
      [Propagated("CIM_MessageLog.CreationClassName"), 
       Key, MaxLen (256),
       Description ("The scoping Log's CreationClassName.") ]
   string LogCreationClassName;
      [Propagated("CIM_MessageLog.Name"),
       Key, MaxLen (256),
       Description ("The scoping Log's Name.") ]
   string LogName;
      [Key, MaxLen (256),
       Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.")  ]
   string CreationClassName;
      [Key, MaxLen (256), 
       Description (
        "RecordID, with the MessageTimestamp property, serve to "
        "uniquely identify the LogRecord within a MessageLog. Note "
        "that this property is different than the RecordNumber "
        "parameters of the MessageLog methods. The latter are ordinal "
        "values only, useful to track position when iterating through "
        "a Log. On the other hand, RecordID is truly an identifier "
        "for an instance of LogRecord. It may be set to the record's "
        "ordinal position, but this is not required.") ] 
   string RecordID; 
      [Key, Description (
        "A LogRecord's key structure includes a timestamp for "
        "the entry.") ]
   datetime MessageTimestamp;
      [Description (
        "A free-form string describing the LogRecord's data structure.") ]
   string DataFormat;
};

 
// ===================================================================
// RecordInLog
// ===================================================================
   [Association, Aggregation, Description (
     "RecordInLog describes the aggregation or location of Log "
     "entries within a MessageLog.") ]
class CIM_RecordInLog  {
      [Key, Aggregate, Min (1), Max (1), 
       Description ("The Message Log.")  ]
   CIM_MessageLog REF MessageLog;
      [Key, Weak, Description (
        "The Log entry contained within the MessageLog.") ]
   CIM_LogRecord REF LogRecord;
};
 

// ===================================================================
// LogInDeviceFile
// ===================================================================
   [Association, Description (
     "MessageLogs can reside in data files, on specially allocated "
     "storage areas such as disks or memory, or output as raw I/O "
     "streams. In fact, a single Log may use each of these mechanisms "
     "to output or capture its contents. The LogInDeviceFile "
     "association describes a Log outputting to a raw I/O stream "
     "DeviceFile - for example, a serial port on a UNIX system.") ]
class CIM_LogInDeviceFile : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "The I/O stream DeviceFile.") ]
   CIM_DeviceFile REF Antecedent;
      [Override ("Dependent"),
       Description ("The MessageLog outputting to the DeviceFile.") ]
   CIM_MessageLog REF Dependent;
};


// ===================================================================
// LogInDataFile
// ===================================================================
   [Association, Description (
     "MessageLogs can reside in data files, on specially allocated "
     "storage areas such as disks or memory, or output as raw I/O "
     "streams. In fact, a single Log may use each of these mechanisms "
     "to output or capture its contents. The LogInDataFile "
     "association describes a Log stored as a DataFile.") ]
class CIM_LogInDataFile : CIM_Dependency {
      [Override ("Antecedent"), Description (
        "The DataFile.") ]
   CIM_DataFile REF Antecedent;
      [Override ("Dependent"),
       Description ("The MessageLog residing in the DataFile.") ]
   CIM_MessageLog REF Dependent;
};

 
// ===================================================================
// LogInStorage
// ===================================================================
   [Association, Description (
     "MessageLogs can reside in data files, on specially allocated "
     "storage areas such as disks or memory, or output as raw I/O "
     "streams. In fact, a single Log may use each of these mechanisms "
     "to output or capture its contents. The LogInStorage "
     "association describes a Log located in a specially allocated "
     "portion of a StorageExtent. The offset of the Log, within "
     "the Extent, is defined using a property of the association, "
     "StartingOffset.") ]
class CIM_LogInStorage : CIM_Dependency {
      [Override ("Antecedent"), Description ("The StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;
      [Override ("Dependent"),
       Description ("The MessageLog located within the Extent.") ]
   CIM_MessageLog REF Dependent;
      [Description (
        "StartingOffset indicates where in the Extent that the Log "
        "begins.") ] 
   uint64 StartingOffset;
};

 
// ===================================================================
// UseOfMessageLog
// ===================================================================
   [Association, Description (
     "ManagedSystemElements may record their event, error or "
     "informational data within MessageLogs. The use of a Log to "
     "hold a ManagedSystemElement's data is described by this "
     "association. The type of Element data captured by the Log "
     "can be specified using the RecordedData string property.") ]
class CIM_UseOfMessageLog : CIM_Dependency {
      [Override ("Antecedent"), Description ("The MessageLog.") ]
   CIM_MessageLog REF Antecedent;
      [Override ("Dependent"), Description (
        "The ManagedSystemElement whose information is recorded in "
        "the MessageLog.") ]
   CIM_ManagedSystemElement REF Dependent;
      [Description (
        "A free-form string describing the use of the Log by the "
        "ManagedSystemElement.") ] 
   string RecordedData;
};

// ===================================================================
// end of file
// ===================================================================

