// ===================================================================
// Title:       Physical MOF Specification 2.5
// Filename:    CIM_Physical25.mof
// Version:     2.5
// Release:     0
// Status:      Final
// Date:        06/12/2001
// ===================================================================
// Copyright "2001" Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release cited should always be noted.
// Description: These object classes define the user and security 
//              model for CIM and includes classes needed to represent
//              users, groups and organizational entities as well as 
//              security services and authentication and authorization 
//              information.
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//		    by other working groups, are omitted. 
// ===================================================================
// Description: The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//				by other working groups, are omitted.
// ==================================================================
// Date:		09/29/1998 - Original release, CIM Version 2.1 - CRs from
// Author:      DMTF System and Devices Working Group
// Editor:      Michael A. Thatcher
// ==================================================================
//	- CR237, Remove CompatibilityList from PhysicalPackage
//    - CR246, Update mapping from DMI Master.MIF 
//    - CR247, Remove repetition of Values arrays from the property 
//          Descriptions
//    - CR248, Add WriteProtectOn boolean to PhysicalMedia
//    - CR253, Add PhysicalCapacity and subclasses, Remove MemoryCard
//    - CR255b, Create AdjacentSlots association / Delete several Slot 
//		properties from Card and the SharedSlots association
//	- CR256, Add VisibleAlarm boolean to Rack and Chassis
//    - CR257, Add an association, MemoryWithMedia
//    - CR258a and 289, Add SpecialPurpose info to Slot
//    - CR260, Remove Max(1) from the Antecedent reference of CardInSlot
//    - CR262, Add RequiresDautherBoard boolean to CIM_Card
//    - CR263, Change description of CardOnCard.GroupComponent
//    - CR264, Add CleanerMedia boolean to PhysicalMedia
//	- CR266, Add PackageAlarm association
//    - CR267, Make all measurements of datatype, real
//	- CR269, Change the "Replaceable" descriptions for Physical
//		Package and PhysicalComponent
//    - CR278a, Add MediaType property to PhysicalLink
//    - CR279a, Add an Index property to Slot
//    - CR280, Replace SlotAdapter property with an association, 
//		SlotInSlot
//    - CR281a, Add SpecialRequirements info to Card
//    - CR283, Add a new association PackageInSlot, and reparent 
//		CardInSlot to be its child
//    - CR284a, Define a new association, ConnectedTo
//    - CR286a, Add TypeOfRack enumeration and CountryDesignation 
//		string to Rack
//    - CR287, Create superclass of Rack and Chassis, PhysicalFrame
//	- CR290, Add ModelCorrespondence to "linked" properties
// Date: 06/09/1999
//    - CR339, Define AdapterActiveConnection association
//	- CR349, Add OperatingVoltages property to Card
//	- CR350, Add PlatformGUID to ComputerSystemPackage
//    - CR355a, Update the method descriptions for IsCompatible
//		indicating that Values-ValueMap qualifiers can be defined 
//		for return codes
//	- CR356a, Put keys on the references of PhysicalElementLocation,
//	      ElementCapacity, ParticipatesInSet and AdjacentSlots
//	- CR365, Clarify the Description for RealizesDiskPartition
//	- CR378a, Miscellaneous changes to enumerations, creating new
//		properties and subclasses, and updating the DMI 
//          MappingStrings
//	- CR379a, Update MappingStrings to align with the DMI master.mif
//	- CR392a, Tape support
//	- CR405, Add Counter qualifier to PhysicalMedia.MountCount and
//		all properties of MediaPhysicalStatInfo
//	- CR407, Add to the enumeration for StorageMediaLocation.
//		LocationType and add property, MediaCapacity (StorageMedia 
//          Location originally defined in CR392)
//	- CR417a, Add to the enumeration for ConfigurationCapacity.
//          ObjectType and updated the class Description (originally 
//		defined in CR392)
//	- CR418a, Update Slot Description, Create RealizesExtent 
//          association and change subclassing for other Realizes 
//		relationships to use RealizesExtent
//    - CR419, Remove Max(1) from the MediaTransferDevice reference
//		for DeviceServicesLocation (originally defined in CR392)
//	- CR420, Add CD-DA, CD+, DVD-Audio and DVD-5,9,10,18 formats to  
//          StorageMediaLocation.MediaTypesSupported and 
//          PhysicalMedia.MediaType
//  Date: 07/06/1999 - Version 2.2.1
//	- CR423, Locale should be specified as en_US
//	- CR425, Update the DMI MappingStrings using the June
//		release of the master.mif
//	Date  02/18/2000 - Version 2.3
//		- CR431 Update MappingStrings
//		- CR433 Add new properties and enums from Master.MIF and new 
//			ModelCorrespondences 
//		- CR435 Add additional types (Front and Back Side I/O slots, NVS,
//			 Volatile, and Cache Memory) to ConfigurationCapacity. 
//		- CR445e, Modify the Card class to add a ConnectorPower method
//		- CR459 Add InfiniBand to the list of connectors/bus types
//		- CR461 Subclass from CIM_ManagedElement Location, PhysicalCapacity 
//			and ReplacementSet
//			Remove Description & Caption from the above classes, where exist.
//	Date 06/09/2000 - Version 2.4
//		- CR478 A variety of changes related to modeling the physical aspects of
//			storage and StorageLibraries. 
//			1. New property, Inaccessible, to DeviceServicesLocation association.
//			2. Add to the enumeration for PhysicalMedia.LabelFormats
//			3. Add two new properties to PhysicalMedia
//			4. Define a new association, RealizedOnSide
//			5. New properties to association, PhysicalMediaInLocation.
//			6. Define a new association, HomeForMedia
//			7. Update description for Container.LocationWithinContainer.
//		- CR487, Further updates to the Storage and Storage Library Models 
//			1. New property, TypeDescriptions, to StorageMediaLocation.
//			2. Update ModelCorrespondence for 
//				StorageMediaLocation.MediaTypesSupported due to changes in #1.  
//			3. Update the Description for StorageMediaLocation.MediaTypesSupported 
//				to reflect that additional info is contained in the 
//				TypeDescriptions array.
//			4. Add a new class, Magazine.
//		- CR495, Change the Values list for CIM_MemoryCapacity.MemoryType and 
//			CIM_PhysicalMemory.MemoryType 
//	Date 12/01/2000 Version 2.5
//		- CR534 Update MappingStrings Qualifiers to stay in sync with updates to the MASTER.MIF.
//
// ===================================================================


// ===================================================================
// Generic Pragmas
// ===================================================================
#pragma locale ("en_US")


// ===================================================================
// Location
// ===================================================================
   [Description (
       "The Location class specifies the position and address of "
	 "a PhysicalElement.")
   ]
class CIM_Location : CIM_ManagedElement
{
      [Key, MaxLen (256), 
	 Description (
	  "Name is a free-form string defining a label for the "
	  "Location. It is a part of the key for the object.")
	]
   string Name;
	[Key, MaxLen (256), 
	 Description (
	  "Position is a free-form string indicating the placement "
	  "of a PhysicalElement.  It can specify slot information on "
	  "a HostingBoard, mounting site in a Cabinet, or latitude and "
	  "longitude information, for example, from a GPS. It is "
	  "part of the key of the Location object.")
	]
   string PhysicalPosition;
	[MaxLen (1024), 
	 Description (
	  "Address is a free-form string indicating a street, building "
	  "or other type of address for the PhysicalElement's Location.")
	]
   string Address;
};

// ==================================================================
// PhysicalElementLocation
// ==================================================================
   [Association, 
    Description (
	 "PhysicalElementLocation associates a PhysicalElement with "
	 "a Location object for inventory or replacement purposes.")
   ]
class CIM_PhysicalElementLocation
{
	[Key, Description (
	  "The PhysicalElement whose Location is specified.")
	]
   CIM_PhysicalElement REF Element;
	[Key, Max (1),
	 Description ("The PhysicalElement's Location.")
	]
   CIM_Location REF PhysicalLocation;
};

// ==================================================================
// PhysicalCapacity
// ==================================================================
   [Abstract,
    Description ("PhysicalCapacity is an abstract class describing "
       "a PhysicalElement's minimum/maximum requirements and "
       "ability to support different types of hardware. For example, "
       "minimum and maximum memory requirements can be modeled as a "
       "subclass of CIM_PhysicalCapacity.")
   ]
class CIM_PhysicalCapacity : CIM_ManagedElement
{
      [MaxLen (256),
       Description ("The Name property defines the label by which "
        "the PhysicalCapacity object is known.  When subclassed, "
        "the Name property can be overridden to be a Key property.")
      ]
   string Name;
};

// =================================================================
// ElementCapacity
// =================================================================
   [Association,
    Description ("ElementCapacity associates a PhysicalCapacity "
       "object with one or more PhysicalElements.  It serves to "
       "associate a description of min/max hardware requirements "
       "or capabilities (stored as a kind of PhysicalCapacity), "
       "with the PhysicalElements being described.")
   ]
class CIM_ElementCapacity
{
      [Key, Description (
        "PhysicalCapacity describes the minimum and maximum "
        "requirements, and ability to support different types of "
        "hardware for a PhysicalElement.")
      ]
   CIM_PhysicalCapacity REF Capacity;
      [Key, Min(1),
       Description ("The PhysicalElement being described.")
      ]
   CIM_PhysicalElement REF Element;
};

// ==================================================================
// MemoryCapacity
// ==================================================================
   [Description (
	 "MemoryCapacity describes the type of Memory that "
       "can be installed on a PhysicalElement and its minimum/maximum "
       "configurations. Information on what memory is currently "
       "'installed', versus an Element's min/max requirements, is "
       "located in instances of the PhysicalMemory class.")
   ]
class CIM_MemoryCapacity : CIM_PhysicalCapacity
{
      [Override ("Name"),
       Key,
       Description ("The inherited Name serves as a part of the "
          "MemoryCapacity object key.")
      ]
   string Name;
      [Key,
       Description ("The type of memory. This is a part of the object "
        "key. Values correspond to the list of possible memory types "
        "in the PhysicalMemory class."),
		Values {"Unknown", "Other", "DRAM", "Synchronous DRAM",
		"Cache DRAM", "EDO", "EDRAM", "VRAM", "SRAM", "RAM",
		"ROM", "Flash", "EEPROM", "FEPROM", "EPROM", "CDRAM",
		"3DRAM", "SDRAM", "SGRAM", "RDRAM", "DDR"},
       ModelCorrespondence {"CIM_PhysicalMemory.MemoryType"}]
   uint16 MemoryType;
      [Description ("Minimum amount of memory, in Kbytes, that is "
        "needed for the associated PhysicalElement to operate "
        "correctly. "),
       Units ("KiloBytes")
      ]
   uint64 MinimumMemoryCapacity;
      [Description ("Maximum amount of memory, in Kbytes, that can be "
        "supported by the associated PhysicalElement. "),
       Units ("KiloBytes")
      ]
   uint64 MaximumMemoryCapacity;
};

// ===================================================================
// ConfigurationCapacity 
// ===================================================================
   [Description (
       "ConfigurationCapacity provides information on the minimum and "
       "maximum numbers of power supplies, fans, disk drives, etc. "
       "that can be connected to or placed on/into a PhysicalElement "
       "(and the number that must be connected/added/removed at a "
       "time). The PhysicalElement whose configuration is described is "
       "identified using the ElementCapacity association, inherited "
       "from PhysicalCapacity. The object whose capacities are "
       "indicated (ie, the power supply or fan) is identified in the "
       "ObjectType property of this class. Since the same min/max "
       "configurations can apply to multiple instances, this class is "
       "not defined as 'weak'.\n"
       "Examples of the use of the ConfigurationCapacity class are "
       "to describe that a 'control unit' Chassis may be connected "
       "to (at most) 4 other I/O chassis, or to describe what a "
       "StorageLibrary's cabinet may contain. Continuing the latter "
       "example, a particular StorageLibrary's cabinet might "
       "hold a minimum of 3 and a maximum of 9 TapeDrives, and a "
       "minimum of 88 and a maximum of 264 StorageMediaLocations "
       "(\"Slots\"). This information would be described in two "
       "instances of ConfigurationCapacity, both associated to the "
       "StorageLibrary's PhysicalPackage.\n"
       "This class does NOT represent the tradeoffs that are "
       "likely to be required of one resource for another. It simply "
       "represents capacities. In the case of the StorageLibrary, "
       "there may be only 2 valid configurations - 9 TapeDrives with "
       "88 Slots, or 3 TapeDrives with 264 Slots. This class only "
       "conveys that 'up to' 9 Drives and 'up to' 264 slots may be "
       "available and are supported.")
   ]
class CIM_ConfigurationCapacity : CIM_PhysicalCapacity
{
      [Override ("Name"), Key, 
       Description ("The inherited Name serves as a part of the "
        "ConfigurationCapacity object key.")
      ]
   string Name;
		[Key, 
		Description ("The type of object (power supply, fan, disk "
		"drive, ...) whose capacities are indicated. This information is "
		"part of the class' key."), 
		Values {"Other", "Processors", "Power Supplies", "Fans", 
			"Batteries", "I/O Slots", "Memory Slots", 
			"MediaAccessDevices (Drives)", 
			"StorageMediaLocation Slots", 
			"StorageMediaLocation Magazines", 
			"StorageMediaLocation Panels", 
			"StorageMediaLocation InterLibrary Ports", 
			"StorageMediaLocation Limited Access Ports", "Doors", 
			"MediaTransferDevice Pickers", 
			"MediaTransferDevice Changers", "LabelReaders",
			"Contained Chassis", "Connected Chassis", 
			"Connected Frames", "Front Side I/O Slots", "Back Side I/O Slots",
			"Cache Memory", "NVS Memory", "Volatile Memory"}, 
		ModelCorrespondence {
			"CIM_ConfigurationCapacity.OtherTypeDescription"}
		]
	uint16 ObjectType;
      [Description (
          "A string describing the object type - used when the "
          "ObjectType property is set to 0 (\"Other\"). OtherType"
          "Description should be set to NULL when ObjectType is any "
          "value other than 0."), 
       MaxLen (64), 
       ModelCorrespondence {"CIM_ConfigurationCapacity.ObjectType"}
      ]
   string OtherTypeDescription;
      [Description ("Minimum number of Elements of type, ObjectType, "
        "that must be installed.")
      ]
   uint64 MinimumCapacity;
      [Description (
          "Maximum number of Elements of type, ObjectType, "
          "that may be installed.")
      ]
   uint64 MaximumCapacity;
      [Description ("Increment in which Elements must be added or "
        "removed.")
      ]
   uint32 Increment;
};

// ==================================================================
// ReplacementSet
// ==================================================================
   [Description (
	 "The ReplacementSet class aggregates PhysicalElements that "
       "must be 'replaced' or 'FRUed' together. For example, when "
       "replacing a memory card, the component memory chips could "
       "be removed and replaced as well. Or, a set of memory chips "
       "may be specified to be replaced or upgraded together using "
       "this association.")
   ]
class CIM_ReplacementSet : CIM_ManagedElement
{
	[Key, MaxLen (256),
	 Description (
	  "Name is a free-form string defining a label for the "
	  "ReplacementSet. It is the key for the object.")
	]
   string Name;
};

// ==================================================================
// ParticipatesInSet
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "ParticipatesInSet indicates which PhysicalElements should "
	 "be replaced together.")
   ]
class CIM_ParticipatesInSet
{
	[Key, Aggregate,
	 Description ("The ReplacementSet.")
	]
   CIM_ReplacementSet REF Set;
	[Key, Description (
	  "The PhysicalElement which should be replaced with other "
	  "Elements, as a Set.")
	]
   CIM_PhysicalElement REF Element;
};

// ==================================================================
// PhysicalPackage
// ==================================================================
   [Description (
	 "The PhysicalPackage class represents PhysicalElements that "
	 "contain or host other components. Examples are a Rack "
	 "enclosure or an adapter Card.")
   ]
class CIM_PhysicalPackage : CIM_PhysicalElement
{
   	[Description (
	  "A PhysicalPackage is Removable if it is designed to be "
	  "taken in and out of the physical container in which it is "
	  "normally found, without impairing the function of the "
	  "overall packaging. A Package can still be Removable if "
	  "power must be 'off' in order to perform the removal. If "
	  "power can be 'on' and the Package removed, then the Element "
	  "is both Removable and HotSwappable. For example, an extra "
	  "battery in a laptop is Removable, as is a disk drive Package "
	  "inserted using SCA connectors. However, the latter is also "
	  "HotSwappable.  A laptop's display is not Removable, nor "
	  "is a non-redundant power supply.  Removing these "
	  "components would impact the function of the overall packaging "
	  "or is impossible due to the tight integration of the Package.")
	]
   boolean Removable;
	[Description (
	  "A PhysicalPackage is Replaceable if it is possible to "
	  "replace (FRU or upgrade) the Element with a physically "
	  "different one.  For example, some ComputerSystems "
	  "allow the main Processor chip to be upgraded to one of a "
	  "higher clock rating. In this case, the Processor is said "
	  "to be Replaceable. Another example is a power supply "
	  "Package mounted on sliding rails. All Removable packages "
	  "are inherently Replaceable.")
	]
   boolean Replaceable;
	[Description (
	  "A PhysicalPackage is HotSwappable if it is possible to "
	  "replace the Element with a physically different "
	  "but equivalent one while the containing Package has power "
	  "applied to it (ie, is 'on').  For example, a disk drive "
	  "Package inserted using SCA connectors is both Removable "
	  "and HotSwappable. All HotSwappable packages are inherently "
	  "Removable and Replaceable.")
	]
   boolean HotSwappable;
	[Description (
	  "The height of the PhysicalPackage in inches."),
	 Units ("Inches")
	]
   real32 Height;
	[Description (
        "The depth of the PhysicalPackage in inches."),
       Units ("Inches")
	]
   real32 Depth;
	[Description (
	  "The width of the PhysicalPackage in inches."),
	 Units ("Inches")
	]
   real32 Width;
	[Description (
	  "The weight of the PhysicalPackage in pounds."),
	 Units ("Pounds")
	]
   real32 Weight;
	[Description (
        "The IsCompatible method verifies whether the referenced "
	  "PhysicalElement may be contained by or inserted into "
	  "the PhysicalPackage. The return value should be 0 if "
	  "the request was successfully executed, 1 if the request "
	  "is not supported and some other value if an error "
	  "occurred. In a subclass, the set of possible return codes "
        "could be specified, using a ValueMap qualifier on the "
        "method. The strings to which the ValueMap contents are "
        "'translated' may also be specified in the subclass as a "
        "Values array qualifier.")
      ]
   uint32 IsCompatible([IN] CIM_PhysicalElement REF ElementToCheck);
};

// ==================================================================
// Container
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "The Container association represents the relationship "
	 "between a contained and a containing PhysicalElement. "
	 "A containing object must be a PhysicalPackage.")
   ]
class CIM_Container : CIM_Component
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description (
	  "The PhysicalPackage that contains other PhysicalElements, "
	  "including other Packages.")
	]
   CIM_PhysicalPackage REF GroupComponent;
	[Override ("PartComponent"),
	 Description (
	  "The PhysicalElement which is contained in the Package.")
	]
   CIM_PhysicalElement REF PartComponent;
	[Description (
        "A free-form string representing the positioning of the "
        "PhysicalElement within the PhysicalPackage. Information "
        "relative to stationary elements in the Container (for "
        "example, 'second drive bay from the top'), angles, "
        "altitudes and other data may be recorded in this property. "
        "This string could supplement or be used in place of "
        "instantiating the CIM_Location object.")
	]
   string LocationWithinContainer;
};

// ==================================================================
// PhysicalFrame
// ==================================================================
   [Description ("PhysicalFrame is a superclass of Rack, Chassis and "
       "other frame enclosures, as they are defined in extension "
       "classes. Properties like visible or audible alarm, and data "
       "related to security breaches are in this superclass." )
   ]
class CIM_PhysicalFrame : CIM_PhysicalPackage
{
      [Description ("CableManagementStrategy is a free-form string "
        "that contains information on how the various cables are "
        "connected and bundled for the Frame. With many networking, "
        "storage-related and power cables, cable management can be "
        "a complex and challenging endeavor. This string property "
        "contains information to aid in assembly and service "
        "of the Frame.")
      ]
   string CableManagementStrategy;
      [Description (
	  "ServicePhilosophy is an enumerated, integer-valued "
        "array that indicates whether the Frame is serviced from the "
        "top (value=2), front (3), back (4) or side (5), whether it "
	  "has sliding trays (6) or removable sides (7), and/or whether "
	  "the Frame is moveable (8), for example, having rollers."),
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Service From Top"
             "Service From Front", "Service From Back", 
             "Service From Side", "Sliding Trays", 
             "Removable Sides", "Moveable"},
	 ModelCorrespondence {"CIM_PhysicalFrame.ServiceDescriptions"}
      ]
   uint16 ServicePhilosophy[];
      [Description ("An array of free-form strings providing more "
        "detailed explanations for any of the entries in the Service"
        "Philosophy array. Note, each entry of this array "
        "is related to the entry in ServicePhilosophy that is "
        "located at the same index."),
       ArrayType ("Indexed"),
	 ModelCorrespondence {"CIM_PhysicalFrame.ServicePhilosophy"}
      ]
   string ServiceDescriptions[];
      [Description ("Boolean indicating whether the Frame is protected "
        "with a lock.")
      ]
   boolean LockPresent;
      [Description ("Boolean indicating whether the Frame is equipped "
        "with an audible alarm.")
      ]
   boolean AudibleAlarm; 
      [Description ("Boolean indicating that the equipment includes "
        "a visible alarm.")
      ]
   boolean VisibleAlarm;
      [Description ("SecurityBreach is an enumerated, integer-valued "
        "property indicating whether a physical breach of the Frame "
        "was attempted but unsuccessful (value=4) or attempted and "
	  "successful (5). Also, the values, \"Unknown\", \"Other\" or "
	  "\"No Breach\", can be specified."),
	 ValueMap {"1", "2", "3", "4", "5"},
       Values {"Other", "Unknown", "No Breach", "Breach Attempted", 
             "Breach Successful"},
	 MappingStrings {
	       "MIF.DMTF|Physical Container Global Table|004"},
	 ModelCorrespondence {"CIM_PhysicalFrame.BreachDescription"}
      ]
   uint16 SecurityBreach;
      [Description ("BreachDescription is a free-form string providing "
        "more information if the SecurityBreach property indicates "
        "that a breach or some other security-related event "
        "occurred."),
	 ModelCorrespondence {"CIM_PhysicalFrame.SecurityBreach"}
      ]
   string BreachDescription;
      [Description (
        "Boolean indicating that the Frame is currently locked.")
      ]
   boolean IsLocked;
};

// ==================================================================
//    Rack
// ==================================================================
   [Description (
       "A Rack is a PhysicalFrame that represents an enclosure in "
	 "which Chassis are placed. Typically a Rack is nothing more "
	 "than the enclosure, and all the functioning componentry is "
	 "packaged in the Chassis, loaded in the Rack.")
   ]
class CIM_Rack : CIM_PhysicalFrame
{
	[Override ("Height"),
	 Description (
	  "The height of the PhysicalPackage in 'U's. A 'U' is a "
	  "standard unit of measure for the height of a Rack or "
	  "rack-mountable component. It is equal to 1.75 inches or "
	  "4.445 cm."),
	 Units ("Us")
	]
   real32 Height;
	[Description ("Enumeration indicating the type of Rack."
	  "Information such as \"Telco\" rack (value=2) or standard "
	  "19 inch rack (1) can be specified. The country for which "
	  "the Rack is manufactured is defined in the the Country"
	  "Designation property."),
	 Values {"Unknown", "Standard 19 Inch", "Telco", 
	       "Equipment Shelf", "Non-Standard"},
	 ModelCorrespondence {"CIM_Rack.CountryDesignation"}
	]
   uint16 TypeOfRack;
	[Description ("Designation of the country for which the Rack "
        "is designed. Country code strings are as defined by "
        "ISO/IEC 3166. The rack type is specified in the TypeOf"
        "Rack property."),
       ModelCorrespondence {"CIM_Rack.TypeOfRack"} ]
   string CountryDesignation;
};

// ==================================================================
//    Chassis
// ==================================================================
   [Description (
	 "The Chassis class represents the PhysicalElements that "
	 "enclose other Elements and provide definable functionality, "
	 "such as a desktop, processing node, UPS, disk or tape storage, "
	 "or a combination of these.")
   ]
class CIM_Chassis : CIM_PhysicalFrame
{
	[Description (
	  "Integer indicating the number of power cords which must be "
	  "connected to the Chassis, for all the componentry to "
	  "operate.")
	]
   uint16 NumberOfPowerCords;
   	[Description (
	  "Current required by the Chassis at 120V. If power is "
	  "provided by the Chassis (as in the case of a UPS), this "
	  "property may indicate the amperage produced, as a negative "
	  "number."),
	 Units ("Amps at 120 Volts")
	]
   sint16 CurrentRequiredOrProduced;
	[Description (
	  "Amount of heat generated by the Chassis in BTU/hour."),
	  Units ("BTU per Hour")
	]
   uint16 HeatGeneration;
	[Description (
	  "An enumerated, integer-valued array indicating the type of "
	  "Chassis."),
	 ArrayType ("Indexed"),
	 ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		     "11", "12", "13", "14", "15", "16", "17", "18", "19",
		     "20", "21", "22", "23", "24"},
	 Values {"Other", "Unknown", "Desktop", "Low Profile Desktop",
		 "Pizza Box", "Mini Tower", "Tower", "Portable", "LapTop",
		 "Notebook", "Hand Held", "Docking Station", "All in One",
		 "Sub Notebook", "Space-Saving", "Lunch Box",
		 "Main System Chassis", "Expansion Chassis", "SubChassis",
		 "Bus Expansion Chassis", "Peripheral Chassis",
		 "Storage Chassis", "Rack Mount Chassis",
		 "Sealed-Case PC"},
	 MappingStrings {
		 "MIF.DMTF|Physical Container Global Table|004"},
	 ModelCorrespondence {"CIM_Chassis.TypeDescriptions"}
	]
   uint16 ChassisTypes[];
	[Description (
	  "An array of free-form strings providing more information "
	  "on the ChassisTypes array entries. Note, each entry of this "
	  "array is related to the entry in ChassisTypes that is "
	  "located at the same index."),
	 ArrayType ("Indexed"),
	 ModelCorrespondence {"CIM_Chassis.ChassisTypes"}
	]
   string TypeDescriptions[];
};

// ==================================================================
// ChassisInRack
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "Racks, as simple enclosures, contain Chassis that provide "
	 "the physical componentry realizing processing nodes, "
	 "storage devices, UPSs, etc. The ChassisInRack association "
	 "makes explicit the 'containing' relationship between the "
	 "Rack and the Chassis.")
   ]
class CIM_ChassisInRack : CIM_Container
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description ("The Rack that contains the Chassis.")
	]
   CIM_Rack REF GroupComponent;
	[Override ("PartComponent"),
	 Description ("The Chassis which is mounted in the Rack.")
	]
   CIM_Chassis REF PartComponent;
	[Description (
	  "An integer indicating the lowest or 'bottom' U in which "
	  "the Chassis is mounted. A 'U' is a standard unit of "
	  "measure for the height of a Rack or rack-mountable "
	  "component. It is equal to 1.75 inches or 4.445 cm."),
	 Units ("Us")
	]
   uint16 BottomU;
};

// ==================================================================
// PackageInChassis
// ==================================================================
   [Association,
    Aggregation,
    Description (
       "A Chassis can contain other Packages, such as other Chassis "
       "and Cards. The PackageInChassis association makes explicit "
       "this relationship.")
   ]
class CIM_PackageInChassis : CIM_Container
{
	[Override ("GroupComponent"),
       Aggregate, Max (1),
       Description (
        "The Chassis that contains other PhysicalPackages.")
	]
   CIM_Chassis REF GroupComponent;
      [Override ("PartComponent"),
	 Description (
	  "The PhysicalPackage which is contained in the Chassis.")
	]
   CIM_PhysicalPackage REF PartComponent;
};

// ==================================================================
// Docked
// ==================================================================
   [Association,
    Description (
	 "A laptop, a type of Chassis, may be docked in another "
	 "type of Chassis, a Docking Station. This is the relationship "
	 "represented by the Docked association. Because this is "
	 "such a typical relationship, it is explicitly described."),
    MappingStrings {"MIF.DMTF|Dynamic States|001.2"}
   ]
class CIM_Docked : CIM_Dependency
{
	[Override ("Antecedent"),
	 Max (1),
	 Description ("The Docking Station.")
	]
   CIM_Chassis REF Antecedent;
	[Override ("Dependent"),
	 Max (1),
	 Description ("The Laptop that is 'Docked'.")
	]
   CIM_Chassis REF Dependent;
};

// ==================================================================
// Card
// ==================================================================
   [Description (
	 "The Card class represents a type of physical container that "
	 "can be plugged into another Card or HostingBoard, or is "
	 "itself a HostingBoard/Motherboard in a Chassis. The CIM_Card "
	 "class includes any package capable of carrying signals and "
	 "providing a mounting point for PhysicalComponents, such as "
	 "Chips, or other PhysicalPackages, such as other Cards.")
   ]
class CIM_Card : CIM_PhysicalPackage
{
	[Description (
	  "Boolean indicating that this Card is a Motherboard or, "
	  "more generically, a baseboard in a Chassis.")
	]
   boolean HostingBoard;
	[Description (
	  "SlotLayout is a free-form string that describes the "
	  "slot positioning, typical usage, restrictions, individual "
	  "slot spacings or any other pertinent information for the "
	  "slots on a Card.")
	]
   string SlotLayout;
	[Description (
	  "Boolean indicating that at least one daughterboard or "
	  "auxiliary Card is required in order to function properly.")
	]
   boolean RequiresDaughterBoard;
	[Description ("Boolean indicating that this Card is physically "
	  "unique from other Cards of the same type and therefore "
	  "requires a special Slot. For example, a double-wide Card "
	  "requires two Slots. Another example is where a certain Card "
	  "may be used for the same general function as other Cards but "
	  "requires a special Slot (e.g., extra long), whereas the "
	  "other Cards can be placed in any available Slot. "
	  "If set to TRUE, then the corresponding property, "
	  "RequirementsDescription, should specify the nature of the "
	  "uniqueness or purpose of the Card."),
	 ModelCorrespondence{"CIM_Card.RequirementsDescription"}
	]
   boolean SpecialRequirements;
	[Description ("A free-form string describing the way(s) in which "
	  "this Card is physically unique from other Cards. This "
	  "property only has meaning when the corresponding boolean "
	  "property, SpecialRequirements, is set to TRUE."),
 	 ModelCorrespondence{"CIM_Card.SpecialRequirements"}
	]
   string RequirementsDescription;
      [Description ("Operating voltages required by the Card."),
       Units("MilliVolts")
      ]
   sint16 OperatingVoltages[];
        [Description (
         "This method manipulates the power to a PhysicalConnector on a Card. "
         "It is intended to be used by a Card (especially by a motherboard - "
         "i.e., HostingBoard=TRUE) to turn the power on and off for a "
         "specific PhysicalConnector located on it. For example, in a personal "
         "computer, a system slot does not know how to turn itself on and off. "
         "However, the motherboard hosting this slot may have that capability. "
         "This is important in order to support hot swapping of an adapter card "
         "in a system slot. The method should return 0 if successful, 1 if the request "
         "is not supported, and some other value if any other error occurred. In "
         "a subclass, the set of possible return codes could be specified, using "
         "a ValueMap qualifier on the method. The strings to which the ValueMap "
         "contents are 'translated' may also be specified in the subclass as a "
         "Values array qualifier.") ]
   uint32 ConnectorPower([IN] CIM_PhysicalConnector REF Connector,
                         [IN] boolean PoweredOn);
};

// ==================================================================
// SystemBusCard
// ==================================================================
   [Description (
       "The SystemBusCard class represents additional information "
       "for a CIM_Card, detailing the Card's bus type and data width. "
       "These properties dictate the type of Slot into which the Card "
       "can be inserted. For example, using the properties of this "
       "class, one can define that a Card is a PCI, 64 bit adapter.")
   ]
class CIM_SystemBusCard : CIM_Card
{
      [Description (
        "An enumerated integer describing the System bus type for "
        "this Card. It indicates the type of Slot into which the "
        "Card can plug. The list of permissible values aligns with "
        "the System bus types in CIM_PhysicalConnector.Connector"
        "Type."),
       ValueMap {"43", "44", "45", "46", "47", "48", "49", "50", 
               "52", "64", "65", "73", "74", "75", "76", "77", "78", 
               "79", "80", "81", "82", "83", "84", "85", "86", "87", 
               "98", "99", "100", "101", "102", "103", "104", "105", 
               "106", "109", "110"},
       Values {"PCI", "ISA", "EISA", "VESA", "PCMCIA", 
             "PCMCIA Type I", "PCMCIA Type II", "PCMCIA Type III", 
             "CardBus", "Access.bus", "NuBus", "AGP", "VME Bus", 
             "VME64", "Proprietary", 
             "Proprietary Processor Card Slot", 
             "Proprietary Memory Card Slot", 
             "Proprietary I/O Riser Slot", "PCI-66MHZ", "AGP2X", 
             "AGP4X", "PC-98", "PC-98-Hireso", "PC-H98", 
             "PC-98Note", "PC-98Full", "PCI-X", 
             "Sbus IEEE 1396-1993 32 bit", 
             "Sbus IEEE 1396-1993 64 bit", "MCA", "GIO", "XIO", 
             "HIO", "NGIO", "PMC", "Future I/O", "InfiniBand"},
       ModelCorrespondence {"CIM_PhysicalConnector.ConnectorType"}
      ]
   uint16 BusType;
      [Description (
        "System bus width (in bits) required by this Card. If "
        "'unknown', enter 0. If 'other' than the values, 8, 16, "
        "32, 64 or 128, enter 1. The list of permissible values "
        "aligns with the data in CIM_Slot.MaxBusWidth."),
       Units ("Bits"),
       ValueMap {"0", "1", "8", "16", "32", "64", "128"},
       ModelCorrespondence {"CIM_Slot.MaxBusWidth"}
      ]
   uint16 BusWidth;
};

// ==================================================================
// CardOnCard
// ==================================================================
   [Association,
    Aggregation,
    Description (
	  "Cards may be plugged into Motherboards/baseboards, are "
	  "daughtercards of an adapter, or support special Card-like "
	  "modules. These relationships are described by the CardOnCard "
	  "association.")
   ]
class CIM_CardOnCard : CIM_Container
{
	[Override ("GroupComponent"),
	 Aggregate,
       Max (1),
	 Description ("The Card that hosts another Card.")
	]
   CIM_Card REF GroupComponent;
	[Override ("PartComponent"),
	 Description (
	  "The Card that is plugged into or otherwise mounted on "
	  "another Card.")
	]
   CIM_Card REF PartComponent;
	[Description (
	  "A string describing and identifying how the Card is "
	  "mounted on or plugged into the 'other' Card. Slot "
	  "information could be included in this field and may be "
	  "sufficient for certain management purposes. If so, "
	  "this avoids creating instantiations of Connector/Slot "
	  "objects just to model the relationship of Cards to "
	  "HostingBoards or other adapters. On the other hand, "
	  "if Slot and Connector information is available, this "
	  "field could be used to provide more detailed mounting "
	  "or slot insertion data.")
	]
   string MountOrSlotDescription;
};

// ===================================================================
// StorageMediaLocation 
// ===================================================================
   [Description (
       "StorageMediaLocation is a PhysicalElement where PhysicalMedia "
       "may be placed. This class describes an entity that holds Media "
       "and is not just a 'place' (as is conveyed by the CIM_Location "
       "object). This class is typically used in the context of a "
       "StorageLibrary. Examples of StorageMediaLocations are Media"
       "AccessDevices, InterLibraryPorts or 'slots' in a Library's "
       "panel.")
   ]
class CIM_StorageMediaLocation : CIM_PhysicalPackage
{
      [Description (
        "The type of Location. For example, whether this is an "
        "individual Media \"Slot\" (value=2), a MediaAccessDevice "
        "(value=4) or a \"Magazine\" (value=3) is indicated in this "
        "property."),
       Values {"Unknown", "Other", "Slot", "Magazine", 
             "MediaAccessDevice", "InterLibrary Port", 
             "Limited Access Port", "Door", "Shelf", "Vault"}
      ]
   uint16 LocationType;
      [Description (
        "LocationCoordinates represent the physical location of the "
        "the StorageMediaLocation instance. The property is defined "
        "as a free-form string to allow the location information to "
        "be described in vendor-unique terminology.")
      ]
   string LocationCoordinates;
      [Description (
          "  Certain StorageMediaLocations may only be able to accept a "
          "limited set of PhysicalMedia MediaTypes. This property "
          "defines an array containing the types of Media that are "
          "acceptable for placement in the Location. Additional "
          "information and description of the contained MediaTypes "
          "can be provided using the TypesDescription array. Also, "
          "size data (for example, DVD disc diameter) can be specified "
          "using the MediaSizesSupported array. \n\n"
          "  Values defined here correspond to those in the CIM_Physical"
          "Media.MediaType property. This allows quick comparisons using "
          "value equivalence calculations. It is understood that there "
          "is no external physical difference between (for example) DVD-"
          "Video and DVD-RAM. But, equivalent values in both the Physical"
          "Media and StorageMediaLocation enumerations allows for one "
          "for one comparisons with no additional processing logic "
          "(i.e., the following is not required ... if \"DVD-Video\" "
          "then value=\"DVD\")."),
       ArrayType ("Indexed"), 
       Values {"Unknown", "Other", "Tape Cartridge", "QIC Cartridge", 
             "AIT Cartridge", "DTF Cartridge", "DAT Cartridge", 
             "8mm Tape Cartridge", "19mm Tape Cartridge", 
             "DLT Cartridge", "Half-Inch Magnetic Tape Cartridge", 
             "Cartridge Disk", "JAZ Disk", "ZIP Disk", "SyQuest Disk", 
             "Winchester Removable Disk", "CD-ROM", "CD-ROM/XA", 
             "CD-I", "CD Recordable", "WORM", "Magneto-Optical", 
             "DVD", "DVD-RW+", "DVD-RAM", "DVD-ROM", "DVD-Video", 
             "Divx", "Floppy/Diskette", "Hard Disk", "Memory Card", 
             "Hard Copy", "Clik Disk", "CD-RW", "CD-DA", "CD+", 
             "DVD Recordable", "DVD-RW", "DVD-Audio", "DVD-5", "DVD-9", 
             "DVD-10", "DVD-18", "Magneto-Optical Rewriteable", 
             "Magneto-Optical Write Once", 
             "Magneto-Optical Rewriteable (LIMDOW)", 
             "Phase Change Write Once", "Phase Change Rewriteable", 
             "Phase Change Dual Rewriteable", "Ablative Write Once", 
             "Near Field Recording", "MiniQic", "Travan", 
             "8mm Metal Particle", "8mm Advanced Metal Evaporate", 
             "NCTP", "LTO Ultrium", "LTO Accelis", "9 Track Tape", 
             "18 Track Tape", "36 Track Tape", "Magstar 3590", 
             "Magstar MP", "D2 Tape", "Tape - DST Small", 
             "Tape - DST Medium", "Tape - DST Large"}, 
       ModelCorrespondence {"CIM_PhysicalMedia.MediaType", 
             "CIM_StorageMediaLocation.MediaSizesSupported"}
      ]
   uint16 MediaTypesSupported[];
      [Description (
           "The sizes (in inches) of the particular MediaTypes that may "
           "be placed in the Location. Note, each entry of this array "
           "is related to the entry in the MediaTypesSupported array that "
           "is located at the same index."), 
       ArrayType ("Indexed"), Units ("Inches"), 
       ModelCorrespondence {"CIM_PhysicalMedia.MediaType", 
             "CIM_StorageMediaLocation.MediaSizesSupported",
			 "CIM_StorageMediaLocation.TypeDescriptions"}
      ]
   real32 MediaSizesSupported[];
      [Description (
        "A StorageMediaLocation may hold more than one PhysicalMedia - "
        "for example, a Magazine. This property indicates the Physical"
        "Media capacity of the Location.")
      ]
   uint32 MediaCapacity;
         [Description (
        "This property provides additional detail related to the "
        "entries in the MediaTypesSupported array. This is "
        "especially critical when the MediaTypesSupported value "
        "is 1 (\"Other\"). Note, each entry of this array is "
        "related to the entry in MediaTypesSupported that is "
        "located at the same index. "),
       ArrayType ("Indexed"),
       ModelCorrespondence {
           "CIM_StorageMediaLocation.MediaTypesSupported"}
      ]
   string TypeDescriptions[];
};

// ===================================================================
// Magazine 
// ===================================================================
   [Description (
       "StorageMediaLocations are typically slots or spaces where "
       "removable media are located. However, a specific kind of "
       "MediaLocation is a Magazine. This entity represents a single "
       "physical container with multiple StorageMediaLocations in it. "
       "All the MediaLocations within the Magazine are added/removed "
       "together. Often, this container has a Barcode or other label "
       "for identification. This is the unique data captured in the "
       "CIM_Magazine class.  Magazine's label properties are defined "
       "exactly as are labels for PhysicalMedia. ")
   ]
class CIM_Magazine : CIM_StorageMediaLocation 
{
      [Description (
        "One or more strings on 'labels' on the Magazine. The "
        "format of the labels and their state (readable, unreadable, "
        "upside-down) are indicated in the corresponding LabelFormats "
        "and LabelStates array properties."), 
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_Magazine.LabelStates", 
                "CIM_Magazine.LabelFormats"}
      ]
   string PhysicalLabels[];
      [Description (
        "An array of enumerated integers describing the states of "
        "each of the labels on a Magazine. The Labels themselves "
        "are listed in the PhysicalLabels property. Note, each entry of "
        "this array is related to the entry in PhysicalLabels that is "
        "located at the same index."),
       ArrayType ("Indexed"), 
       Values {"OK/Readable", "Unreadable", "Upside Down"}, 
       ModelCorrespondence {"CIM_Magazine.PhysicalLabels"}
      ]
   uint16 LabelStates[];
      [Description (
        "An array of enumerated integers describing the formats of "
        "each of the labels on a Magazine. The Labels themselves "
        "are listed in the PhysicalLabels property. Note, each entry of "
        "this array is related to the entry in PhysicalLabels that is "
        "located at the same index."), 
       ArrayType ("Indexed"), 
       Values {"Barcode", "Radio Frequency Identification", 
             "OCR (Optical Character Recognition)", 
             "MICR (Magnetic Ink Character Recognition)",
             "7 Character Barcode", "9 Character Barcode"}, 
       ModelCorrespondence {"CIM_Magazine.PhysicalLabels"}
      ]
   uint16 LabelFormats[];
};

// ===================================================================
// DeviceServicesLocation 
// ===================================================================
   [Association, Description (
       "Within an automated StorageLibrary, Media should be accessible "
       "to the various robotics and MediaTransferDevices (Pickers, "
       "Changers, InterLibraryPorts, etc.). The Library may be "
       "serviced by different TransferDevices, each responsible for "
       "a subset of the Library's StorageMediaLocations. The Device"
       "ServicesLocation association indicates that the Transfer"
       "Device handles Media stored in the referenced Location. "
       "For example, LibraryPort 'A' may only service Media from "
       "Slots 1-10, while LibraryPort 'B' covers Slots 11-33. "
       "This detail is conveyed by this association.")
   ]
class CIM_DeviceServicesLocation : CIM_Dependency
{
      [Override ("Antecedent"), Description (
        "The MediaTransferDevice that handles Media from the "
        "StorageMediaLocation.")
      ]
   CIM_MediaTransferDevice REF Antecedent;
      [Override ("Dependent"), Description (
        "The MediaLocation that is serviced.")
      ]
   CIM_StorageMediaLocation REF Dependent;
      [Description (
        "Boolean indicating that the referenced StorageMediaLocation "
        "is not currently accessible to the MediaTransferDevice. For "
        "example, the Location could be the realization of an "
        "InterLibraryPort that is currently servicing another "
        "Library. The DeviceServicesLocation association describes "
        "that the TransferDevice COULD service the MediaLocation. "
        "This boolean indicates that that this is temporarily not "
        "possible.")
      ] 
   boolean Inaccessible;

};

// ==================================================================
// PhysicalComponent
// ==================================================================
   [Description (
       "The PhysicalComponent class represents any low-level or "
       "basic Component within a Package. A Component object either "
       "can not or does not need to be decomposed into its "
       "constituent parts. For example, an ASIC (or Chip) can not be "
       "further decomposed. A tape for data storage (PhysicalMedia) "
       "does not need to be decomposed. Any PhysicalElement that is "
       "not a Link, Connector, or Package is a descendent (or "
       "member) of this class. For example, the UART chipset on an "
       "internal modem Card would be a subclass (if additional "
       "properties or associations are defined) or an instance of "
       "PhysicalComponent.")
   ]
class CIM_PhysicalComponent : CIM_PhysicalElement
{
	[Description (
	  "A PhysicalComponent is Removable if it is designed to be "
	  "taken in and out of the physical container in which it is "
	  "normally found, without impairing the function of the "
	  "overall packaging. A Component can still be Removable if "
	  "power must be 'off' in order to perform the removal. If "
	  "power can be 'on' and the Component removed, then the Element "
	  "is both Removable and HotSwappable. For example, an "
	  "upgradeable Processor chip is Removable.")
	]
   boolean Removable;
	[Description (
	  "A PhysicalComponent is Replaceable if it is possible to "
	  "replace (FRU or upgrade) the Element with a physically "
	  "different one.  For example, some ComputerSystems "
	  "allow the main Processor chip to be upgraded to one of a "
	  "higher clock rating. In this case, the Processor is said "
	  "to be Replaceable. All Removable Components are "
	  "inherently Replaceable.")
	]
   boolean Replaceable;
	[Description (
	  "A PhysicalComponent is HotSwappable if it is possible to "
	  "replace the Element with a physically different "
	  "but equivalent one while the containing Package has power "
	  "applied to it (ie, is 'on').  For example, a fan Component "
	  "may be designed to be HotSwappable. All HotSwappable "
	  "Components are inherently Removable and Replaceable.")
	]
   boolean HotSwappable;
};

// ==================================================================
// PackagedComponent 
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "A Component is typically contained by a PhysicalPackage, such "
	 "as a Chassis or Card. The PackagedComponent association makes "
	 "this relationship explicit. In the first sentence, the word, "
	 "'typically', is used. This is because a Component may be "
	 "removed from, or not yet inserted into, its containing "
	 "Package (ie, the Removable boolean is TRUE). Therefore, a "
	 "Component may not always be associated with a container.")
   ]
class CIM_PackagedComponent : CIM_Container
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description ("The PhysicalPackage that contains Component(s).")
	]
   CIM_PhysicalPackage REF GroupComponent;
	[Override ("PartComponent"),
	 Description (
	  "The PhysicalComponent which is contained in the Package.")
	]
   CIM_PhysicalComponent REF PartComponent;
};

// ==================================================================
// Chip
// ==================================================================
   [Description (
	 "The Chip class represents any type of integrated circuit "
	 "hardware, including ASICs, processors, memory chips, etc.")
   ]
class CIM_Chip : CIM_PhysicalComponent
{
	[Description ("The implementation form factor for the Chip."
	  "For example, values such as SIMM (7), TSOP (9) or PGA (10) "
	  "can be specified."),
    Values {"Unknown", "Other", "SIP", "DIP", "ZIP", "SOJ", 
          "Proprietary", "SIMM", "DIMM", "TSOP", "PGA", "RIMM",
          "SODIMM", "SRIMM", "SMD", "SSMP", "QFP", "TQFP", "SOIC", 
             "LCC", "PLCC", "BGA", "FPBGA", "LGA"}
      ]
   uint16 FormFactor;
};

// ==================================================================
// PhysicalMemory
// ==================================================================
   [Description (
	 "PhysicalMemory is a subclass of CIM_Chip, representing "
	 "low level memory devices - SIMMS, DIMMs, raw memory chips, "
	 "etc.")
   ]
class CIM_PhysicalMemory : CIM_Chip
{
	[Override ("FormFactor"),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint16 FormFactor;
	[Description ("The type of PhysicalMemory."),
	Values {"Unknown", "Other", "DRAM", "Synchronous DRAM",
	"Cache DRAM", "EDO", "EDRAM", "VRAM", "SRAM", "RAM",
	"ROM", "Flash", "EEPROM", "FEPROM", "EPROM", "CDRAM",
	"3DRAM", "SDRAM", "SGRAM", "RDRAM", "DDR"},
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint16 MemoryType;
	[Description (
	  "Total width, in bits, of the PhysicalMemory, including check "
	  "or error correction bits. If there are no error correction "
	  "bits, the value in this property should match that specified "
	  "for DataWidth."),
	 Units ("Bits"),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint16 TotalWidth;
	[Description (
	  "Data width of the PhysicalMemory, in bits. A data width of 0 "
	  "and a TotalWidth of 8 would indicate that the Memory is "
	  "solely used to provide error correction bits."),
	 Units ("Bits"),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint16 DataWidth;
	[Description ("The speed of the PhysicalMemory, in nanoseconds."),
	 Units ("NanoSeconds"),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint32 Speed;
	[Description (
	  "The total capacity of this PhysicalMemory, in bytes."),
	 Units ("Bytes"),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   uint64 Capacity;
	[Description (
	  "A string identifying the physically labeled bank where the "
	  "Memory is located - for example, 'Bank 0' or 'Bank A'."),
	 MaxLen (64),
	 MappingStrings {"MIF.DMTF|Memory Device|005"}
	]
   string BankLabel;
	[Description (
	  "Specifies the position of the PhysicalMemory in a 'row'. For "
	  "example, if it takes two 8-bit memory devices to form a 16-"
	  "bit row, then a value of '2'means that this Memory is the "
	  "second device. 0 is an invalid value for this property."),
	 MappingStrings {"MIF.DMTF|Memory Device Mapped Addresses|001.6"}
	]
   uint32 PositionInRow;
	[Description (
	  "The position of this PhysicalMemory in an interleave. 0 "
	  "indicates non-interleaved. 1 indicates the first position, 2 "
	  "the second position and so on. For example, in a 2:1 "
	  "interleave, a value of '1' would indicate that the Memory "
	  "is in the 'even' position."),
	 MappingStrings {"MIF.DMTF|Memory Device Mapped Addresses|001.7"}
	]
   uint32 InterleavePosition;
};

// ==================================================================
// MemoryOnCard 
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "PhysicalMemory can be located on HostingBoards, adapter Cards, "
	 "etc. This association explicitly defines this relationship of "
	 "Memory to Cards.")
   ]
class CIM_MemoryOnCard : CIM_PackagedComponent
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description ("The Card that includes or 'contains' Memory.")
	]
   CIM_Card REF GroupComponent;
	[Override ("PartComponent"),
	 Description (
	  "The PhysicalMemory which is located on the Card.")
	]
   CIM_PhysicalMemory REF PartComponent;
};

// ==================================================================
// PhysicalMedia
// ==================================================================
   [Description (
 	 "The PhysicalMedia class represents any type of documentation "
	 "or storage medium, such as tapes, CDROMs, etc. This class "
	 "is typically used to locate and manage Removable Media "
	 "(versus Media sealed with the MediaAccessDevice, as a single "	
	 "Package, as is the case with hard disks). However, 'sealed' "
	 "Media can also be modeled using this class, where the Media "
	 "would then be associated with the PhysicalPackage using the "
	 "PackagedComponent relationship.")
   ]
class CIM_PhysicalMedia : CIM_PhysicalComponent
{
	[Description (
        "The number of bytes that can be read from or written to a "
        "Media. This property is not applicable to \"Hard Copy\" "
        "(documentation) or cleaner Media. Data compression should not "
        "be assumed, as it would increase the value in this property. "
        "For tapes, it should be assumed that no filemarks or blank "
        "space areas are recorded on the Media."),
	 Units ("Bytes")
	]
   uint64 Capacity; 
	[Description (
	  "Specifies the type of the PhysicalMedia, as an enumerated "
	  "integer. The MediaDescription property is "
	  "used to provide more explicit definition of the Media type, "
	  "whether it is pre-formatted, compatability features, etc."),
	 Values {"Unknown", "Other", "Tape Cartridge", "QIC Cartridge",
		 "AIT Cartridge", "DTF Cartridge", "DAT Cartridge",
		 "8mm Tape Cartridge", "19mm Tape Cartridge",
	       "DLT Cartridge", "Half-Inch Magnetic Tape Cartridge",
		 "Cartridge Disk", "JAZ Disk", "ZIP Disk", "SyQuest Disk",
	   	 "Winchester Removable Disk", "CD-ROM", "CD-ROM/XA",
		 "CD-I", "CD Recordable", "WORM", "Magneto-Optical", "DVD",
		 "DVD-RW+", "DVD-RAM", "DVD-ROM", "DVD-Video", "Divx",
		 "Floppy/Diskette", "Hard Disk", "Memory Card",
		 "Hard Copy", "Clik Disk", "CD-RW", "CD-DA", "CD+", 
             "DVD Recordable", "DVD-RW", "DVD-Audio", "DVD-5", "DVD-9", 
             "DVD-10", "DVD-18", "Magneto-Optical Rewriteable", 
             "Magneto-Optical Write Once", 
             "Magneto-Optical Rewriteable (LIMDOW)", 
             "Phase Change Write Once", "Phase Change Rewriteable", 
             "Phase Change Dual Rewriteable", "Ablative Write Once", 
             "Near Field Recording", "MiniQic", "Travan", 
             "8mm Metal Particle", "8mm Advanced Metal Evaporate", 
             "NCTP", "LTO Ultrium", "LTO Accelis", "9 Track Tape", 
             "18 Track Tape", "36 Track Tape", "Magstar 3590", 
             "Magstar MP", "D2 Tape", "Tape - DST Small ", 
             "Tape - DST Medium", "Tape - DST Large"},
	 ModelCorrespondence {"CIM_PhysicalMedia.MediaDescription"}
	]
   uint16 MediaType;
	[Description (
	  "Additional detail related to the MediaType enumeration. For "
	  "example, if value 3 (\"QIC Cartridge\") is specified, this "
	  "property could indicate whether the tape is wide or 1/4 inch, "
	  "whether it is pre-formatted, whether it is Travan compatible, "
	  "etc."),
	 ModelCorrespondence {"CIM_PhysicalMedia.MediaType"}
	]
   string MediaDescription;
	[Description (
	  "Boolean specifying whether the Media is currently write "
	  "protected by some kind of physical mechanism, such as a "
	  "protect tab on a floppy diskette.")
	]
   boolean WriteProtectOn;
	[Description ("Boolean indicating that the PhysicalMedia "
	  "is used for cleaning purposes and not data storage.")
	]
   boolean CleanerMedia;
      [Description (
        "Size of the Media in inches. For example, '3.5' would "
        "be entered for a 3.5 inch disk, or '12' would be entered "
        "for a 12 inch optical disk. On the other hand, '0.5' would "
        "be defined for a 1/2 inch tape."),
      Units ("Inches")
      ]
   real32 MediaSize;
      [Description (
        "For removable Media, the maximum number of times that "
        "the Media can be mounted before it should be retired. For "
        "cleaner Media, this is the maximum number of Drive cleans "
        "that can be performed. For nonremovable Media, such as hard "
        "disks, this property is not applicable and should be set to "
        "0.")
      ]
   uint64 MaxMounts;
      [Description (
        "For removable or cleaner Media, the number of times that "
        "the Media has been mounted for data transfer or to clean a "
        "Drive. For nonremovable Media, such as hard disks, "
        "this property is not applicable and should be set to 0."),
       Counter, 
       ModelCorrespondence {"CIM_PhysicalMedia.MaxMounts"}
      ]
   uint64 MountCount;
      [Description (
        "Boolean indicating that the Media has two recording sides "
        "(TRUE) or only a single side (FALSE). Examples of dual "
        "sided Media include DVD-ROM and some optical disks. Examples "
        "of single sided Media are tapes and CD-ROM.")
      ]
   boolean DualSided;
      [Description (
        "One or more strings on 'labels' on the PhysicalMedia. "
        "The format of the labels and their state (readable, "
        "unreadable, upside-down) are indicated in the LabelFormats and "
        "LabelStates array properties."), 
       ArrayType ("Indexed"),
       ModelCorrespondence {"CIM_PhysicalMedia.LabelStates", 
                "CIM_PhysicalMedia.LabelFormats"}
      ]
   string PhysicalLabels[];
      [Description (
        "An array of enumerated integers describing the states of "
        "each of the labels on a PhysicalMedia. The Labels themselves "
        "are listed in the PhysicalLabels property. Note, each entry of "
        "this array is related to the entry in PhysicalLabels that is "
        "located at the same index."),
       ArrayType ("Indexed"), 
       Values {"OK/Readable", "Unreadable", "Upside Down"}, 
       ModelCorrespondence {"CIM_PhysicalMedia.PhysicalLabels"}
      ]
   uint16 LabelStates[];
      [Description (
        "An array of enumerated integers describing the formats of "
        "each of the labels on a PhysicalMedia. The Labels themselves "
        "are listed in the PhysicalLabels property. Note, each entry of "
        "this array is related to the entry in PhysicalLabels that is "
        "located at the same index."), 
       ArrayType ("Indexed"), 
       Values {"Barcode", "Radio Frequency Identification", 
             "OCR (Optical Character Recognition)", 
             "MICR (Magnetic Ink Character Recognition)",
             "7 Character Barcode", "9 Character Barcode"},
       ModelCorrespondence {"CIM_PhysicalMedia.PhysicalLabels"}
      ]
   uint16 LabelFormats[];
         [Description (
        "For removable or cleaner Media, the date and time that the "
        "Media was last mounted. For nonremovable Media, such as "
        "hard disks, this property has no meaning and is not applicable.")
      ]
   datetime TimeOfLastMount;
      [Description (
        "For removable or cleaner Media, the total time (in seconds) "
        "that the Media has been mounted for data transfer or to clean a "
        "Drive. For nonremovable Media, such as hard disks, "
        "this property is not applicable and should be set to 0.")
      ]
   uint64 TotalMountTime;
};

// ===================================================================
// MediaPhysicalStatInfo
// ===================================================================
   [Description (
       "Statistics related to reading physical labels and picks/puts "
       "at a specific StorageMediaLocation, or for a specific piece "
       "of PhysicalMedia. Although the same class is used to represent "
       "this data, at the instance level the object holds information "
       "for the Location (independent of the Media), OR for the Media "
       "(independent of its StorageMediaLocation).")
   ]
class CIM_MediaPhysicalStatInfo : CIM_PhysicalStatisticalInformation
{
      [Description (
        "The number of successful physical label scans."),
       Counter
      ]
   uint64 ScanSuccesses;
      [Description (
        "The number of failed physical label scans."),
       Counter
      ]
   uint64 ScanFailures;
      [Description (
        "The number of retried physical label scans."),
       Counter
      ]
   uint64 ScanRetries;
      [Description (
        "The number of successful picks."),
       Counter
      ]
   uint64 PickSuccesses;
      [Description ("The number of failed picks."),
       Counter
      ]
   uint64 PickFailures;
      [Description ("The number of retried picks."),
       Counter
      ]
   uint64 PickRetries;
      [Description ("The number of successful puts."),
       Counter
      ]
   uint64 PutSuccesses;
      [Description ("The number of failed puts."),
       Counter
      ]
   uint64 PutFailures;
      [Description ("The number of retried puts."),
       Counter
      ]
   uint64 PutRetries;
      [Description (
         "Method to reset the statistical counters. The method "
         "takes one parameter as input - an integer indicating which "
         "counter to reset. For this input parameter, 0 indicates all, "
         "1-3 reset the scan-related counters, 4-6 reset the "
         "'pick'-related counters, and 7-9 reset the 'put'-related "
         "counters. The method returns 0 if successful, 1 if not supported, "
         "and any other value if an error occurred. A method is specified "
         "so that the Element's instrumentation can also reset its "
         "internal processing and counters. The set of possible return "
         "codes should be specified in a ValueMap qualifier on the method. "
         "The strings to which the ValueMap contents are 'translated' "
         "should be specified as a Values array qualifier on the method.")
      ]
   uint32 ResetCounter ([IN, Values {"All", "Scan Successes",
    "Scan Failures", "Scan Retries", "Pick Successes", 
    "Pick Failures", "Pick Retries", "Put Successes", 
    "Put Failures", "Put Retries"}] uint16 SelectedCounter);
};

// ==================================================================
// MemoryWithMedia
// ==================================================================
   [Association,
    Description ("MemoryWithMedia indicates that Memory is associated "
	 "with a PhysicalMedia and its cartridge. The Memory provides "
	 "media identification and also stores user-specific data. ")
   ]
class CIM_MemoryWithMedia : CIM_Dependency
{
	[Override ("Antecedent"),
	 Description ("The Memory associated with PhysicalMedia. ")
	]
   CIM_PhysicalMemory REF Antecedent;
	[Override ("Dependent"),
	 Description ("The PhysicalMedia.")
	]
   CIM_PhysicalMedia REF Dependent;
};

// ===================================================================
// PhysicalMediaInLocation
// ===================================================================
   [Association, Description (
       "Within a StorageLibrary, all Media should be accounted for, "
       "and be present in some Storage Location. This relationship "
       "is made explicit by the PhysicalMediaInLocation association."
       "In addition, one can determine if a Location is empty or "
       "full based on whether this association exists for the "
       "StorageMediaLocation.")
   ]
class CIM_PhysicalMediaInLocation : CIM_Dependency
{
      [Override ("Antecedent"), Description (
        "The StorageMediaLocation which holds the PhysicalMedia."), 
       Max (1)
      ]
   CIM_StorageMediaLocation REF Antecedent;
      [Override ("Dependent"), Description (
        "The Media in the Location.")
      ]
   CIM_PhysicalMedia REF Dependent;
         [Description (
        "An enumeration expressing which 'Side' of the Media is "
        "facing up. Since sides can be named by various schemes (0/1 or "
        "A/B), both schemes are expressed in the Values array of this "
        "property. Also, the value 5 (\"Not Applicable\" describes that "
        "orientation is not pertinent for this Media."),
       Values {"Unknown", "Side 0", "Side 1", "Side A", 
        "Side B", "Not Applicable"}
      ]
   uint16 Orientation;
      [Description (
        "The date and time that the Media was last placed into the "
        "referenced Location.")
      ]
   datetime TimeOfLastPlacement;
};

// ==================================================================
// PhysicalTape 
// ==================================================================
   [Description (
       "The PhysicalTape class represents additional data for a Tape "
       "Media. Information on the tape length and whether it must be "
       "unloaded from BOT are properties of this class.")
   ]
class CIM_PhysicalTape : CIM_PhysicalMedia
{
      [Description ("The physical length of the Tape in feet."), 
       Units ("Feet")
      ]
   real32 TapeLength;
      [Description (
        "Boolean set to TRUE if the Tape can be unloaded at any "
        "position on the Media. It is set to FALSE if the tape must "
        "be at a certain position for unload - such as at the beginning "
        "of tape (BOT) area, or at mid-tape point for TapeDrives with "
        "mid-tape load.")
      ]
   boolean UnloadAnywhere;
};

// ===================================================================
// RealizesExtent
// ===================================================================
   [Association, Description (
       "StorageExtents can be realized by PhysicalComponents. For "
       "example, disks or tapes are realized by PhysicalMedia. Memory "
       "is realized by PhysicalMemory. This relationship of Extents "
       "to PhysicalComponents is made explicit by the RealizesExtent "
       "association. In addition, the StartingAddress of the "
       "StorageExtent on the Component is specified here.")
   ]
class CIM_RealizesExtent : CIM_Realizes
{
      [Override ("Antecedent"), Description (
        "The PhysicalComponent on which the Extent is realized."), 
       Max (1)
      ]
   CIM_PhysicalComponent REF Antecedent;
      [Override ("Dependent"), Description (
        "The StorageExtent that is located on the Component.")
      ]
   CIM_StorageExtent REF Dependent;
      [Description (
        "The starting address on the PhysicalComponent where the "
        "StorageExtent begins. Ending address of the StorageExtent "
        "is determined using the NumberOfBlocks and Block"
        "Size properties of the StorageExtent object.")
      ]
   uint64 StartingAddress;
};

// ===================================================================
// RealizesPExtent
// ===================================================================
   [Association,
    Description (
	 "PhysicalExtents are realized on a PhysicalMedia. This "
	 "relationship is made explicit by the RealizesPExtent "
	 "association.  In addition, the StartingAddress of the "
	 "PhysicalExtent on the PhysicalMedia is specified here.")
   ]
class CIM_RealizesPExtent : CIM_RealizesExtent
{
	[Override ("Antecedent"),
	 Description (
	  "The PhysicalMedia on which the Extent is realized."),
	 Max (1)
	]
   CIM_PhysicalMedia REF Antecedent;
	[Override ("Dependent"),
	 Description (
	  "The PhysicalExtent that is located on the Media.")
	]
   CIM_PhysicalExtent REF Dependent;
};

// ===================================================================
// RealizesDiskPartition
// ===================================================================
   [Association,
    Description (
       "DiskPartitions can be directly realized on a PhysicalMedia. "
       "This is used to model the creation of Partitions on a raw SCSI "
       "or IDE drive, using the fdisk (DOS and Unix) or pdisk (Unix) "
       "command. The StartingAddress of the DiskPartition on the "
       "PhysicalMedia is also specified as a property of this "
       "relationship. An alternative is that Partitions can "
       "be BasedOn StorageVolumes, such as a VolumeSet or a Volume "
       "exposed by a hardware RAID cabinet. The latter relationship is "
       "modeled using the DiskPartitionBasedOnVolume association.")
   ]
class CIM_RealizesDiskPartition : CIM_RealizesExtent
{
	[Override ("Antecedent"),
	 Description (
	  "The PhysicalMedia on which the Extent is realized."),
	 Max (1)
	]
   CIM_PhysicalMedia REF Antecedent;
	[Override ("Dependent"),
	 Description (
	  "The DiskPartition that is located on the Media.")
	]
   CIM_DiskPartition REF Dependent;
};

// ===================================================================
// RealizesAggregatePExtent
// ===================================================================
   [Association,
    Description (
	 "AggregatePExtents are realized on a PhysicalMedia. This "
	 "relationship is made explicit by the RealizesAggregatePExtent "
	 "association.")
   ]
class CIM_RealizesAggregatePExtent : CIM_RealizesExtent
{
	[Override ("Antecedent"),
	 Description (
	  "The PhysicalMedia on which the Extent is realized."),
	 Max (1)
	]
   CIM_PhysicalMedia REF Antecedent;
	[Override ("Dependent"),
	 Description (
	   "The AggregatePExtent that is located on the Media.")
	]
   CIM_AggregatePExtent REF Dependent;
};

// ===================================================================
// RealizesTapePartition 
// ===================================================================
   [Association, Description (
       "TapePartitions are realized on PhysicalTape. This "
       "relationship is made explicit by the RealizesTapePartition "
       "association.")
   ]
class CIM_RealizesTapePartition : CIM_RealizesExtent
{
      [Override ("Antecedent"), Description (
        "The PhysicalTape on which the Partition is realized."),
       Max (1)
      ]
   CIM_PhysicalTape REF Antecedent;
      [Override ("Dependent"), Description (
        "The TapePartition that is located on the Media.")
      ]
   CIM_TapePartition REF Dependent;
};

// ===================================================================
// RealizedOnSide
// ===================================================================
   [Association, Description (
       "Since removable PhysicalMedia can be dual-sided, there is the "
       "possibility for StorageExtents to be realized on a single side "
       "of the Media. This association is a specialization of the "
       "RealizesExtent relationship, adding a Side property to express "
       "the Media's orientation details.")
   ]
class CIM_RealizedOnSide : CIM_RealizesExtent
{
      [Override ("Antecedent"), Description (
        "The PhysicalMedia on which the Extent is realized.")
      ]
   CIM_PhysicalMedia REF Antecedent;
      [Description (
        "An enumeration expressing on which 'Side' the Extent is "
        "realized. Since sides can be named by various schemes (0/1 or "
        "A/B), both schemes are expressed in the Values array of this "
        "property."),
       Values {"Unknown", "Side 0", "Side 1", "Side A", "Side B"}
     ]
   uint16 Side;
};

// ==================================================================
// PhysicalLink
// ==================================================================
   [Description (
	 "The PhysicalLink class represents the cabling of "
	 "PhysicalElements together. For example, serial or Ethernet "
	 "cables, and infrared Links would be subclasses (if additional "
	 "properties or associations are defined) or instances of "
	 "PhysicalLink. In many cases, the numerous physical cables "
	 "within a PhysicalPackage or Network will not be modeled. "
	 "However, where these cables or Links are critical components, "
	 "or are tagged assets of the company, these objects can be "
	 "instantiated using this class or one of its descendent "
	 "classes.")
   ]
class CIM_PhysicalLink : CIM_PhysicalElement
{
	[Description ("The maximum length of the PhysicalLink in feet."),
	 Units ("Feet")
	]
   real64 MaxLength;
	[Description (
	  "The current length of the PhysicalLink in feet. For some "
	  "connections, especially wireless technologies, this property "
	  "may not be applicable and should be left uninitialized."),
	 Units ("Feet")
	]
   real64 Length;
	[Description (
	  "Boolean indicating whether the PhysicalLink is an actual "
	  "cable (TRUE) or a wireless connection (FALSE).")
	]
   boolean Wired;
	[Description("The MediaType property defines the particular "
	  "type of Media through which transmission signals pass. "
	  "Common network media include twisted-pair (value=11 or 12), "
	  "coaxial (7, 8 or 9) and fiber-optic cable (10)."),
       Values {"Unknown", "Other", "Cat1", "Cat2", "Cat3", "Cat4", 
             "Cat5", "50-ohm Coaxial", "75-ohm Coaxial", 
             "100-ohm Coaxial", "Fiber-optic", "UTP", "STP", 
             "Ribbon Cable", "Twinaxial", "Optical 9um", 
             "Optical 50um", "Optical 62.5um"},
		MappingStrings {"MIF.DMTF|Fibre Channel Bus Port Extensions|001.4"}  
	]
   uint16 MediaType;
};

// ===================================================================
// ElementsLinked
// ===================================================================
   [Association, 
    Description (
	 "The ElementsLinked association indicates which Physical"
	 "Elements are cabled together by a PhysicalLink.")
   ]
class CIM_ElementsLinked : CIM_Dependency
{
	[Override ("Antecedent"),
	 Description ("The PhysicalLink.")
	]
   CIM_PhysicalLink REF Antecedent;
	[Override ("Dependent"), 
	 Description ("The PhysicalElement that is linked.")
	]
   CIM_PhysicalElement REF Dependent;
};

// ==================================================================
// PhysicalConnector
// ==================================================================
   [Description (
	 "The PhysicalConnector class represents any PhysicalElement "
	 "that is used to connect to other Elements. Any object that "
	 "can be used to connect and transmit signals or power between "
	 "two or more PhysicalElements is a descendant (or member) "
	 "of this class. For example, Slots and D-shell connectors are "
	 "types of PhysicalConnectors.")
   ]
class CIM_PhysicalConnector : CIM_PhysicalElement
{
	[Description (
	  "A free-form string describing the pin configuration and "
	  "signal usage of a PhysicalConnector.")
	]
   string ConnectorPinout;
	[Description (
	  "An array of integers defining the type of PhysicalConnector. "
	  "An array is specified to allow the description of "
	  "'combinations' of Connector information. For example, one "
	  "array entry could specify RS-232 (value=25), another DB-25 "
	  "(value=23) and a third entry define the Connector as \"Male\" "
	  "(value=2)."),
       Values {"Unknown", "Other", "Male", "Female", "Shielded",
             "Unshielded", "SCSI (A) High-Density (50 pins)",
             "SCSI (A) Low-Density (50 pins)",
             "SCSI (P) High-Density (68 pins)", "SCSI SCA-I (80 pins)",
             "SCSI SCA-II (80 pins)", "Fibre Channel (DB-9, Copper)",
             "Fibre Channel (Optical Fibre)",
             "Fibre Channel SCA-II (40 pins)", 
             "Fibre Channel SCA-II (20 pins)", "Fibre Channel BNC",
             "ATA 3-1/2 Inch (40 pins)", "ATA 2-1/2 Inch (44 pins)",
             "ATA-2", "ATA-3", "ATA/66", "DB-9", "DB-15", "DB-25",
             "DB-36", "RS-232C", "RS-422", "RS-423", "RS-485", "RS-449",
             "V.35", "X.21", "IEEE-488", "AUI", "UPT Category 3",
             "UPT Category 4", "UPT Category 5", "BNC", "RJ11", "RJ45",
             "Fiber MIC", "Apple AUI", "Apple GeoPort", "PCI", "ISA",
             "EISA", "VESA", "PCMCIA", "PCMCIA Type I",
             "PCMCIA Type II", "PCMCIA Type III", "ZV Port", "CardBus",
             "USB", "IEEE 1394", "HIPPI", "HSSDC (6 pins)", "GBIC",
             "DIN", "Mini-DIN", "Micro-DIN", "PS/2", "Infrared",
             "HP-HIL", "Access.bus", "NuBus", "Centronics",
             "Mini-Centronics", "Mini-Centronics Type-14",
             "Mini-Centronics Type-20", "Mini-Centronics Type-26",
             "Bus Mouse", "ADB", "AGP", "VME Bus", "VME64",
             "Proprietary", "Proprietary Processor Card Slot",
             "Proprietary Memory Card Slot", "Proprietary I/O Riser Slot",
             "PCI-66MHZ", "AGP2X", "AGP4X", "PC-98", "PC-98-Hireso",
             "PC-H98", "PC-98Note", "PC-98Full", "SSA SCSI",
             "Circular", "On Board IDE Connector", 
             "On Board Floppy Connector", "9 Pin Dual Inline", 
             "25 Pin Dual Inline", "50 Pin Dual Inline",
             "68 Pin Dual Inline", "On Board Sound Connector", 
             "Mini-jack", "PCI-X", "Sbus IEEE 1396-1993 32 bit",
             "Sbus IEEE 1396-1993 64 bit", "MCA", "GIO", "XIO", 
             "HIO", "NGIO", "PMC", "MTRJ", "VF-45", "Future I/O",
             "SC", "SG", "Electrical", "Optical", "Ribbon", "GLM", 
             "1x9", "Mini SG", "LC", "HSSC","VHDCI Shielded (68 pins)",
			 "InfiniBand"},
			 MappingStrings {"MIF.DMTF|Bus Port|003 and 12"}, 
			 ModelCorrespondence {"CIM_PhysicalConnector.OtherTypeDescription"}
	]
   uint16 ConnectorType[];
   			[Description (
			"A string describing the Connector - used when the "
			"ConnectorType property is set to 1 (\"Other\"). OtherType "
			"Description should be set to NULL when ConnectorType is any "
			"value other than 1."),
			ModelCorrespondence {"CIM_PhysicalConnector.ConnectorType"},
			MappingStrings {"MIF.DMTF|Bus Port|003"}
			]
	string OtherTypeDescription;

};

// ===================================================================
// ConnectedTo
// ===================================================================
   [Association,
    Description ("The ConnectedTo association indicates that two or "
       "more PhysicalConnectors are connected together.")
   ] 
class CIM_ConnectedTo : CIM_Dependency
{
      [Override ("Antecedent"),
       Description ("The Antecedent represents a PhysicalConnector "
        "that serves as one end of the connection.")
      ]
   CIM_PhysicalConnector REF Antecedent;
      [Override ("Dependent"),
       Description (
	  "The Dependent represents another PhysicalConnector "
        "that serves as the other end of the connection.")
      ]
   CIM_PhysicalConnector REF Dependent;
};

// ===================================================================
// Slot
// ===================================================================
   [Description (
       "The Slot class represents Connectors into which Packages are "
       "inserted. For example, a PhysicalPackage that is a DiskDrive "
       "may be inserted into an SCA 'Slot'. As another example, "
       "a Card (subclass of PhysicalPackage) may be inserted into "
       "a 16-, 32-, or 64-bit expansion 'Slot' on a HostingBoard. "
       "PCI or PCMCIA Type III Slots are examples of the latter.")
   ]
class CIM_Slot : CIM_PhysicalConnector
{
		[Override ("ConnectorType"),
		 MappingStrings {"MIF.DMTF|System Slot|005.2"}
		]
   uint16 ConnectorType[];
		[Description (
		  "Boolean indicating whether the Slot supports hot-plug of "
		  "adapter Cards.")
		]
   boolean SupportsHotPlug;
		[Description (
		  "Maximum height of an adapter Card that can be inserted into "
		  "the Slot, in inches."),
		 Units ("Inches")
		]
   real32 HeightAllowed;
		[Description (
		  "Maximum length of an adapter Card that can be inserted into "
		  "the Slot, in inches."),
		 Units ("Inches")
		]
   real32 LengthAllowed;
		[Description (
		  "Maximum bus width of adapter Cards that can be inserted into "
		  "this Slot, in bits. If the value is 'unknown', enter 0. If "
			"the value is other than 8, 16, 32, 64 or 128, enter 1."),
		 Units ("Bits"),
		 ValueMap {"0", "1", "8", "16", "32", "64", "128"},
		 MappingStrings {"MIF.DMTF|System Slot|005.3"}
		]
   uint16 MaxDataWidth;
		[Description (
		  "An array of enumerated integers indicating the Vcc voltage "
		  "supported by this Slot."),
		 Values {"Unknown", "Other", "3.3V", "5V"},
		 MappingStrings {"MIF.DMTF|System Slot|005.9"}
		]
   uint16 VccMixedVoltageSupport[];
		[Description (
		  "An array of enumerated integers indicating the Vpp voltage "
		  "supported by this Slot."),
		 Values {"Unknown", "Other", "3.3V", "5V", "12V"},
		 MappingStrings {"MIF.DMTF|System Slot|005.10"}
		]
   uint16 VppMixedVoltageSupport[];
		[Description (
		  "Maximum thermal dissipation of the Slot in milliwatts."),
		 Units ("MilliWatts"),
		 MappingStrings {"MIF.DMTF|System Slot|005.11"}
		]
   uint32 ThermalRating;
		[Description (
		  "Boolean indicating that this Slot is physically unique "
		  "and may hold special types of hardware, e.g. a graphics "
		  "processor slot. If set to TRUE, then the property, Special"
		  "PurposeDescription (a string), should specify the nature of "
		  "the uniqueness or purpose of the Slot."),
		 ModelCorrespondence {"CIM_Slot.PurposeDescription"}
		]
   boolean SpecialPurpose;
		[Description ("A free-form string describing that this Slot is "
		  "physically unique and may hold special types of hardware. "
		  "This property only has meaning when the corresponding "
		  "boolean property, SpecialPurpose, is set to TRUE."),
		 ModelCorrespondence {"CIM_Slot.SpecialPurpose"}
		]
   string PurposeDescription;
		[Description ("The Number property indicates the physical slot "
		  "number, which can be used as an index into a system "
		  "slot table, whether or not that slot is physically occupied."),
		  MappingStrings {"MIF.DMTF|System Slot|005.1"} 
		]
   uint16 Number;
   		[Description (
		"A boolean indicating whether the Slot is currently "
		"powered (TRUE) or not (FALSE)."),
		MappingStrings {"MIF.DMTF|System Slot|005.13"}
		]
	boolean Powered;

		[Description (
		"A boolean indicating whether the switch state of the Slot "
		"is currently open (TRUE) or closed (FALSE). This switch state "
		"determines whether the contents of the Slot can be hot-plugged."),
		MappingStrings {"MIF.DMTF|System Slot|005.15"}
		]
	boolean OpenSwitch;

};

// ==================================================================
// SlotInSlot 
// ==================================================================
   [Association,
    Description ("Slots are special types of Connectors into which "
	 "adapter Cards are typically inserted. The SlotInSlot "
	 "relationship represents the ability of a special adapter to "
	 "extend the existing Slot structure to enable otherwise "
	 "incompatible Cards to be plugged into a Frame or Hosting"
	 "Board. The adapter effectively creates a new Slot and can "
	 "be thought of (conceptually) as a Slot in a Slot. This "
	 "enables Cards that would otherwise be physically and/or "
	 "electrically incompatible with the existing Slots to be "
	 "supported, by interfacing to the Slot provided by the "
	 "adapter. This has many practical uses. For example, "
	 "networking boards are very expensive. As new hardware "
	 "becomes available, Chassis and even Card configurations "
	 "change. To protect the investment of their customers, "
	 "networking vendors will manufacture special adapters "
	 "that enable old Cards to fit into new Chassis or Hosting"
	 "Boards and/or new Cards to fit into old. This is done using "
	 "a special adapter that fits over one or more existing Slots "
	 "and presents a new Slot into which the Card can plug.")
   ]
class CIM_SlotInSlot : CIM_ConnectedTo
{
	[Override ("Antecedent"),
       Description ("The Antecedent represents the existing Slot(s) "
        "of the HostingBoard, or Frame that are being adapted "
        "to accommodate a Card that would otherwise not be "
        "physically and/or electrically compatible with it.")
      ]
   CIM_Slot REF Antecedent;
      [Override ("Dependent"),
       Max (1),
       Description ("The new Slot provided by the adapter board.")
      ]
   CIM_Slot REF Dependent;
};

// ==================================================================
// AdjacentSlots
// ==================================================================
   [Association,
    Description ("AdjacentSlots describes the layout of Slots on a "
       "HostingBoard or adapter Card.  Information like the distance "
       "between the Slots and whether they are 'shared' (if one is "
       "populated, then the other Slot can not be used), is conveyed "
       "as properties of the association.")
   ]
class CIM_AdjacentSlots
{
      [Key, Description ("One of the adjacent Slots.")]
   CIM_Slot REF SlotA;
      [Key, Description ("The 'other' adjacent Slot.")]
   CIM_Slot REF SlotB;
      [Description ("The distance, in inches, between adjacent Slots."),
       Units ("Inches")
      ]
   real32 DistanceBetweenSlots;
      [Description ("Slots can be located in close proximity on Hosting"
        "Boards or other Cards, such that if one of these Slots is "
        "populated by an adapter Card, the other Slot must be left "
        "empty. This relationship is indicated by the SharedSlots "
        "boolean set to TRUE.")]
   boolean SharedSlots;
};

// ==================================================================
// PackageInConnector 
// ==================================================================
   [Association, 
    Description (
        "Adapter cards and other 'packaging' are plugged into System "
        "Connectors for power and/or to transfer data. This "
        "relationship is defined by PackageInConnector. For example, "
        "it would be used to describe the insertion of a daughtercard "
        "onto another Card. Various subclasses of PackageInConnector "
        "are also defined. PackageInSlot and its subclass, "
        "CardInSlot, are two examples of subclasses.")
   ]
class CIM_PackageInConnector : CIM_Dependency
{
      [Override ("Antecedent"), Description (
        "The Connector into which the Package is inserted.")
      ]
   CIM_PhysicalConnector REF Antecedent;
      [Override ("Dependent"), Max (1), 
       Description ("The Package in the Connector.")
      ]
   CIM_PhysicalPackage REF Dependent;
};

// ==================================================================
// PackageInSlot 
// ==================================================================
   [Association,
    Description ("Complex networking devices often are Chassis-based. "
	 "These Chassis allow for enhancement and/or augmentation of "
	 "their base functionality by accepting additional Chassis "
       "devices, similar to accepting functionality in the form of "
	 "adding Cards. This association models this capability.")
   ]
class CIM_PackageInSlot : CIM_PackageInConnector
{
      [Override ("Antecedent"),
       Description (
	  "The Slot into which the PhysicalPackage is inserted.")
      ]
   CIM_Slot REF Antecedent;
      [Override ("Dependent"),
       Max (1),
       Description ("The Package in the Slot.")
      ]
   CIM_PhysicalPackage REF Dependent;
};

// ==================================================================
// CardInSlot 
// ==================================================================
   [Association,
    Description (
       "Slots are special types of Connectors into which adapter "
	 "Cards are inserted. This relationship of a Card in a Slot "
       "is made explicit using the CardInSlot association."),
    MappingStrings {"MIF.DMTF|System Slot|005.4"}
   ]
class CIM_CardInSlot : CIM_PackageInSlot
{
	[Override ("Antecedent"),
	 Description ("The Slot into which the Card is inserted.")
	]
   CIM_Slot REF Antecedent;
 	[Override ("Dependent"),
	 Max (1),
	 Description ("The Card in the Slot.")]
   CIM_Card REF Dependent;
};

// ==================================================================
// LinkHasConnector 
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "Cables and Links utilize PhysicalConnectors to actually "
	 "'connect' PhysicalElements. This association explicitly "
	 "defines this relationship of Connectors for PhysicalLinks.")
   ]
class CIM_LinkHasConnector : CIM_Component
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description ("The PhysicalLink that has a Connector.")
	]
   CIM_PhysicalLink REF GroupComponent;
	[Override ("PartComponent"),
	 Description ("The PhysicalConnector.")
	]
   CIM_PhysicalConnector REF PartComponent;
};

// ==================================================================
// ConnectorOnPackage 
// ==================================================================
   [Association,
    Aggregation,
    Description (
	 "PhysicalPackages contain Connectors as well as other "
	 "PhysicalElements. The ConnectorOnPackage association makes "
	 "explicit the containment relationship between Connectors and "
	 "Packages.")
   ]
class CIM_ConnectorOnPackage : CIM_Container
{
	[Override ("GroupComponent"),
	 Aggregate, Max (1),
	 Description ("The PhysicalPackage that has a Connector.")
	]
   CIM_PhysicalPackage REF GroupComponent;
	[Override ("PartComponent"),
	 Description ("The PhysicalConnector.")
	]
   CIM_PhysicalConnector REF PartComponent;
};

// ===================================================================
// AdapterActiveConnection 
// ===================================================================
   [Association, 
    Description (
       "The AdapterActiveConnection relationship indicates that a "
       "NetworkAdapter is using the referenced PhysicalConnector "
       "to output to the network. This relationship is important when "
       "the Adapter can choose to output from one of several "
       "Connectors. The Connectors may be associated with the "
       "NetworkAdapter in a Realizes relationship - but this is not "
       "required. This association provides additional information "
       "(i.e., 'in use for communication') different than Realizes.")
   ]
class CIM_AdapterActiveConnection : CIM_Dependency
{
      [Override ("Antecedent"), 
       Description ("The PhysicalConnector.")
      ]
   CIM_PhysicalConnector REF Antecedent;
      [Override ("Dependent"), 
       Description (
        "The NetworkAdapter that transmits using the Connector.")
      ]
   CIM_NetworkAdapter REF Dependent;
};

// ==================================================================
// ComputerSystemPackage  
// ==================================================================
   [Association, 
    Description (
	 "Similar to the way that LogicalDevices are 'Realized' by "
	 "PhysicalElements, UnitaryComputerSystems are realized in "
	 "one or more PhysicalPackages. The ComputerSystemPackage "
	 "association explicitly defines this relationship.")
   ]
class CIM_ComputerSystemPackage : CIM_Dependency
{
	[Override ("Antecedent"),
	 Description (
	  "The PhysicalPackage(s) that realize a UnitaryComputerSystem.")
	]
   CIM_PhysicalPackage REF Antecedent;
	[Override ("Dependent"),
	 Description ("The UnitaryComputerSystem.")
	]
   CIM_UnitaryComputerSystem REF Dependent;
      [Description(
        "A Gloabally Unique Identifier for the System's Package.")
      ]
   string PlatformGUID;
}; 

// ==================================================================
// LibraryPackage 
// ==================================================================
   [Association, Description (
       "Similar to the way that LogicalDevices are 'Realized' by "
       "PhysicalElements, a StorageLibrary can be realized in one or "
       "more PhysicalPackages. The LibraryPackage association "
       "explicitly defines this relationship.")
   ]
class CIM_LibraryPackage : CIM_Dependency
{
      [Override ("Antecedent"), Description (
        "The PhysicalPackage(s) that realize a StorageLibrary.")
      ]
   CIM_PhysicalPackage REF Antecedent;
      [Override ("Dependent"), 
       Description ("The StorageLibrary.")
      ]
   CIM_StorageLibrary REF Dependent;
};

// ==================================================================
// PackageCooling  
// ==================================================================
   [Association,
    Description (
	 "Often, a CoolingDevice is installed in a Package such as "
	 "a Chassis or a Rack, not for a specific Device, but to assist "
	 "in the cooling of the Package in general.  This relationship "
	 "is described by the PackageCooling association.")
   ]
class CIM_PackageCooling : CIM_Dependency
{
	[Override ("Antecedent"),
	 Description ("The CoolingDevice for the Package.")
	]
   CIM_CoolingDevice REF Antecedent;
	[Override ("Dependent"),
	 Description (
	  "The PhysicalPackage whose environment is cooled.")
	]
   CIM_PhysicalPackage REF Dependent;
};

// ==================================================================
// PackageTempSensor 
// ==================================================================
   [Association,
    Description (
	 "Often, a TemperatureSensor is installed in a Package such as "
	 "a Chassis or a Rack, not to measure any particular Device, but "
	 "the Package's environment in general.  This relationship is "
	 "described by the PackageTempSensor association.")
   ]
class CIM_PackageTempSensor : CIM_Dependency
{
	[Override ("Antecedent"),
	 Description ("The TemperatureSensor for the Package.")
	]
   CIM_TemperatureSensor REF Antecedent;
	[Override ("Dependent"),
	 Description (
	  "The PhysicalPackage whose environment is monitored.")
	]
   CIM_PhysicalPackage REF Dependent;
};

// ==================================================================
// PackageAlarm 
// ==================================================================
   [Association, 
    Description (
	 "Often, an AlarmDevice is installed as part of a Package, "
	 "not to indicate issues with any particular LogicalDevice "
	 "or PhysicalComponent, but with the Package's environment "
	 "in general, its security state or its overall health. " 
	 "This relationship is described by the PackageAlarm "
	 "association. ")
   ]
class CIM_PackageAlarm : CIM_Dependency
{
	[Override ("Antecedent"), 
	 Description ("The AlarmDevice for the Package. ")
	]
   CIM_AlarmDevice REF Antecedent;
	[Override ("Dependent"), 
	 Description (
	  "The PhysicalPackage whose health, security, environment, "
	  "etc. is alarmed. ")
	]
   CIM_PhysicalPackage REF Dependent;
};

// ===================================================================
// HomeForMedia
// ===================================================================
   [Association, Description (
       "  In a StorageLibrary or repository for PhysicalMedia, it is "
       "reasonable that a specific Media always be placed in a "
       "specific Location (rather than anywhere in the repository/"
       "Library).  The default location for a PhysicalMedia is called "
       "its 'home'. This information is expressed by the HomeForMedia "
       "dependency association. (Note that a PhysicalMedia can have at "
       "most one 'home', and a StorageMediaLocation can be 'home' to "
       "at most one Media.)" )
   ]
class CIM_HomeForMedia : CIM_Dependency
{
      [Override ("Antecedent"), Max (1), Description (
        "The Location that is 'home' to a piece of PhysicalMedia.")
      ]
   CIM_StorageMediaLocation REF Antecedent;
      [Override ("Dependent"), Max (1), Description (
        "The PhysicalMedia whose 'home' or default Location is defined.")
      ]
   CIM_PhysicalMedia REF Dependent;
};

// ==================================================================
// end of file
// ==================================================================
